{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/images/cpp.png","path":"images/cpp.png","modified":1,"renderable":0},{"_id":"source/images/footertime.png","path":"images/footertime.png","modified":1,"renderable":0},{"_id":"source/images/hello.png","path":"images/hello.png","modified":1,"renderable":0},{"_id":"source/images/rightsides.png","path":"images/rightsides.png","modified":1,"renderable":0},{"_id":"themes/stellar/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/plugins/copycode.js","path":"js/plugins/copycode.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/fcircle.js","path":"js/services/fcircle.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/friends.js","path":"js/services/friends.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/mdrender.js","path":"js/services/mdrender.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/ghinfo.js","path":"js/services/ghinfo.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/memos.js","path":"js/services/memos.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/siteinfo.js","path":"js/services/siteinfo.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/sites.js","path":"js/services/sites.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/timeline.js","path":"js/services/timeline.js","modified":1,"renderable":1},{"_id":"themes/stellar/source/js/services/weibo.js","path":"js/services/weibo.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"8fc90704eebe1b03a6ba55f42ad2a319cd0cd6dc","modified":1717033580711},{"_id":"source/_data/.DS_Store","hash":"8d2dd4080bc8b1a67ee6859552869c51cdd3d56e","modified":1715233388589},{"_id":"source/_data/wiki.yml","hash":"0866bb44893c23766b1f6a0fbfd359669d2286b0","modified":1717732507732},{"_id":"source/_data/widgets.yml","hash":"574136777d8e9c06ed9642afce9f68c21b46d20b","modified":1717732510256},{"_id":"source/friends/.DS_Store","hash":"34fe290bc8d934cf4c51deea76c7ec16f3cf4d2f","modified":1715172237612},{"_id":"source/friends/index.md","hash":"d0be64a4d0f97be7e549cac36b1acb4375fcb480","modified":1715233300236},{"_id":"source/about/.DS_Store","hash":"34fe290bc8d934cf4c51deea76c7ec16f3cf4d2f","modified":1715604031186},{"_id":"source/about/index.md","hash":"7701f25974ba7789a02aa49db26fa35467c1fa04","modified":1716904876180},{"_id":"source/_posts/.DS_Store","hash":"62431ce00e7db01601d4d9dec7bde0262c7f09c4","modified":1717034480450},{"_id":"source/_posts/CPP基础.md","hash":"9d3bec8e8e4dd91cb5412843c9544a55ef1d954f","modified":1717729500484},{"_id":"source/_posts/CppLearn.md","hash":"538421cb5e1eb3a82c7b53c107b9fc68a90f16a4","modified":1717733235146},{"_id":"source/_posts/QT学习.md","hash":"0782e5c8cbd59848e359e5840629b7581ab657be","modified":1717729515767},{"_id":"source/_posts/SVN 操作笔记.md","hash":"8c6c92e113582586dc9c210c7db8ccbd6f05ce35","modified":1717729519988},{"_id":"source/_posts/VS去除程序运行时的控制台【黑框】.md","hash":"0e7dc0c640dd1c666fc6fac13a24209ad180dc7a","modified":1717729524868},{"_id":"source/_posts/hello-world.md","hash":"f8789311d746c1bd0d6ce177b24bedb2f2b036bc","modified":1717732402871},{"_id":"source/_posts/代码随想录.md","hash":"ee11d6680c5f24ab6a729d3c1491071a9eea2137","modified":1717729440281},{"_id":"source/_posts/哈希表part01.md","hash":"bba3182e986cf5b55fb808d9db33ccc6732d23fd","modified":1717729447016},{"_id":"source/_posts/数组part02.md","hash":"99125eebe43f040d5a53df529f065253728b7607","modified":1717729495635},{"_id":"source/_posts/数组part01.md","hash":"53a23eca5e357430e384827820adff2109718805","modified":1717729490706},{"_id":"source/_posts/链表part01.md","hash":"165d2567318018afd628dda0c1ea54551865010a","modified":1717729476526},{"_id":"source/_posts/神印王座.md","hash":"9194496d4746f52ae5e70b67f41e28857e2517c5","modified":1717729486092},{"_id":"source/_posts/链表part02.md","hash":"3daf787589bb1f71d5f0159699cb7caa5dea871f","modified":1717729821610},{"_id":"source/_posts/链表基础知识.md","hash":"8e7cb5d4dde3311f17cd472dde8d25e0baa64c23","modified":1717729470493},{"_id":"source/images/.DS_Store","hash":"41f6eb90db919907ac1214ee818a6d9fd0f1795a","modified":1715136386740},{"_id":"source/_data/links/ios_developer.yml","hash":"a170100cd4a1aae8743fa4594e8738895613cdab","modified":1715176822274},{"_id":"source/_data/wiki/hexo-stellar.yml","hash":"37c30a7cb8991b7883cda36fb6c7e83ef5fa4d55","modified":1717732515536},{"_id":"source/images/footertime.png","hash":"2685c80c3d4adc78fb0cc62d7748790c1b44ac94","modified":1715134411927},{"_id":"source/images/rightsides.png","hash":"ef5a8a108dda04d2d0b36e3f8f54b018a9b01ec2","modified":1715135341077},{"_id":"source/images/hello.png","hash":"956e5356a7a52413c55528263ef3d36985f60053","modified":1715156580309},{"_id":"themes/stellar/layout/_partial/widgets/search.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1715096705650},{"_id":"themes/stellar/source/css/_components/widgets/tree.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1715096705662},{"_id":"source/images/cpp.png","hash":"cac666de63d2b5859da0ff3cde93f58e958cd927","modified":1715240989948},{"_id":"themes/stellar/.npmignore","hash":"9f66a3a5bea36f32c51cbfff88f1a45b74c80592","modified":1715134073422},{"_id":"themes/stellar/.gitignore","hash":"cf4e2dcaa760ff6f7520fd032ce44574e2970e54","modified":1715134073422},{"_id":"themes/stellar/LICENSE","hash":"7fdfdb5dbc7d672fa28a2a3c9efa03ff8df5917d","modified":1715096705646},{"_id":"themes/stellar/_config.yml","hash":"4bbb17f0885f1ddfe9a9818cebd49c1aa0707b2e","modified":1715096705646},{"_id":"themes/stellar/giscus.json","hash":"af57a96a9dc188079bdcd0ad4273f1765778f5ea","modified":1715096705646},{"_id":"themes/stellar/npm-publish.sh","hash":"b137d2f0d48fccd065ba1750b886f33ad7a7236a","modified":1715096705652},{"_id":"themes/stellar/package.json","hash":"51a2607b053e4520577e055a773e4bccdd95539c","modified":1715096705652},{"_id":"themes/stellar/_data/widgets.yml","hash":"574136777d8e9c06ed9642afce9f68c21b46d20b","modified":1715096705646},{"_id":"themes/stellar/_data/icons.yml","hash":"59ff2162c2974fb64b6da769dda331bdf0da35da","modified":1715096705646},{"_id":"themes/stellar/layout/404.ejs","hash":"d84f01256feb3c0bc0b280031fb78ae9f0d86f26","modified":1715096705646},{"_id":"themes/stellar/languages/en.yml","hash":"7befcf94a88c79d495431dd7fcd4e9496b8e398c","modified":1715096705646},{"_id":"themes/stellar/README.md","hash":"d474d9b14cafda27ab291336cbdb4ac91bfec756","modified":1715096705646},{"_id":"themes/stellar/languages/zh-TW.yml","hash":"653d54b0d5146e7bf146793a43557a95736e465e","modified":1715096705646},{"_id":"themes/stellar/layout/categories.ejs","hash":"eaf71831abd6780690f26fa1a7cf83bc6f08d7e9","modified":1715096705651},{"_id":"themes/stellar/layout/archive.ejs","hash":"af072e9b75e8d5371771237e71a1f1381078526a","modified":1715096705651},{"_id":"themes/stellar/languages/zh-CN.yml","hash":"dd31bdce070076d9d87be36e5a0ca7bdf5c1e2cb","modified":1715096705646},{"_id":"themes/stellar/layout/index.ejs","hash":"ea5fa65b2049bc1c4c8c247972a79310468e3c68","modified":1715096705652},{"_id":"themes/stellar/layout/index_topic.ejs","hash":"6bffb1488ce9c2c4b04386cb7fe61792ae5491f2","modified":1715096705652},{"_id":"themes/stellar/layout/index_wiki.ejs","hash":"9e7dc6941c5205ed60fa7abfb1f36ae19e2f3834","modified":1715096705652},{"_id":"themes/stellar/layout/layout.ejs","hash":"879a2b082abe4c4de51a8f4bc2095f8f6105cc79","modified":1715096705652},{"_id":"themes/stellar/layout/page.ejs","hash":"995522b7ed87fc89b8d70f650703363601e36174","modified":1715096705652},{"_id":"themes/stellar/layout/tags.ejs","hash":"4ff8ccff9a9c8d373df788fbc0bebdc87302056e","modified":1715096705652},{"_id":"themes/stellar/.github/ISSUE_TEMPLATE/article-share.md","hash":"f88a131062c94d8dadd0536e841966bf8547e1a7","modified":1715134073422},{"_id":"themes/stellar/layout/_partial/head.ejs","hash":"78287469a403a326295561d1b590fd1cd822452c","modified":1715096705648},{"_id":"themes/stellar/.github/configs/label-commenter-config.yml","hash":"acae6f9e872bd6a462e711771aeedcb7cdca0a86","modified":1715134073422},{"_id":"themes/stellar/.github/workflows/label-commenter.yml","hash":"f89d116ba78e3fd4a0695c2ac4176e46e3c92028","modified":1715134073422},{"_id":"themes/stellar/layout/_partial/menubtn.ejs","hash":"36775d16431301a6ac02858f32a8ee470ef8332f","modified":1715096705649},{"_id":"themes/stellar/.github/ISSUE_TEMPLATE/any-question.yaml","hash":"312caa37c7c3090b496167e6da5f82099ca4de4e","modified":1715134073422},{"_id":"themes/stellar/.github/workflows/npm-publish.yml","hash":"9e95a1f04628056117df5ab8615acd36f3d63283","modified":1715134073422},{"_id":"themes/stellar/layout/_partial/scripts.ejs","hash":"4cce2274152e4933bf2c3cb05c86d788f3b65eb4","modified":1715096705649},{"_id":"themes/stellar/layout/_plugins/copycode.ejs","hash":"7cedd8eced00f6813f7d772334ec92acbc8bd982","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/fancybox.ejs","hash":"dcb638d9320eea6c9a6b7b0212e6167341bec05b","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/heti.ejs","hash":"c3956c8fd5fabd4ec8cea05dc076bf7a03eb012a","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/index.ejs","hash":"29407e95f14d4d50c1f8a8b9a5af242927676432","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/mathjax.ejs","hash":"c1621e718747a6eb34734e7e4a8364f5a78dc714","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/lazyload.ejs","hash":"e2b07b0c97d531c82cc02a80610fe0c1a39bc837","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/mermaid.ejs","hash":"8ef22ac075890554521f464f6b92dc1fb7538b37","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/swiper.ejs","hash":"b80d6185c0263375df82498705a98ad32238b12f","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/scrollreveal.ejs","hash":"1f3b98068a4db7ec709b47e134520af16f59fa71","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/preload.ejs","hash":"f25523da5633b249da8cebe7c866265bf7825697","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/tianli_gpt.ejs","hash":"961b9131a2f0e30afa94c6a3c35dd7869b69f0cc","modified":1715096705651},{"_id":"themes/stellar/scripts/events/index.js","hash":"38e64f33a00ee328d22774890dc963c1196bd7f1","modified":1715096705652},{"_id":"themes/stellar/scripts/filters/index.js","hash":"5667f028990dd556133080090a5fcb00c64f05ac","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/404.js","hash":"66b53d2b35b18d5f3835b47467c23f31eb322553","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/author.js","hash":"0de0824fdbc4f67c84910267901095504b253751","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/categories.js","hash":"936d4d406fd401359bab1e5f74c6e1e097e8f092","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/search.js","hash":"404f28ea5d77cee462a551d8f74c9f7c41f73ba0","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/tags.js","hash":"ed29755154d8e7a9346019ba4ac8782a8649b177","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/topic.js","hash":"88c0f2990365fb0ce751682815e07f36cf333d3f","modified":1715096705653},{"_id":"themes/stellar/scripts/generators/wiki.js","hash":"61efe22787c3fea9d935df4b088a9dd2d1af0868","modified":1715096705653},{"_id":"themes/stellar/scripts/helpers/icon.js","hash":"b7c84be7f08abc1725f351ed8718791a861466c3","modified":1715096705654},{"_id":"themes/stellar/scripts/helpers/category_color.js","hash":"20b19d6b6307cdeb0b0832bf4931366abe972490","modified":1715096705653},{"_id":"themes/stellar/scripts/helpers/parse_config.js","hash":"1251d82318972f22283dc7a089b77a3f0135b1b6","modified":1715096705654},{"_id":"themes/stellar/scripts/helpers/related_posts.js","hash":"6763a97fa25669fa1d1aa8e5291919deb5dc7f67","modified":1715096705654},{"_id":"themes/stellar/scripts/helpers/stellar_info.js","hash":"5b7a10c8b09237a467767f5467749c7d9378c2c1","modified":1715096705654},{"_id":"themes/stellar/scripts/helpers/utils.js","hash":"05c127baa250b192c9c673355bf90d7134e1ea11","modified":1715096705654},{"_id":"themes/stellar/scripts/helpers/scrollreveal.js","hash":"57e3da4a3dd751b3ebd384a674e26f08f69da018","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/index.js","hash":"9276f2e8f476699b682b3a4de6e1c6bddc971f99","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/inline-labels.js","hash":"a9cb7520af8a95f467c048128c036cbb3167fb8d","modified":1715096705654},{"_id":"themes/stellar/source/css/_custom.styl","hash":"58e0e4d48aa890a48604873e76cb8a44a04b6d3d","modified":1715096705662},{"_id":"themes/stellar/source/css/main.styl","hash":"44b5008a50682b442f38f1cc2ffd117e4dfc9ec5","modified":1715096705663},{"_id":"themes/stellar/layout/_partial/comments/script.ejs","hash":"62be59ef634ceee342c81ecc4e23cb664cdbf620","modified":1715096705647},{"_id":"themes/stellar/source/js/main.js","hash":"ab563d681848bbfee4456fe269f1c1008678861e","modified":1715096705664},{"_id":"themes/stellar/layout/_partial/comments/layout.ejs","hash":"3dbdb141d295d25b4f67fd0e299c40baa38241a8","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/cover/index.ejs","hash":"4b317700640749b1e04e6d51a542a2bcd28c8b72","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/cover/wiki_cover.ejs","hash":"8374cf58d5cc52799b8e1c8af95dd84c65372173","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/cover/post_cover.ejs","hash":"59e6ae6726ded33e3d84208fd4a4872a6431fcc7","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/scripts/services.ejs","hash":"ebe96e8b8edef9f48c80cff0e97b588dc8a1c859","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/main/footer.ejs","hash":"77035746bd33687c47a2d7cd9c2cec9a7c19700d","modified":1717995404426},{"_id":"themes/stellar/layout/_partial/scripts/defines.ejs","hash":"93393f0fbd25f09363ada3adefd97ccb9ebd5893","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/scripts/sidebar.ejs","hash":"403b6986bfc54177a7ee3ddba9e0a55e7b79e3a1","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/sidebar/index_leftbar.ejs","hash":"5a0b325540f2f8804c1843f3a4881cc4682c08f6","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/scripts/theme.ejs","hash":"87022a734dc2f4be8549463111696bbbf6f950b1","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/scripts/utils.ejs","hash":"a2a0d37c33b05c9020dbebe457e53283bff72a95","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/sidebar/index_rightbar.ejs","hash":"2e32bd7776f8caffbfc11ccd3393611480690fbf","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/sidebar/menu.ejs","hash":"59d579a0eaec7572485d8d4d22341de79a890d00","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/author.ejs","hash":"4c7eab461e45a7a5863333e9904dadbed6c8ca0c","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/sidebar/search.ejs","hash":"058c19e09f2c702480ad543b194ae3fa187dc9da","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/ghissues.ejs","hash":"410f56e6da87e7a1476d033c6939a0241658a598","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/sidebar/logo.ejs","hash":"cd08385b0026953cd9adf5c22af528b9c3e924e7","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/widgets/ghrepo.ejs","hash":"e7d23ff8f8c96f77685e441c7f6040430d07a21a","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/linklist.ejs","hash":"813336cbbe4505e9be42d5682fd7b720dba25194","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/ghuser.ejs","hash":"5d8cf68b091f8bf4b88ac230495bc2dec561ad6a","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/related.ejs","hash":"ac6040f2067c799836d5dc4abacf0b879a156d88","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/markdown.ejs","hash":"7ce0ce941c55e42c545c1fffa77a3db07e1989b1","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/tagcloud.ejs","hash":"d95c26f84c7d9061ba3ef6188d58fa14f1c63bf3","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/timeline.ejs","hash":"745b384871291e0cf2f6ceb4a0c12989b4e8cd62","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/toc.ejs","hash":"63c01fb3c03187e214a9d19fc0ab72fd74031e3b","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/widgets/tree.ejs","hash":"2a7d37a843e32d073be4637bc17980e368a16003","modified":1715096705651},{"_id":"themes/stellar/layout/_plugins/search/algolia_search.ejs","hash":"654fa8e2d695e5aa16988dfcd7dfab1b9b27d6f9","modified":1715096705651},{"_id":"themes/stellar/layout/_partial/widgets/recent.ejs","hash":"a5fcb3be545dbbc6a57f3e6dda47c30114c74148","modified":1715096705650},{"_id":"themes/stellar/layout/_plugins/search/local_search.ejs","hash":"38a3641bb532583b699fda42175cb14242f07575","modified":1715096705651},{"_id":"themes/stellar/scripts/events/lib/config.js","hash":"ab74c3df31ad21b842d859af40c1131dbd8fd2d7","modified":1715096705652},{"_id":"themes/stellar/scripts/events/lib/authors.js","hash":"eedefb5430fc4176bdc2814c8a88295f0e524d10","modified":1715096705652},{"_id":"themes/stellar/scripts/events/lib/links.js","hash":"881cac75e4071d219a18156738e18eb397d83c00","modified":1715096705653},{"_id":"themes/stellar/scripts/events/lib/topic_tree.js","hash":"7f735f2573c87d202e2d4b845307d0725d619e8e","modified":1715096705653},{"_id":"themes/stellar/scripts/events/lib/doc_tree.js","hash":"e217f244af98b1151e7f57e9e77812f3a1e2ad78","modified":1715096705652},{"_id":"themes/stellar/scripts/events/lib/merge_posts.js","hash":"4e45b8dc5317f7d66bc14879ae6b5f972123ce5d","modified":1715096705653},{"_id":"themes/stellar/scripts/events/lib/utils.js","hash":"271ba6c8cc997e4f55b2e146a99bde8301818400","modified":1715096705653},{"_id":"themes/stellar/scripts/filters/lib/img_lazyload.js","hash":"b3dedcc1fc4189589e63d4fa6f169a70e9d63cd1","modified":1715096705653},{"_id":"themes/stellar/scripts/tags/lib/about.js","hash":"c9778c35c1ccd9f2018174bafbd37b23dd52cf62","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/lib/audio.js","hash":"9b094b16dce131a5c09373661c88a1de9b5326f7","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/lib/albums.js","hash":"9fd16a8ceffd1806c25582062af7a72eca0e5c56","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/lib/banner.js","hash":"1fceb77a37ecaddf38c03aa655eec878701427c0","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/lib/button.js","hash":"e0890a759335b1c5ad09db084bcf62073b2557cb","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/box.js","hash":"753ae16a343ae82628f2057bd9cf09ea376fdbb5","modified":1715096705654},{"_id":"themes/stellar/scripts/tags/lib/copy.js","hash":"d22a82b6fd9c96c7ac49677b427e6c629fa889d7","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/emoji.js","hash":"e10f68f69206fc6e9d0c478630be2b4514d328d7","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/folders.js","hash":"853a75c8b4f445f64a18420929c31865db30cd39","modified":1715096705655},{"_id":"themes/stellar/scripts/filters/lib/img_onerror.js","hash":"d44a8e20d4d537c0cf85b980e1fc3bc84865a2d3","modified":1715096705653},{"_id":"themes/stellar/scripts/tags/lib/folding.js","hash":"b1efa6e86b1f8f25a58376349f21117902e5bb01","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/frame.js","hash":"1251a8622260af8efc55c2f0aac8ee5cf79d9043","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/friends.js","hash":"da08a75ad3579464debe8da2dd57314bd641dbb2","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/gallery.js","hash":"56a9309b096cbe1876a1e8c2b7c3f692325135e1","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/ghcard.js","hash":"039ee39d8dba7c0aa0e267de38f9064b30855a55","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/grid.js","hash":"dad59b638c2fd30538e3a69bf0c8d76d34cf3ece","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/checkbox.js","hash":"69caf7488b6c92cb2524df81ece6f33a46a89fe0","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/icon.js","hash":"273898ae29a07c1baccb432efa0d33ccfabe7db9","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/image.js","hash":"aa10441f0ec79b2f33829e5b1b8b4b4c21d865e9","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/hashtag.js","hash":"f38ce98fff40ed35be9b1f1be3194bc4c5d44dc3","modified":1715096705655},{"_id":"themes/stellar/scripts/tags/lib/mark.js","hash":"cfd8198f349dba60fbdf53042b6ebd9a0ba521c7","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/md.js","hash":"6ed5db6d055dbfe01ecaeddbd0ead13a20ba7e74","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/link.js","hash":"8a1297c324749f98e24036d3aa91ad374ad1d930","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/note.js","hash":"a70d1fcb440ad029ddddb72b053a59b1ed3bfef8","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/navbar.js","hash":"e78ca3469c44362c7d8c3ad8899f49a119b326ff","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/okr.js","hash":"8e7a7d912e4f5e1fe1feb6125e4762c378b11ba3","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/quot.js","hash":"e87c2d55973a688837072e3d0b7cfdffc58dde5b","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/sites.js","hash":"298f42f3097a19e5d229099964e15dac7d46e1b0","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/posters.js","hash":"713e1367f3a60e5903954a8fab15b0d9d9cfd89a","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/swiper.js","hash":"dc025c79b190d233383fec001ddbe478f2675cc8","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/tabs.js","hash":"1b3d7b6b962293b44430e7b40560b8d1fa5c618d","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/timeline.js","hash":"f1defeed67e56c055f37ee7fab8a597a9d14f89e","modified":1715096705656},{"_id":"themes/stellar/scripts/tags/lib/toc.js","hash":"d7b51b66d7b83a77e501930e735092a9967d5d18","modified":1715096705657},{"_id":"themes/stellar/scripts/tags/lib/video.js","hash":"9f580f1483e6c24eba6ff96aef8f52ee3bf85b71","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/blockquote.styl","hash":"f107e6f399382a6663722bc2e823986c257da9a3","modified":1715096705657},{"_id":"themes/stellar/scripts/tags/lib/poetry.js","hash":"c36321caeec845ed131bdd0922bff25eb59f086a","modified":1715096705656},{"_id":"themes/stellar/source/css/_common/cap.styl","hash":"c99286644d4a44dc76e1fe9a3af1815112f65acc","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/button.styl","hash":"9afb3e566294f95f404a608b666367081a691e6b","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/control.styl","hash":"75081ca9d522a76ec4acffb8111c918b2297650a","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/blur.styl","hash":"43441caaee7b7ab011a26016362b023263cd64a8","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/device.styl","hash":"fa135f5d93f8a333cc77f7dd4f6b8bf88e0f43bd","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/html.styl","hash":"e7f596ff7294517096f5cb27f5af53b1a797e047","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/image.styl","hash":"cca1103a9185202b13be49e16d77d259e9ffb482","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/highlight.styl","hash":"2e1191dbfa6e77a53ea9e95cecf66dc5b3d63b81","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/input.styl","hash":"953fc87072cd760d92dfef55310addbb17bb2b51","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/loading.styl","hash":"6962fd568ad9779146742b8b8928cec107972e8e","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/base.styl","hash":"2986c5771652c353a320f4404ceeb1c6b257a6ed","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/layout.styl","hash":"c7d0d3c70087e14bd1f6d8d50d56762d8c5ad44d","modified":1715096705657},{"_id":"themes/stellar/source/css/_common/media.styl","hash":"fa7dbcaa31089fe547acb01a767af97fb019bba6","modified":1715096705658},{"_id":"themes/stellar/source/css/_common/span.styl","hash":"86462ffaf1603b5d5ab6534c0f7fe0eb495aad2d","modified":1715096705658},{"_id":"themes/stellar/source/css/_common/svg.styl","hash":"aa2ae391db2ea028b9221740b24fca7f7e9ff16c","modified":1715096705658},{"_id":"themes/stellar/source/css/_common/pre.styl","hash":"be7ecc0a1cdd2e6f1594c4cc238734b2dc3a2c4e","modified":1715096705658},{"_id":"themes/stellar/source/css/_components/index.styl","hash":"7a7ab293e065116646102546c6bab01166836059","modified":1715096705658},{"_id":"themes/stellar/source/css/_components/layout.styl","hash":"b7eb188db92bb9a32ae180969838f6eda2ec9640","modified":1715096705658},{"_id":"themes/stellar/source/css/_common/toast.styl","hash":"f2930874174763da2338fa95087c345bf5c41800","modified":1715096705658},{"_id":"themes/stellar/source/css/_common/title.styl","hash":"c9009b6c52a1ea4dfb6c2f56b1c3fc6de8a2c63a","modified":1715096705658},{"_id":"themes/stellar/source/css/_components/list.styl","hash":"326015062dd68c7ee8272416cf4f7732d20482cb","modified":1715096705658},{"_id":"themes/stellar/source/css/_components/md.styl","hash":"55c6f6f73468229159d895de08282e0d75b167b1","modified":1715096705658},{"_id":"themes/stellar/source/css/_defines/func.styl","hash":"7ca5d5e0f358038497649ca58402d03ac6ddb13f","modified":1715096705662},{"_id":"themes/stellar/source/css/_defines/const.styl","hash":"c62a434f1eef895d343cb8255a19c6f1a6c73195","modified":1715096705662},{"_id":"themes/stellar/source/css/_defines/theme.styl","hash":"152ab1b4d66175977a057563a3f66bf0cbc4fbd4","modified":1715096705662},{"_id":"themes/stellar/source/css/_plugins/aplayer.styl","hash":"00b6e9209638eef9f70e75a24a5a90b05f7b5347","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/main.styl","hash":"41040b445d23ff4e56656ce3ca4e0fd7fd67d67b","modified":1715096705658},{"_id":"themes/stellar/source/css/_plugins/fancybox.styl","hash":"f4a709dcac4e21ca0fbeca552a8dde2ac2bf8d97","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/copycode.styl","hash":"a9f27136143eb779d1aeb903e863c94a98b82aac","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/index.styl","hash":"f96caf6f1d582973bc71199eee478cfc9fe88085","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/katex.styl","hash":"64a0208a475811c8a022536441188a161d9dd05d","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/mermaid.styl","hash":"b01f298bb006abfe00bf68566bcc53c3cad4a6e7","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/lazyload.styl","hash":"6cd216067594d07c097a66e2403df36a1abbe6d6","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/swiper.styl","hash":"46179e1e9ca273f4e095388d981acdc9fce5bdb8","modified":1715096705663},{"_id":"themes/stellar/source/js/search/algolia-search.js","hash":"2b4cc743d66fbdbe37f2311963d54d957637ca3e","modified":1715096705664},{"_id":"themes/stellar/source/css/_plugins/scrollreveal.styl","hash":"21b9125c1bae3e5348547e85500ceb992de21923","modified":1715096705663},{"_id":"themes/stellar/source/js/search/local-search.js","hash":"cf710d711fcbc21122cdc01edd43d9b4087f1b9d","modified":1715096705664},{"_id":"themes/stellar/source/css/_plugins/tianli_gpt.styl","hash":"6cc2d27b8ec0296de09ce38d15abdd966702b79a","modified":1715096705663},{"_id":"themes/stellar/source/js/plugins/copycode.js","hash":"af017eeaaf12e78b1700d78b199b4368d001a193","modified":1715096705664},{"_id":"themes/stellar/source/js/services/fcircle.js","hash":"add550bfb204a2057661d4d6630d78ebf485754d","modified":1715096705664},{"_id":"themes/stellar/source/js/services/friends.js","hash":"581a2baa085df422b752cbec098ca56aac691790","modified":1715096705664},{"_id":"themes/stellar/source/js/services/mdrender.js","hash":"947f476e6dd8ca6a75f87f6ac6f2fbb2b0861e82","modified":1715096705664},{"_id":"themes/stellar/source/js/services/ghinfo.js","hash":"94b86ce42dd765e9a4c1befa72ee9648d7ec6f88","modified":1715096705664},{"_id":"themes/stellar/source/js/services/memos.js","hash":"9d8e2976765ed15a739969752556b3ee28b1f283","modified":1715096705664},{"_id":"themes/stellar/source/js/services/sites.js","hash":"5626b70d13360933c581983dcda422e4fccdc810","modified":1715096705664},{"_id":"themes/stellar/source/js/services/siteinfo.js","hash":"74da788f29862604cd53f6b82b036ff56c715d21","modified":1715096705664},{"_id":"themes/stellar/source/js/services/timeline.js","hash":"41cde82427726c3366b64b1f54f1aed9bc20fcf1","modified":1715096705664},{"_id":"themes/stellar/source/js/services/weibo.js","hash":"437e631539f3a50cf8b46ff17008404609c1c481","modified":1715096705664},{"_id":"themes/stellar/layout/_partial/comments/artalk/layout.ejs","hash":"14b26d696ba6644ef9d5854e1b4a8fda028bddb9","modified":1715096705646},{"_id":"themes/stellar/layout/_partial/comments/artalk/script.ejs","hash":"82aae1b1a5a5db2113935742f3fae5fc7d6f0177","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/giscus/script.ejs","hash":"35cc20ffa353c49ed8cdc0c27c7aea20cfe52b90","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/giscus/layout.ejs","hash":"144e313ab45889c715ea1cfff3976b1f1322469e","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/beaudar/script.ejs","hash":"c2171249b79e549edbcdbbaf0d1f0c9deed2f033","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/beaudar/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/twikoo/layout.ejs","hash":"a3d429f4eafc582f739dd48865b39afd7c22ed56","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/twikoo/script.ejs","hash":"1b9d294c8be6d4ea58dfd5617f8561bad234e133","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/utterances/script.ejs","hash":"c64d639c7cea2ce37973c786910b7964e6b41e6c","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/utterances/layout.ejs","hash":"431848ce38c18589ddb54d5e705bd7792872c199","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/waline/layout.ejs","hash":"2abe764ffeab5603645b0e5148a17e9373de5eb4","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/comments/waline/script.ejs","hash":"d7d9a3959afff50e901532af211ec9805c84d67d","modified":1715096705647},{"_id":"themes/stellar/layout/_partial/main/article/read_next.ejs","hash":"30c9e20e6835fa92a528de61041742ff42cc2af0","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/article/related_posts.ejs","hash":"d771cdb24dd2a31cdadeed5c98c016675dc0c02a","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/article/article_footer.ejs","hash":"ea08a1daf4569f8a623ba0039d20bc150610c8c7","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/navbar/dateinfo.ejs","hash":"8bec18d89f073fe5a7c669910fd2a8efc1fdb5e5","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/navbar/ghinfo.ejs","hash":"f5177430efd994b7c2d9d3104a58b0f1f60f4a00","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/navbar/nav_tabs_wiki.ejs","hash":"bb8644df466868a879fc97bc364f1aba6b1137cf","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/main/navbar/article_banner.ejs","hash":"877fca38602c76cc9ced6f739e3929091f0d2f74","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/navbar/nav_tabs_blog.ejs","hash":"e66b369babf79bc84108bbc12d1ea7f7144cf33e","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/main/post_list/paginator.ejs","hash":"1a4b3bc64325ec7d5932ea78c36f2ec4978c09eb","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/main/post_list/post_card.ejs","hash":"dab8decf3ebf7a2d4d829a534af76e8500fbffbb","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/main/post_list/wiki_card.ejs","hash":"d2676c1817f09be21008fbf1c2a25e3c9dc1793f","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/widgets/components/link.ejs","hash":"eee3e54cca066643d973f7bc1e2af6230121e634","modified":1715096705650},{"_id":"themes/stellar/layout/_partial/main/post_list/topic_card.ejs","hash":"9f100016e7cfa07c8728f9c3cf9543ed3ed43cfe","modified":1715096705649},{"_id":"themes/stellar/layout/_partial/widgets/components/linklist.ejs","hash":"91f3a83ff54284200951637c0cfcd3e4e613942e","modified":1715096705650},{"_id":"themes/stellar/source/css/_components/pages/archives.styl","hash":"a99f09f4cc948588d071f8cd95362f2d70ec4c40","modified":1715096705658},{"_id":"themes/stellar/source/css/_components/sidebar/footer.styl","hash":"ac3423d488259ea467e95325e12f57476a9bdc9c","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/pages/error.styl","hash":"91f9df285a87bc7b7e9da19d547ea4b1dc392828","modified":1715096705658},{"_id":"themes/stellar/source/css/_components/sidebar/logo.styl","hash":"f81eb3d7a49c71f728d8bf42081bde30c6ff596e","modified":1715096705659},{"_id":"themes/stellar/layout/_partial/widgets/components/edit.ejs","hash":"9d976ca956c73128f72f39ca7641ceb5240b15a1","modified":1715096705650},{"_id":"themes/stellar/source/css/_components/sidebar/search.styl","hash":"ea880602a99ed8cb9b87f410e1f340b4d23d38e8","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/sidebar/nav-area.styl","hash":"5302a72d15f7c35b391da723e84592f1129fca57","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/sidebar/sidebar.styl","hash":"aaac0bc311badd146a11d3276ce89a4361c52ad4","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/sidebar/menu.styl","hash":"57f772066edaa2cbe560622de28035780ad9000b","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/article-banner.styl","hash":"1a1f86d224c27c7be3f771652ac776dcb63fe62f","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/article-footer.styl","hash":"762c38e63aebbd028b5aed264349fa1d2a14e8af","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/bread-nav.styl","hash":"daf58b32af0b5dfea6cbfa1c3cab695976e57164","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/cover.styl","hash":"ef44c47d0a70feb84d69cf8bb2bc6977f61b94f2","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/footer.styl","hash":"363fd4daf060fbf7de56fe5df787bc325565791b","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/paginator.styl","hash":"d5a64f3820ffc0913086c9fa35b26391eb023e61","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/partial/navbar.styl","hash":"282291ee0f876ea14cff671555ab9defe8fc2318","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/widgets/ghrepo.styl","hash":"73d5baa3dfcc9e73fc7470e1ebe244857ffd75c1","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/partial/related.styl","hash":"b413ab434cfb778384fbac64d43da41437435aa0","modified":1715096705659},{"_id":"themes/stellar/source/css/_components/widgets/ghuser.styl","hash":"16c62c701f9cf6a253c6390d43eaa01cfd7600b1","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/components.styl","hash":"34280561524a535342da3f246443b2a94fef074d","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/markdown.styl","hash":"f5a431cd88fca7f328634e13eff50a55b34b734b","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/related.styl","hash":"8464b5adb8ffcd086d0e748849d907871d149223","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/list.styl","hash":"176281f5ccc64f87da4bbd4e34316e32017bc3b4","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/tagcloud.styl","hash":"c452b18f1242c634c0e124a46414cbc7c65da494","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/widgets.styl","hash":"7d383e58d54bf40806027fa22ab0ba70b5ab4fde","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/toc.styl","hash":"f290d98a4d721b523b0c972b7de61a86b05b1086","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/widgets/timeline.styl","hash":"ab1901de4acfe89b642cd721d7d08b1b0009661b","modified":1715096705662},{"_id":"themes/stellar/source/css/_components/tag-plugins/about.styl","hash":"cdaf1ccd782db961cecda0802c94dabe27656731","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/banner.styl","hash":"f49a123a61cb02c65eebb79adefae9a6f8b8e2fc","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/button.styl","hash":"19469c881d8798916ea45ec11ecd5348146e7927","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/common.styl","hash":"a0a0e36d7672271147853bae34eb15b1ad2f0eef","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/emoji.styl","hash":"100d2e0c43496464dd97fa83fa3e603e68bf30e9","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/checkbox.styl","hash":"1cd33e27fd539ed2a6cb41d4fc59294f1dd315b4","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/folders.styl","hash":"2eae18b521a613a19dd6399dcb5504f843dcbb88","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/copy.styl","hash":"2e00b4923bf8a4cf1b742d19cf26165cc65fcffe","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/folding.styl","hash":"84eb11a5a5808f3a4bd0985d97a7b108a36fd044","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/gallery.styl","hash":"52be8d049ce7533084aa3a6f361b4f365086af02","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/frame.styl","hash":"f8621b5a155ea78c5828e7ccbd1dfe6a72c9733c","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/friends.styl","hash":"4d412ca8388ff65979b9a619a7ae2fe212a90bac","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/grid.styl","hash":"606311fa8326152f99fc721284a09e06490d0cca","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/hashtag.styl","hash":"0e2e74fcff5c30be9533e451a1c06ed1477dc9aa","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/image.styl","hash":"beb0eb953d11489d4eaf16282784625062c81d9f","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/inline-labels.styl","hash":"96aad4c7710ed7097842fab77473b66a298b6e3f","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/ghcard.styl","hash":"98a50d3fab79ce03dd7f161fe3442d803712c284","modified":1715096705660},{"_id":"themes/stellar/source/css/_components/tag-plugins/link.styl","hash":"b91bb69a2f84567f87c2665c3dbaeb8831487185","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/mark.styl","hash":"1227da0705c294abab7030439d1e505c6b304ccf","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/media.styl","hash":"99cdaf447f8066738023a07163711c544fbed25a","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/navbar.styl","hash":"c2c3da16355f2dfd316edd11d9f2f2c50bc5299c","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/okr.styl","hash":"0c2d281e90c8cb1a0de5ff516dca0e08ae7db141","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/icon.styl","hash":"ea5372d1042db221f6c3ce5a31e18153c5e00d39","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/override.styl","hash":"6a31ef8c4dc7caa655ed7d852100abb2711ab5ac","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/note.styl","hash":"5e59f5ab728c2ad5b5e4e06b0dd694407bb14096","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/poetry.styl","hash":"6d15463121a741b69249318cadabf4bd06b4b3c6","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/sites.styl","hash":"0b765b154695d544fa5dfab562e60a48c49f8547","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/quot.styl","hash":"06f7f98457e9c814621316f93b5f04686cdb6e2f","modified":1715096705661},{"_id":"themes/stellar/source/css/_plugins/comments/beaudar.styl","hash":"e9800f67a650f1c022aee494768e05da76e6a6b7","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/comments/artalk.styl","hash":"279d7185e0ea65a8f5e1f783eaa3f83bc7bf3555","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/comments/utterances.styl","hash":"be43f728d9515acaf050fbb3eed83cfefa2fe702","modified":1715096705663},{"_id":"themes/stellar/source/css/_plugins/comments/twikoo.styl","hash":"c30662f7635bbfd7b4ecde949fdec40aee4b6bce","modified":1715096705663},{"_id":"themes/stellar/source/css/_components/tag-plugins/toc.styl","hash":"18577b1c775f14da4b70cf3a8db56aa229f733c8","modified":1715096705662},{"_id":"themes/stellar/source/css/_plugins/comments/waline.styl","hash":"9efd82d46da9bb4adb09f7ad1eea31a599608163","modified":1715096705663},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/blog.ejs","hash":"0e3ff0a54e75acf562fd06d3d2c3ea03e0df7e81","modified":1715096705648},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/page.ejs","hash":"66fca0ad5ae3ceaa8fa1f698713c4882fc0341c3","modified":1715096705648},{"_id":"themes/stellar/source/css/_components/tag-plugins/timeline.styl","hash":"a5ef35db9c54905770c0ab68471ec054b0a83d9e","modified":1715096705661},{"_id":"themes/stellar/source/css/_components/tag-plugins/tabs.styl","hash":"b9bb4cf9442c0d4c09951c2fb886dbf8d0fe8de0","modified":1715096705661},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb/wiki.ejs","hash":"c878619b0e8835e9a53a3b460ab5c707e9a3fb61","modified":1715096705648}],"Category":[{"name":"cpp","_id":"clx8i4fa30004qt3a7g7rhcjh"},{"name":"Blog","_id":"clx8i4fa6000dqt3a3qwcafun"},{"name":"题解","parent":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa7000lqt3ae0p1gk20"},{"name":"QT","parent":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa9000xqt3a83xz2jov"},{"name":"debug","_id":"clx8i4fa9001aqt3ah3f8aoj8"},{"name":"动漫","_id":"clx8i4faa001eqt3a8fivefv6"},{"name":"cpp","parent":"clx8i4fa9001aqt3ah3f8aoj8","_id":"clx8i4faa001kqt3a99ixaugs"}],"Data":[{"_id":"widgets","data":{"ghrepo":{"layout":"ghrepo"},"related":{"layout":"related"},"ghissues":{"layout":"ghissues","title":null,"limit":3,"labels":null},"recent":{"layout":"recent","rss":null,"limit":10},"tree":{"layout":"tree"},"toc":{"layout":"toc","list_number":false,"min_depth":1,"max_depth":6,"collapse":false,"edit_this_page":{"_posts/":null,"wiki/stellar/":"https://github.com/xaoxuu/hexo-theme-stellar-docs/blob/main/"}},"ghuser":{"layout":"ghuser","username":null,"avatar":true},"author":{"layout":"author","avatar":true},"tagcloud":{"layout":"tagcloud","title":"标签云","min_font":12,"max_font":24,"amount":100,"orderby":"name","order":1,"color":false,"start_color":null,"end_color":null,"show_count":false},"timeline":{"layout":"timeline","title":"近期动态","api":null,"user":null,"type":null,"limit":null}}},{"_id":".DS_Store","data":"\u0000\u0000\u0000\u0001Bud1\u0000\u0000\u0010\u0000\u0000\u0000\b\u0000\u0000\u0000\u0010\u0000\u0000\u0000\u0002\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\b\u0000\u0000\u0000\b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0001\u0000\u0000\u0010\u0000\u0000sIlocblob\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0007\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000sIlocblob\u0000\u0000\u0000\u0010\u0000\u0000\u0000e\u0000\u0000\u0000�������\u0000\u0000\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000sbwspblob\u0000\u0000\u0000�bplist00�\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\u0007\b\u000b\b]ShowStatusBar[ShowToolbar[ShowTabView_\u0010\u0014ContainerShowSidebar\\WindowBounds[ShowSidebar\b\t\b\t_\u0010\u0018{{450, 329}, {920, 436}}\t\b\u0015#/;R_klmno�\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\r\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000�\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000slg1Scomp\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000smoDDblob\u0000\u0000\u0000\b�>A����A\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000smodDblob\u0000\u0000\u0000\b�>A����A\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000sph1Scomp\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0005\u0000l\u0000i\u0000n\u0000k\u0000svSrnlong\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\b\u000b\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000 \u0000\u0000\u0000\u0001\u0000\u0000\u0000@\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0000\u0000\u0000\u0001\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0010\u0000\u0000\u0000\u0000\u0001\u0000\u0000 \u0000\u0000\u0000\u0000\u0001\u0000\u0000@\u0000\u0000\u0000\u0000\u0001\u0000\u0000�\u0000\u0000\u0000\u0000\u0001\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0001\u0000\b\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0010\u0000\u0000\u0000\u0000\u0000\u0001\u0000 \u0000\u0000\u0000\u0000\u0000\u0001\u0000@\u0000\u0000\u0000\u0000\u0000\u0001\u0000�\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0001\b\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0010\u0000\u0000\u0000\u0000\u0000\u0000\u0001 \u0000\u0000\u0000\u0000\u0000\u0000\u0001@\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0003\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u000b\u0000\u0000\u0000E\u0000\u0000\u0002\t\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0004DSDB\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000\u0000\u0000 \u0000\u0000\u0000`\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000�\u0000\u0000\u0000\u0001\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0002\u0000\u0000\b\u0000\u0000\u0000\u0018\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000 \u0000\u0000\u0000\u0000\u0001\u0000\u0000@\u0000\u0000\u0000\u0000\u0001\u0000\u0000�\u0000\u0000\u0000\u0000\u0001\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0001\u0000\b\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0010\u0000\u0000\u0000\u0000\u0000\u0001\u0000 \u0000\u0000\u0000\u0000\u0000\u0001\u0000@\u0000\u0000\u0000\u0000\u0000\u0001\u0000�\u0000\u0000\u0000\u0000\u0000\u0001\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0001\b\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0010\u0000\u0000\u0000\u0000\u0000\u0000\u0001 \u0000\u0000\u0000\u0000\u0000\u0000\u0001@\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000"},{"_id":"wiki","data":["hexo-stellar","其它项目"]},{"_id":"links/ios_developer","data":[{"title":"CAYZLH","url":"https://www.cayzlh.com","cover":null,"icon":"https://www.cayzlh.com/avatar.svg","description":"CODE IS POETRY"},{"title":"1dd's blog","url":"https://rail1dd.top","cover":null,"icon":"https://pics-1318128484.cos.ap-nanjing.myqcloud.com/1dd_square.jpg","description":"ESFJ｜复古未来｜跨界融合｜自我探索"},{"title":"又见苍岚","url":"https://www.zywvvd.com","cover":null,"icon":"https://www.zywvvd.com/image/avatar.png","description":"蓝天依旧，明眸如初"}]},{"_id":"wiki/hexo-stellar","data":{"name":"Stellar","title":"Stellar - 每个人的独立博客","subtitle":"每个人的独立博客 | Designed by xaoxuu","tags":"博客主题","icon":"/assets/wiki/stellar/icon.svg","cover":"/assets/wiki/stellar/icon.svg","description":"Stellar 是一个内置文档系统的简约商务风 Hexo 主题，支持丰富的标签和动态数据组件。","repo":"xaoxuu/hexo-theme-stellar","search":{"filter":"/wiki/stellar/","placeholder":"在 Stellar 中搜索..."},"leftbar":["tree","timeline_stellar_releases","related"],"comment_title":"评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。","comments":{"service":"giscus","giscus":{"data-repo":"xaoxuu/hexo-theme-stellar","data-mapping":"number","data-term":226}},"base_dir":"/wiki/stellar/","tree":{"快速开始":["index","examples","releases"],"基本使用":["theme-settings","pages","sidebar","tag-plugins","tag-plugins/express","tag-plugins/data","tag-plugins/container","comments"],"文档系统":["wiki-settings"],"进阶玩法":["widgets","advanced-settings","notes","fcircle"],"技术支持":["articles","todo","contributors"]}}}],"Page":[{"menu_id":"links","title":"友链","date":"2024-05-09T05:41:40.246Z","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png","_content":"\n\n\n\n\n<br />\n\n# 网络的小伙伴\n\n\n<center>{% friends ios_developer %}</center>\n\n# 科协的老登们\n\n<br />\n\n# 本站信息\n{% poetry  author:  footer:你也会带我走吗？ %}\n名称：Monty Lee’s Blog \n**描述：温良慎独 ｜ 自由从容**\n网址：[https://montylee.cn/](https://montylee.cn/) \n图标：https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/monty_lee.png\n{% endpoetry %}\n\n\n\n","source":"friends/index.md","raw":"---\nmenu_id: links\ntitle: 友链\ndate: 2024/05/08/10/07\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png\n---\n\n\n\n\n\n<br />\n\n# 网络的小伙伴\n\n\n<center>{% friends ios_developer %}</center>\n\n# 科协的老登们\n\n<br />\n\n# 本站信息\n{% poetry  author:  footer:你也会带我走吗？ %}\n名称：Monty Lee’s Blog \n**描述：温良慎独 ｜ 自由从容**\n网址：[https://montylee.cn/](https://montylee.cn/) \n图标：https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/monty_lee.png\n{% endpoetry %}\n\n\n\n","updated":"2024-05-09T05:41:40.236Z","path":"friends/index.html","comments":1,"layout":"page","_id":"clx8i4f9y0000qt3af9h1cenj","content":"<br />\n\n<h1 id=\"网络的小伙伴\"><a href=\"#网络的小伙伴\" class=\"headerlink\" title=\"网络的小伙伴\"></a>网络的小伙伴</h1><center><div class=\"tag-plugin users-wrap\"><div class=\"grid-box\"><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://www.cayzlh.com\"><img src=\"https://www.cayzlh.com/avatar.svg\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"name\"><span>CAYZLH</span></div></a></div><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://rail1dd.top\"><img src=\"https://pics-1318128484.cos.ap-nanjing.myqcloud.com/1dd_square.jpg\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"name\"><span>1dd's blog</span></div></a></div><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://www.zywvvd.com\"><img src=\"https://www.zywvvd.com/image/avatar.png\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"name\"><span>又见苍岚</span></div></a></div></div></div></center>\n\n<h1 id=\"科协的老登们\"><a href=\"#科协的老登们\" class=\"headerlink\" title=\"科协的老登们\"></a>科协的老登们</h1><br />\n\n<h1 id=\"本站信息\"><a href=\"#本站信息\" class=\"headerlink\" title=\"本站信息\"></a>本站信息</h1><div class=\"tag-plugin poetry\"><div class=\"content\"><div class=\"body\"><p>名称：Monty Lee’s Blog<br><strong>描述：温良慎独 ｜ 自由从容</strong><br>网址：<a href=\"https://montylee.cn/\">https://montylee.cn/</a><br>图标：<a href=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/monty_lee.png\">https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/monty_lee.png</a></p></div><div class=\"footer\">你也会带我走吗？</div></div></div>\n\n\n\n","excerpt":"","more":"<br />\n\n<h1 id=\"网络的小伙伴\"><a href=\"#网络的小伙伴\" class=\"headerlink\" title=\"网络的小伙伴\"></a>网络的小伙伴</h1><center><div class=\"tag-plugin users-wrap\"><div class=\"grid-box\"><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://www.cayzlh.com\"><img src=\"https://www.cayzlh.com/avatar.svg\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"name\"><span>CAYZLH</span></div></a></div><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://rail1dd.top\"><img src=\"https://pics-1318128484.cos.ap-nanjing.myqcloud.com/1dd_square.jpg\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"name\"><span>1dd's blog</span></div></a></div><div class=\"grid-cell user-card\"><a class=\"card-link\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\" href=\"https://www.zywvvd.com\"><img src=\"https://www.zywvvd.com/image/avatar.png\" onerror=\"javascript:this.removeAttribute(&quot;data-src&quot;);this.src=&quot;https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg&quot;;\"/><div class=\"name\"><span>又见苍岚</span></div></a></div></div></div></center>\n\n<h1 id=\"科协的老登们\"><a href=\"#科协的老登们\" class=\"headerlink\" title=\"科协的老登们\"></a>科协的老登们</h1><br />\n\n<h1 id=\"本站信息\"><a href=\"#本站信息\" class=\"headerlink\" title=\"本站信息\"></a>本站信息</h1><div class=\"tag-plugin poetry\"><div class=\"content\"><div class=\"body\"><p>名称：Monty Lee’s Blog<br><strong>描述：温良慎独 ｜ 自由从容</strong><br>网址：<a href=\"https://montylee.cn/\">https://montylee.cn/</a><br>图标：<a href=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/monty_lee.png\">https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/monty_lee.png</a></p></div><div class=\"footer\">你也会带我走吗？</div></div></div>\n\n\n\n"},{"menu_id":"about","title":"关于","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png","_content":"\n# 自我介绍\n\n来自 NJUPT 网络工程专业的大学生，然而网络相关的知识几乎为 0……~~（神经网络算网络吗？？？）~~\n\n\n\n# 获奖经历\n\n| **竞赛名称**      | **所获奖项** | **获奖时间**    |\n| :-----------------:        |    :------------:   |          :-------: |\n| 美国大学生数学建模竞赛       | Honorable Mention       | 2023.05   |\n| 中国高校计算机大赛——网络技术挑战赛   | 华东赛区一等奖        | 2023.08      |\n| 全国大学生物联网设计竞赛（华为杯）   | 全国二等奖      | 2023.08      |\n| 大学生物联网技术与应用“三创”大赛    | 全国一等奖        | 2023.08      |\n| 全国大学生数学建模竞赛   | 江苏省二等奖        | 2023.09      |\n| 中国高校计算机大赛——人工智能创意赛   | 区域赛三等奖         | 2023.10      |\n| 全国大学生市场调查与分析大赛   | 全国三等奖        | 2024.04      |\n\n\n# 公开成果\n\n**Efficient Prompt Tuning for Vision and Language Models**\n~~The 30th International Conference on Neural Information Processing （CCFC）~~\n* In this paper, we propose a more efficient CLIP prompt tuning method, achieving better performance and faster convergence in downstream tasks using large-scale pre-trained visual language models. Experimental results on 11 datasets demonstrate the superiority of our approach.\n* 论文中提出了一种更高效的CLIP prompt tuning方法，利用大规模预训练的视觉语言模型在下游任务中取得了更好的性能和更快的收敛。在11个数据集上的实验证明了该方法的优越性。\n\n\n\n\n# 技术栈\n\n本科阶段，遵循个人兴趣主要学习了计算机视觉相关的内容，受就业形势所迫及实习岗位影响，开始入坑客户端和C++。\n\n* **计算机视觉**\n  * **Python** | **Diffusion Model** | **PyTorch** ｜……\n* **客户端开发**\n  * **C++** ｜**QT**……\n\n\n# 碎碎念\n\n\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 28 日 -->\n\n来了好几天了，基本上都是在干测试，不过也确实学到了不少东西。\n\n工程性的开发和学校里的小打小闹真的不一样啊。\n\n<!-- node 2024 年 5 月 13 日 -->\n\n面试通过，22号就要开始我的实习之旅了。\n\n* 主语言：C++\n* 岗位：软件开发，具体应该是SLAM点云数据相关\n\n<!-- node 2024 年 5 月 9 日 -->\n下午中海达面试，有点紧张……\n\n{% endtimeline %}","source":"about/index.md","raw":"---\nmenu_id: about\ntitle: 关于\nbanner : https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png\n---\n\n# 自我介绍\n\n来自 NJUPT 网络工程专业的大学生，然而网络相关的知识几乎为 0……~~（神经网络算网络吗？？？）~~\n\n\n\n# 获奖经历\n\n| **竞赛名称**      | **所获奖项** | **获奖时间**    |\n| :-----------------:        |    :------------:   |          :-------: |\n| 美国大学生数学建模竞赛       | Honorable Mention       | 2023.05   |\n| 中国高校计算机大赛——网络技术挑战赛   | 华东赛区一等奖        | 2023.08      |\n| 全国大学生物联网设计竞赛（华为杯）   | 全国二等奖      | 2023.08      |\n| 大学生物联网技术与应用“三创”大赛    | 全国一等奖        | 2023.08      |\n| 全国大学生数学建模竞赛   | 江苏省二等奖        | 2023.09      |\n| 中国高校计算机大赛——人工智能创意赛   | 区域赛三等奖         | 2023.10      |\n| 全国大学生市场调查与分析大赛   | 全国三等奖        | 2024.04      |\n\n\n# 公开成果\n\n**Efficient Prompt Tuning for Vision and Language Models**\n~~The 30th International Conference on Neural Information Processing （CCFC）~~\n* In this paper, we propose a more efficient CLIP prompt tuning method, achieving better performance and faster convergence in downstream tasks using large-scale pre-trained visual language models. Experimental results on 11 datasets demonstrate the superiority of our approach.\n* 论文中提出了一种更高效的CLIP prompt tuning方法，利用大规模预训练的视觉语言模型在下游任务中取得了更好的性能和更快的收敛。在11个数据集上的实验证明了该方法的优越性。\n\n\n\n\n# 技术栈\n\n本科阶段，遵循个人兴趣主要学习了计算机视觉相关的内容，受就业形势所迫及实习岗位影响，开始入坑客户端和C++。\n\n* **计算机视觉**\n  * **Python** | **Diffusion Model** | **PyTorch** ｜……\n* **客户端开发**\n  * **C++** ｜**QT**……\n\n\n# 碎碎念\n\n\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 28 日 -->\n\n来了好几天了，基本上都是在干测试，不过也确实学到了不少东西。\n\n工程性的开发和学校里的小打小闹真的不一样啊。\n\n<!-- node 2024 年 5 月 13 日 -->\n\n面试通过，22号就要开始我的实习之旅了。\n\n* 主语言：C++\n* 岗位：软件开发，具体应该是SLAM点云数据相关\n\n<!-- node 2024 年 5 月 9 日 -->\n下午中海达面试，有点紧张……\n\n{% endtimeline %}","date":"2024-05-28T14:01:16.195Z","updated":"2024-05-28T14:01:16.180Z","path":"about/index.html","comments":1,"layout":"page","_id":"clx8i4fa10002qt3agjam5sc8","content":"<h1 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h1><p>来自 NJUPT 网络工程专业的大学生，然而网络相关的知识几乎为 0……<del>（神经网络算网络吗？？？）</del></p>\n<h1 id=\"获奖经历\"><a href=\"#获奖经历\" class=\"headerlink\" title=\"获奖经历\"></a>获奖经历</h1><table>\n<thead>\n<tr>\n<th align=\"center\"><strong>竞赛名称</strong></th>\n<th align=\"center\"><strong>所获奖项</strong></th>\n<th align=\"center\"><strong>获奖时间</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">美国大学生数学建模竞赛</td>\n<td align=\"center\">Honorable Mention</td>\n<td align=\"center\">2023.05</td>\n</tr>\n<tr>\n<td align=\"center\">中国高校计算机大赛——网络技术挑战赛</td>\n<td align=\"center\">华东赛区一等奖</td>\n<td align=\"center\">2023.08</td>\n</tr>\n<tr>\n<td align=\"center\">全国大学生物联网设计竞赛（华为杯）</td>\n<td align=\"center\">全国二等奖</td>\n<td align=\"center\">2023.08</td>\n</tr>\n<tr>\n<td align=\"center\">大学生物联网技术与应用“三创”大赛</td>\n<td align=\"center\">全国一等奖</td>\n<td align=\"center\">2023.08</td>\n</tr>\n<tr>\n<td align=\"center\">全国大学生数学建模竞赛</td>\n<td align=\"center\">江苏省二等奖</td>\n<td align=\"center\">2023.09</td>\n</tr>\n<tr>\n<td align=\"center\">中国高校计算机大赛——人工智能创意赛</td>\n<td align=\"center\">区域赛三等奖</td>\n<td align=\"center\">2023.10</td>\n</tr>\n<tr>\n<td align=\"center\">全国大学生市场调查与分析大赛</td>\n<td align=\"center\">全国三等奖</td>\n<td align=\"center\">2024.04</td>\n</tr>\n</tbody></table>\n<h1 id=\"公开成果\"><a href=\"#公开成果\" class=\"headerlink\" title=\"公开成果\"></a>公开成果</h1><p><strong>Efficient Prompt Tuning for Vision and Language Models</strong><br><del>The 30th International Conference on Neural Information Processing （CCFC）</del></p>\n<ul>\n<li>In this paper, we propose a more efficient CLIP prompt tuning method, achieving better performance and faster convergence in downstream tasks using large-scale pre-trained visual language models. Experimental results on 11 datasets demonstrate the superiority of our approach.</li>\n<li>论文中提出了一种更高效的CLIP prompt tuning方法，利用大规模预训练的视觉语言模型在下游任务中取得了更好的性能和更快的收敛。在11个数据集上的实验证明了该方法的优越性。</li>\n</ul>\n<h1 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h1><p>本科阶段，遵循个人兴趣主要学习了计算机视觉相关的内容，受就业形势所迫及实习岗位影响，开始入坑客户端和C++。</p>\n<ul>\n<li><strong>计算机视觉</strong><ul>\n<li><strong>Python</strong> | <strong>Diffusion Model</strong> | <strong>PyTorch</strong> ｜……</li>\n</ul>\n</li>\n<li><strong>客户端开发</strong><ul>\n<li><strong>C++</strong> ｜<strong>QT</strong>……</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 28 日</div><div class=\"body fs14\"><p>来了好几天了，基本上都是在干测试，不过也确实学到了不少东西。</p><p>工程性的开发和学校里的小打小闹真的不一样啊。</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 13 日</div><div class=\"body fs14\"><p>面试通过，22号就要开始我的实习之旅了。</p><ul><li>主语言：C++</li><li>岗位：软件开发，具体应该是SLAM点云数据相关</li></ul></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 9 日</div><div class=\"body fs14\"><p>下午中海达面试，有点紧张……</p></div></div></div>","excerpt":"","more":"<h1 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h1><p>来自 NJUPT 网络工程专业的大学生，然而网络相关的知识几乎为 0……<del>（神经网络算网络吗？？？）</del></p>\n<h1 id=\"获奖经历\"><a href=\"#获奖经历\" class=\"headerlink\" title=\"获奖经历\"></a>获奖经历</h1><table>\n<thead>\n<tr>\n<th align=\"center\"><strong>竞赛名称</strong></th>\n<th align=\"center\"><strong>所获奖项</strong></th>\n<th align=\"center\"><strong>获奖时间</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">美国大学生数学建模竞赛</td>\n<td align=\"center\">Honorable Mention</td>\n<td align=\"center\">2023.05</td>\n</tr>\n<tr>\n<td align=\"center\">中国高校计算机大赛——网络技术挑战赛</td>\n<td align=\"center\">华东赛区一等奖</td>\n<td align=\"center\">2023.08</td>\n</tr>\n<tr>\n<td align=\"center\">全国大学生物联网设计竞赛（华为杯）</td>\n<td align=\"center\">全国二等奖</td>\n<td align=\"center\">2023.08</td>\n</tr>\n<tr>\n<td align=\"center\">大学生物联网技术与应用“三创”大赛</td>\n<td align=\"center\">全国一等奖</td>\n<td align=\"center\">2023.08</td>\n</tr>\n<tr>\n<td align=\"center\">全国大学生数学建模竞赛</td>\n<td align=\"center\">江苏省二等奖</td>\n<td align=\"center\">2023.09</td>\n</tr>\n<tr>\n<td align=\"center\">中国高校计算机大赛——人工智能创意赛</td>\n<td align=\"center\">区域赛三等奖</td>\n<td align=\"center\">2023.10</td>\n</tr>\n<tr>\n<td align=\"center\">全国大学生市场调查与分析大赛</td>\n<td align=\"center\">全国三等奖</td>\n<td align=\"center\">2024.04</td>\n</tr>\n</tbody></table>\n<h1 id=\"公开成果\"><a href=\"#公开成果\" class=\"headerlink\" title=\"公开成果\"></a>公开成果</h1><p><strong>Efficient Prompt Tuning for Vision and Language Models</strong><br><del>The 30th International Conference on Neural Information Processing （CCFC）</del></p>\n<ul>\n<li>In this paper, we propose a more efficient CLIP prompt tuning method, achieving better performance and faster convergence in downstream tasks using large-scale pre-trained visual language models. Experimental results on 11 datasets demonstrate the superiority of our approach.</li>\n<li>论文中提出了一种更高效的CLIP prompt tuning方法，利用大规模预训练的视觉语言模型在下游任务中取得了更好的性能和更快的收敛。在11个数据集上的实验证明了该方法的优越性。</li>\n</ul>\n<h1 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h1><p>本科阶段，遵循个人兴趣主要学习了计算机视觉相关的内容，受就业形势所迫及实习岗位影响，开始入坑客户端和C++。</p>\n<ul>\n<li><strong>计算机视觉</strong><ul>\n<li><strong>Python</strong> | <strong>Diffusion Model</strong> | <strong>PyTorch</strong> ｜……</li>\n</ul>\n</li>\n<li><strong>客户端开发</strong><ul>\n<li><strong>C++</strong> ｜<strong>QT</strong>……</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 28 日</div><div class=\"body fs14\"><p>来了好几天了，基本上都是在干测试，不过也确实学到了不少东西。</p><p>工程性的开发和学校里的小打小闹真的不一样啊。</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 13 日</div><div class=\"body fs14\"><p>面试通过，22号就要开始我的实习之旅了。</p><ul><li>主语言：C++</li><li>岗位：软件开发，具体应该是SLAM点云数据相关</li></ul></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 9 日</div><div class=\"body fs14\"><p>下午中海达面试，有点紧张……</p></div></div></div>"}],"Post":[{"title":"C++ 基础","date":"2024-05-12T16:00:00.000Z","description":"C++ 学习记录，基础语法学习，较为详细介绍指针和结构体的基础语法。","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211943_Ts5Y5.gif","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211943_Ts5Y5.gif","poster":{"topic":null,"headline":"C++ 基础","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n# C++ 基础入门\n~~注：本文章仅供个人学习使用，如需系统学习，请阅读[C++基础入门](https://github.com/Blitzer207/C-Resource/blob/master/第1阶段C%2B%2B%20匠心之作%20从0到1入门/C%2B%2B基础入门讲义/C%2B%2B基础入门.md)~~\n# 零散知识\n1. 科学计数法： \n    ```C++\n       float f1 = 3e2; // 3 * 10 ^ 2\n       float f2 = 3e-2; // 3 * 0.1 ^ 2\n    ```\n\n\n2. 使用 ASCII 码给字符型变量赋值\n\n    ```C++\n        char ch = 'a';\n        cout << ch << endl;\n        cout << sizeof (ch) << endl;\n    \n        ch = 98; // 使用 ASCII 码给字符型变量赋值\n        cout << ch << endl;\n    ```\n    输出：![img.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img.png)\n\n\n3. 输入 bool 型变量\n    ```C++\n       bool flag = true;\n       cout << \"输入布尔型变量：\" << endl;\n       cin >> flag;\n       cout << !flag << endl;\n    ```\n   输出：![img_1.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_1.png)\n\n\n4. 前++和后++\n   \n    前置递增：先让变量+1，然后进行表达式运算赋值\n    后置递增：先进行表达式计算赋值，再让变量+1\n   ![img_2.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_2.png)\n\n\n5. ![img_3.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_3.png)\n\n\n6. 三目运算符\n   * 语法：表达式1 ? 表达式2 : 表达式3\n   * 解释：\n     * 如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n     * 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。\n\n# 指针\n~~相关内容源自黑马课程~~\n作用：可以通过指针间接访问内存\n![img_4.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_4.png)\n\n指针变量可以通过\" * \"操作符，操作指针变量指向的内存空间，这个过程称为解引用\n具体定义如下：\n```C++\nint a = 10;\nint *p;\n// &a = p;\n// *p = a;\n```\n\n* 所有指针类型在32位操作系统下是4个字节 \n## 空指针\n* 指针变量指向内存中编号为0的空间\n* 用途：初始化指针\n* 注意：空指针指向的内存是不可以访问的\n* 0-255之间的内存编号是系统占用的，不可以访问 \n## 野指针\n* 类比开房，并不是走到哪个门口想进就能进的，\n必须实现开好房间（申请好内存）\n## const 修饰指针 \n* const 修饰指针 --- 常量指针 \n  * 特点：指针的指向可以修改，但是指向的指不能修改\n* const 修饰常量 --- 指针常量 \n  * 特点：常量指针相反\n* const 即修饰指针，又修饰常量\n      \n```C++\n  int main() {\n    \n      int a = 10;\n      int b = 10;\n    \n      //const 修饰的是指针，指针指向可以改，指针指向的值不可以更改\n      const int * p1 = &a; \n      p1 = &b; //正确\n      //*p1 = 100;  报错\n        \n    \n      //const 修饰的是常量，指针指向不可以改，指针指向的值可以更改\n      int * const p2 = &a;\n      //p2 = &b; //错误\n      *p2 = 100; //正确\n    \n      //const 既修饰指针又修饰常量\n      const int * const p3 = &a;\n      //p3 = &b; //错误\n      //*p3 = 100; //错误\n    \n      return 0;\n  }\n```\n\n## 指针和数组\n作用：利用指针访问数组中的元素\n\n## 指针和函数\n利用指针作函数参数，可以修改实参的值\n\n# 结构体\n结构体是属于用户自定义的数据类型，允许用户存储不同的数据类型。\n\n\n```C++\n//结构体定义\nstruct student\n{\n//成员列表\nstring name;  //姓名\nint age;      //年龄\nint score;    //分数\n}stu3; //结构体变量创建方式3\n\n\nint main() {\n\n    //结构体变量创建方式1\n    struct student stu1; //struct 关键字可以省略\n\n    stu1.name = \"张三\";\n    stu1.age = 18;\n    stu1.score = 100;\n    \n    cout << \"姓名：\" << stu1.name << \" 年龄：\" << stu1.age  << \" 分数：\" << stu1.score << endl;\n\n    //结构体变量创建方式2\n    struct student stu2 = { \"李四\",19,60 };\n\n    cout << \"姓名：\" << stu2.name << \" 年龄：\" << stu2.age  << \" 分数：\" << stu2.score << endl;\n\n\n    stu3.name = \"王五\";\n    stu3.age = 18;\n    stu3.score = 80;\n    \n\n    cout << \"姓名：\" << stu3.name << \" 年龄：\" << stu3.age  << \" 分数：\" << stu3.score << endl;\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n* 总结1：定义结构体时的关键字是struct，不可省略\n* 总结2：创建结构体变量时，关键字struct可以省略\n* 总结3：结构体变量利用操作符 ''.'' 访问成员\n\n## 结构体数组\n```C++\nstruct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }\n```\n\n## 结构体指针\n通过指针访问结构体中的成员\n\n```C++\n//结构体定义\nstruct student\n{\n//成员列表\nstring name;  //姓名\nint age;      //年龄\nint score;    //分数\n};\n\n\nint main() {\n\n    struct student stu = { \"张三\",18,100, };\n    \n    struct student * p = &stu;\n    \n    p->score = 80; //指针通过 -> 操作符可以访问成员\n\n    cout << \"姓名：\" << p->name << \" 年龄：\" << p->age << \" 分数：\" << p->score << endl;\n    \n    system(\"pause\");\n\n    return 0;\n}\n```\n\n## 结构体嵌套结构体\n\n## 结构体做函数参数\n将结构体作为参数向函数中传递\n\n## 结构体中 const 使用场景\n\n","source":"_posts/CPP基础.md","raw":"---\n# 基本信息\ntitle: C++ 基础\ndate: 2024/05/13\ntags: [cpp, 计算机]\ncategories: [cpp]\ndescription: C++ 学习记录，基础语法学习，较为详细介绍指针和结构体的基础语法。\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211943_Ts5Y5.gif\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211943_Ts5Y5.gif\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  C++ 基础 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n# C++ 基础入门\n~~注：本文章仅供个人学习使用，如需系统学习，请阅读[C++基础入门](https://github.com/Blitzer207/C-Resource/blob/master/第1阶段C%2B%2B%20匠心之作%20从0到1入门/C%2B%2B基础入门讲义/C%2B%2B基础入门.md)~~\n# 零散知识\n1. 科学计数法： \n    ```C++\n       float f1 = 3e2; // 3 * 10 ^ 2\n       float f2 = 3e-2; // 3 * 0.1 ^ 2\n    ```\n\n\n2. 使用 ASCII 码给字符型变量赋值\n\n    ```C++\n        char ch = 'a';\n        cout << ch << endl;\n        cout << sizeof (ch) << endl;\n    \n        ch = 98; // 使用 ASCII 码给字符型变量赋值\n        cout << ch << endl;\n    ```\n    输出：![img.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img.png)\n\n\n3. 输入 bool 型变量\n    ```C++\n       bool flag = true;\n       cout << \"输入布尔型变量：\" << endl;\n       cin >> flag;\n       cout << !flag << endl;\n    ```\n   输出：![img_1.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_1.png)\n\n\n4. 前++和后++\n   \n    前置递增：先让变量+1，然后进行表达式运算赋值\n    后置递增：先进行表达式计算赋值，再让变量+1\n   ![img_2.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_2.png)\n\n\n5. ![img_3.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_3.png)\n\n\n6. 三目运算符\n   * 语法：表达式1 ? 表达式2 : 表达式3\n   * 解释：\n     * 如果表达式1的值为真，执行表达式2，并返回表达式2的结果；\n     * 如果表达式1的值为假，执行表达式3，并返回表达式3的结果。\n\n# 指针\n~~相关内容源自黑马课程~~\n作用：可以通过指针间接访问内存\n![img_4.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_4.png)\n\n指针变量可以通过\" * \"操作符，操作指针变量指向的内存空间，这个过程称为解引用\n具体定义如下：\n```C++\nint a = 10;\nint *p;\n// &a = p;\n// *p = a;\n```\n\n* 所有指针类型在32位操作系统下是4个字节 \n## 空指针\n* 指针变量指向内存中编号为0的空间\n* 用途：初始化指针\n* 注意：空指针指向的内存是不可以访问的\n* 0-255之间的内存编号是系统占用的，不可以访问 \n## 野指针\n* 类比开房，并不是走到哪个门口想进就能进的，\n必须实现开好房间（申请好内存）\n## const 修饰指针 \n* const 修饰指针 --- 常量指针 \n  * 特点：指针的指向可以修改，但是指向的指不能修改\n* const 修饰常量 --- 指针常量 \n  * 特点：常量指针相反\n* const 即修饰指针，又修饰常量\n      \n```C++\n  int main() {\n    \n      int a = 10;\n      int b = 10;\n    \n      //const 修饰的是指针，指针指向可以改，指针指向的值不可以更改\n      const int * p1 = &a; \n      p1 = &b; //正确\n      //*p1 = 100;  报错\n        \n    \n      //const 修饰的是常量，指针指向不可以改，指针指向的值可以更改\n      int * const p2 = &a;\n      //p2 = &b; //错误\n      *p2 = 100; //正确\n    \n      //const 既修饰指针又修饰常量\n      const int * const p3 = &a;\n      //p3 = &b; //错误\n      //*p3 = 100; //错误\n    \n      return 0;\n  }\n```\n\n## 指针和数组\n作用：利用指针访问数组中的元素\n\n## 指针和函数\n利用指针作函数参数，可以修改实参的值\n\n# 结构体\n结构体是属于用户自定义的数据类型，允许用户存储不同的数据类型。\n\n\n```C++\n//结构体定义\nstruct student\n{\n//成员列表\nstring name;  //姓名\nint age;      //年龄\nint score;    //分数\n}stu3; //结构体变量创建方式3\n\n\nint main() {\n\n    //结构体变量创建方式1\n    struct student stu1; //struct 关键字可以省略\n\n    stu1.name = \"张三\";\n    stu1.age = 18;\n    stu1.score = 100;\n    \n    cout << \"姓名：\" << stu1.name << \" 年龄：\" << stu1.age  << \" 分数：\" << stu1.score << endl;\n\n    //结构体变量创建方式2\n    struct student stu2 = { \"李四\",19,60 };\n\n    cout << \"姓名：\" << stu2.name << \" 年龄：\" << stu2.age  << \" 分数：\" << stu2.score << endl;\n\n\n    stu3.name = \"王五\";\n    stu3.age = 18;\n    stu3.score = 80;\n    \n\n    cout << \"姓名：\" << stu3.name << \" 年龄：\" << stu3.age  << \" 分数：\" << stu3.score << endl;\n\n    system(\"pause\");\n\n    return 0;\n}\n```\n\n* 总结1：定义结构体时的关键字是struct，不可省略\n* 总结2：创建结构体变量时，关键字struct可以省略\n* 总结3：结构体变量利用操作符 ''.'' 访问成员\n\n## 结构体数组\n```C++\nstruct  结构体名 数组名[元素个数] = {  {} , {} , ... {} }\n```\n\n## 结构体指针\n通过指针访问结构体中的成员\n\n```C++\n//结构体定义\nstruct student\n{\n//成员列表\nstring name;  //姓名\nint age;      //年龄\nint score;    //分数\n};\n\n\nint main() {\n\n    struct student stu = { \"张三\",18,100, };\n    \n    struct student * p = &stu;\n    \n    p->score = 80; //指针通过 -> 操作符可以访问成员\n\n    cout << \"姓名：\" << p->name << \" 年龄：\" << p->age << \" 分数：\" << p->score << endl;\n    \n    system(\"pause\");\n\n    return 0;\n}\n```\n\n## 结构体嵌套结构体\n\n## 结构体做函数参数\n将结构体作为参数向函数中传递\n\n## 结构体中 const 使用场景\n\n","slug":"CPP基础","published":1,"updated":"2024-06-07T03:05:00.484Z","layout":"post","photos":[],"_id":"clx8i4fa00001qt3ad635cvq4","content":"<h1 id=\"C-基础入门\"><a href=\"#C-基础入门\" class=\"headerlink\" title=\"C++ 基础入门\"></a>C++ 基础入门</h1><p><del>注：本文章仅供个人学习使用，如需系统学习，请阅读<a href=\"https://github.com/Blitzer207/C-Resource/blob/master/%E7%AC%AC1%E9%98%B6%E6%AE%B5C%2B%2B%20%E5%8C%A0%E5%BF%83%E4%B9%8B%E4%BD%9C%20%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E8%AE%B2%E4%B9%89/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md\">C++基础入门</a></del></p>\n<h1 id=\"零散知识\"><a href=\"#零散知识\" class=\"headerlink\" title=\"零散知识\"></a>零散知识</h1><ol>\n<li><p>科学计数法： </p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> f1 = <span class=\"number\">3e2</span>; <span class=\"comment\">// 3 * 10 ^ 2</span></span><br><span class=\"line\"><span class=\"type\">float</span> f2 = <span class=\"number\">3e-2</span>; <span class=\"comment\">// 3 * 0.1 ^ 2</span></span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>使用 ASCII 码给字符型变量赋值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> ch = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">sizeof</span> (ch) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">ch = <span class=\"number\">98</span>; <span class=\"comment\">// 使用 ASCII 码给字符型变量赋值</span></span><br><span class=\"line\">cout &lt;&lt; ch &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p> 输出：<img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img.png\" alt=\"img.png\"></p>\n</li>\n<li><p>输入 bool 型变量</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">cin &gt;&gt; flag;</span><br><span class=\"line\">cout &lt;&lt; !flag &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>输出：<img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_1.png\" alt=\"img_1.png\"></p>\n</li>\n<li><p>前++和后++</p>\n<p> 前置递增：先让变量+1，然后进行表达式运算赋值<br> 后置递增：先进行表达式计算赋值，再让变量+1<br><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_2.png\" alt=\"img_2.png\"></p>\n</li>\n<li><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_3.png\" alt=\"img_3.png\"></p>\n</li>\n<li><p>三目运算符</p>\n<ul>\n<li>语法：表达式1 ? 表达式2 : 表达式3</li>\n<li>解释：<ul>\n<li>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</li>\n<li>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p><del>相关内容源自黑马课程</del><br>作用：可以通过指针间接访问内存<br><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_4.png\" alt=\"img_4.png\"></p>\n<p>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<br>具体定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p;</span><br><span class=\"line\"><span class=\"comment\">// &amp;a = p;</span></span><br><span class=\"line\"><span class=\"comment\">// *p = a;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有指针类型在32位操作系统下是4个字节</li>\n</ul>\n<h2 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h2><ul>\n<li>指针变量指向内存中编号为0的空间</li>\n<li>用途：初始化指针</li>\n<li>注意：空指针指向的内存是不可以访问的</li>\n<li>0-255之间的内存编号是系统占用的，不可以访问</li>\n</ul>\n<h2 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h2><ul>\n<li>类比开房，并不是走到哪个门口想进就能进的，<br>必须实现开好房间（申请好内存）</li>\n</ul>\n<h2 id=\"const-修饰指针\"><a href=\"#const-修饰指针\" class=\"headerlink\" title=\"const 修饰指针\"></a>const 修饰指针</h2><ul>\n<li>const 修饰指针 — 常量指针 <ul>\n<li>特点：指针的指向可以修改，但是指向的指不能修改</li>\n</ul>\n</li>\n<li>const 修饰常量 — 指针常量 <ul>\n<li>特点：常量指针相反</li>\n</ul>\n</li>\n<li>const 即修饰指针，又修饰常量</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//const 修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> * p1 = &amp;a; </span><br><span class=\"line\">    p1 = &amp;b; <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"comment\">//*p1 = 100;  报错</span></span><br><span class=\"line\">      </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//const 修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class=\"line\">    <span class=\"type\">int</span> * <span class=\"type\">const</span> p2 = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">//p2 = &amp;b; //错误</span></span><br><span class=\"line\">    *p2 = <span class=\"number\">100</span>; <span class=\"comment\">//正确</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//const 既修饰指针又修饰常量</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> * <span class=\"type\">const</span> p3 = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">//p3 = &amp;b; //错误</span></span><br><span class=\"line\">    <span class=\"comment\">//*p3 = 100; //错误</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h2><p>作用：利用指针访问数组中的元素</p>\n<h2 id=\"指针和函数\"><a href=\"#指针和函数\" class=\"headerlink\" title=\"指针和函数\"></a>指针和函数</h2><p>利用指针作函数参数，可以修改实参的值</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><p>结构体是属于用户自定义的数据类型，允许用户存储不同的数据类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">//成员列表</span></span><br><span class=\"line\">string name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\"><span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\"><span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;stu3; <span class=\"comment\">//结构体变量创建方式3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//结构体变量创建方式1</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu1; <span class=\"comment\">//struct 关键字可以省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    stu1.name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">    stu1.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    stu1.score = <span class=\"number\">100</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//结构体变量创建方式2</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu2 = &#123; <span class=\"string\">&quot;李四&quot;</span>,<span class=\"number\">19</span>,<span class=\"number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    stu3.name = <span class=\"string\">&quot;王五&quot;</span>;</span><br><span class=\"line\">    stu3.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    stu3.score = <span class=\"number\">80</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>总结1：定义结构体时的关键字是struct，不可省略</li>\n<li>总结2：创建结构体变量时，关键字struct可以省略</li>\n<li>总结3：结构体变量利用操作符 ‘’.’’ 访问成员</li>\n</ul>\n<h2 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span>  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构体指针\"><a href=\"#结构体指针\" class=\"headerlink\" title=\"结构体指针\"></a>结构体指针</h2><p>通过指针访问结构体中的成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">//成员列表</span></span><br><span class=\"line\">string name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\"><span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\"><span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu = &#123; <span class=\"string\">&quot;张三&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">100</span>, &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> * p = &amp;stu;</span><br><span class=\"line\">    </span><br><span class=\"line\">    p-&gt;score = <span class=\"number\">80</span>; <span class=\"comment\">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构体嵌套结构体\"><a href=\"#结构体嵌套结构体\" class=\"headerlink\" title=\"结构体嵌套结构体\"></a>结构体嵌套结构体</h2><h2 id=\"结构体做函数参数\"><a href=\"#结构体做函数参数\" class=\"headerlink\" title=\"结构体做函数参数\"></a>结构体做函数参数</h2><p>将结构体作为参数向函数中传递</p>\n<h2 id=\"结构体中-const-使用场景\"><a href=\"#结构体中-const-使用场景\" class=\"headerlink\" title=\"结构体中 const 使用场景\"></a>结构体中 const 使用场景</h2>","excerpt":"","more":"<h1 id=\"C-基础入门\"><a href=\"#C-基础入门\" class=\"headerlink\" title=\"C++ 基础入门\"></a>C++ 基础入门</h1><p><del>注：本文章仅供个人学习使用，如需系统学习，请阅读<a href=\"https://github.com/Blitzer207/C-Resource/blob/master/%E7%AC%AC1%E9%98%B6%E6%AE%B5C%2B%2B%20%E5%8C%A0%E5%BF%83%E4%B9%8B%E4%BD%9C%20%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E8%AE%B2%E4%B9%89/C%2B%2B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md\">C++基础入门</a></del></p>\n<h1 id=\"零散知识\"><a href=\"#零散知识\" class=\"headerlink\" title=\"零散知识\"></a>零散知识</h1><ol>\n<li><p>科学计数法： </p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">float</span> f1 = <span class=\"number\">3e2</span>; <span class=\"comment\">// 3 * 10 ^ 2</span></span><br><span class=\"line\"><span class=\"type\">float</span> f2 = <span class=\"number\">3e-2</span>; <span class=\"comment\">// 3 * 0.1 ^ 2</span></span><br></pre></td></tr></table></figure>\n\n</li>\n<li><p>使用 ASCII 码给字符型变量赋值</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> ch = <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">sizeof</span> (ch) &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">ch = <span class=\"number\">98</span>; <span class=\"comment\">// 使用 ASCII 码给字符型变量赋值</span></span><br><span class=\"line\">cout &lt;&lt; ch &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p> 输出：<img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img.png\" alt=\"img.png\"></p>\n</li>\n<li><p>输入 bool 型变量</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">&quot;输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">cin &gt;&gt; flag;</span><br><span class=\"line\">cout &lt;&lt; !flag &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n<p>输出：<img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_1.png\" alt=\"img_1.png\"></p>\n</li>\n<li><p>前++和后++</p>\n<p> 前置递增：先让变量+1，然后进行表达式运算赋值<br> 后置递增：先进行表达式计算赋值，再让变量+1<br><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_2.png\" alt=\"img_2.png\"></p>\n</li>\n<li><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_3.png\" alt=\"img_3.png\"></p>\n</li>\n<li><p>三目运算符</p>\n<ul>\n<li>语法：表达式1 ? 表达式2 : 表达式3</li>\n<li>解释：<ul>\n<li>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</li>\n<li>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><p><del>相关内容源自黑马课程</del><br>作用：可以通过指针间接访问内存<br><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/img_4.png\" alt=\"img_4.png\"></p>\n<p>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<br>具体定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *p;</span><br><span class=\"line\"><span class=\"comment\">// &amp;a = p;</span></span><br><span class=\"line\"><span class=\"comment\">// *p = a;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>所有指针类型在32位操作系统下是4个字节</li>\n</ul>\n<h2 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h2><ul>\n<li>指针变量指向内存中编号为0的空间</li>\n<li>用途：初始化指针</li>\n<li>注意：空指针指向的内存是不可以访问的</li>\n<li>0-255之间的内存编号是系统占用的，不可以访问</li>\n</ul>\n<h2 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h2><ul>\n<li>类比开房，并不是走到哪个门口想进就能进的，<br>必须实现开好房间（申请好内存）</li>\n</ul>\n<h2 id=\"const-修饰指针\"><a href=\"#const-修饰指针\" class=\"headerlink\" title=\"const 修饰指针\"></a>const 修饰指针</h2><ul>\n<li>const 修饰指针 — 常量指针 <ul>\n<li>特点：指针的指向可以修改，但是指向的指不能修改</li>\n</ul>\n</li>\n<li>const 修饰常量 — 指针常量 <ul>\n<li>特点：常量指针相反</li>\n</ul>\n</li>\n<li>const 即修饰指针，又修饰常量</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//const 修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> * p1 = &amp;a; </span><br><span class=\"line\">    p1 = &amp;b; <span class=\"comment\">//正确</span></span><br><span class=\"line\">    <span class=\"comment\">//*p1 = 100;  报错</span></span><br><span class=\"line\">      </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//const 修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class=\"line\">    <span class=\"type\">int</span> * <span class=\"type\">const</span> p2 = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">//p2 = &amp;b; //错误</span></span><br><span class=\"line\">    *p2 = <span class=\"number\">100</span>; <span class=\"comment\">//正确</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//const 既修饰指针又修饰常量</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> * <span class=\"type\">const</span> p3 = &amp;a;</span><br><span class=\"line\">    <span class=\"comment\">//p3 = &amp;b; //错误</span></span><br><span class=\"line\">    <span class=\"comment\">//*p3 = 100; //错误</span></span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h2><p>作用：利用指针访问数组中的元素</p>\n<h2 id=\"指针和函数\"><a href=\"#指针和函数\" class=\"headerlink\" title=\"指针和函数\"></a>指针和函数</h2><p>利用指针作函数参数，可以修改实参的值</p>\n<h1 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h1><p>结构体是属于用户自定义的数据类型，允许用户存储不同的数据类型。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">//成员列表</span></span><br><span class=\"line\">string name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\"><span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\"><span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;stu3; <span class=\"comment\">//结构体变量创建方式3</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//结构体变量创建方式1</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu1; <span class=\"comment\">//struct 关键字可以省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">    stu1.name = <span class=\"string\">&quot;张三&quot;</span>;</span><br><span class=\"line\">    stu1.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    stu1.score = <span class=\"number\">100</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//结构体变量创建方式2</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu2 = &#123; <span class=\"string\">&quot;李四&quot;</span>,<span class=\"number\">19</span>,<span class=\"number\">60</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    stu3.name = <span class=\"string\">&quot;王五&quot;</span>;</span><br><span class=\"line\">    stu3.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    stu3.score = <span class=\"number\">80</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>总结1：定义结构体时的关键字是struct，不可省略</li>\n<li>总结2：创建结构体变量时，关键字struct可以省略</li>\n<li>总结3：结构体变量利用操作符 ‘’.’’ 访问成员</li>\n</ul>\n<h2 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span>  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构体指针\"><a href=\"#结构体指针\" class=\"headerlink\" title=\"结构体指针\"></a>结构体指针</h2><p>通过指针访问结构体中的成员</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//结构体定义</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">student</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">//成员列表</span></span><br><span class=\"line\">string name;  <span class=\"comment\">//姓名</span></span><br><span class=\"line\"><span class=\"type\">int</span> age;      <span class=\"comment\">//年龄</span></span><br><span class=\"line\"><span class=\"type\">int</span> score;    <span class=\"comment\">//分数</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> stu = &#123; <span class=\"string\">&quot;张三&quot;</span>,<span class=\"number\">18</span>,<span class=\"number\">100</span>, &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">student</span> * p = &amp;stu;</span><br><span class=\"line\">    </span><br><span class=\"line\">    p-&gt;score = <span class=\"number\">80</span>; <span class=\"comment\">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class=\"string\">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class=\"string\">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">system</span>(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结构体嵌套结构体\"><a href=\"#结构体嵌套结构体\" class=\"headerlink\" title=\"结构体嵌套结构体\"></a>结构体嵌套结构体</h2><h2 id=\"结构体做函数参数\"><a href=\"#结构体做函数参数\" class=\"headerlink\" title=\"结构体做函数参数\"></a>结构体做函数参数</h2><p>将结构体作为参数向函数中传递</p>\n<h2 id=\"结构体中-const-使用场景\"><a href=\"#结构体中-const-使用场景\" class=\"headerlink\" title=\"结构体中 const 使用场景\"></a>结构体中 const 使用场景</h2>"},{"title":"QT 学习记录","date":"2024-05-30T16:00:00.000Z","description":"QT 学习记录","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20220530203948_dd1b1.gif","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20220530203948_dd1b1.gif","poster":{"topic":null,"headline":"QT 学习记录","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n\n{% timeline %}\n\n<!-- node 2024 年 6 月 1 日 -->\n\n1. 开始学习。\n\n2. 看完第一部分：Qt 简介、Qt 项目模块、按钮控件、信号槽的概念；\n\n3. lambda表达式那里没听懂\n\n{% endtimeline %}\n\n# 0531【01-05】\n\n1. QT 简介、历史、优点**（跨平台、接口简单、一定程度上简化了内存回收）**、版本、成功案例\n2. 创建第一个QT程序 ([MacOS配置Clion的Qt环境的详细步骤（完整版）](https://blog.csdn.net/weixin_45571585/article/details/127074832))\n   1. QT Creator 配置了半天也没成功，决定还是使用 CLion 了\n\n# 0601【06-15】\n\n1. 创建一个按钮，设置按钮大小\n2. 固定窗口大小 `setFixesSize();`\n3. QT 的窗口坐标系，左上角为(0, 0)\n\n## 对象树\n\n* 父类释放内存，子类也自动释放（一定程度上简化了内存管理）\n* 构造自上而下，析构自下而上\n\n![IMG_5985](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5985.jpg)\n\n## 信号和槽\n\n优点：松散耦合，信号的发送端和接收端本身并没有关联，通过 connect 连接，将两端耦合在一起。\n\n```cpp\nconnect(信号的发送者，信号发送端，信号接收者，信号的处理（槽）)\n```\n\n* 信号发送端是一个地址\n* 信号可以连接信号\n* 一个信号可以连接多个槽函数\n* 多个信号可以连接同一个槽函数\n* 信号与槽函数的类型要一一对应\n* 信号的参数个数可以多于槽函数的参数个数\n\n![image-20240601170731941](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240601170731941.png)\n\n\n\n### 自定义信号与槽\n\n1. 自定义信号：\n   * 返回为 void\n   * 需要声明，无需实现\n   * **可以有参数（可以重载）**\n   * 可以写在 signals 下\n2. 自定义槽：\n   * 返回为 void\n   * 需要声明，也需要实现\n   * 可以有参数，可以重载\n   * 可以写到 public slot 或者 public 下\n\n\n\n## lambda表达式\n\n~~有点复杂，听不懂~~\n\n一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。\n\n声明格式如下：\n\n```cpp\n[capture list] (params list) mutable exception-> return type { function body }\n```\n\n各项具体含义如下，\n\n1. capture list：捕获外部变量列表\n2. params list：形参列表\n3. mutable指示符：用来说用是否可以修改捕获的变量\n4. exception：异常设定\n5. return type：返回类型\n6. function body：函数体\n\n\n\n# 0602【16】\n\n复习之前所学的内容\n\n# 0603【17-19】\n\n## QMainWindow\n\n![image-20240603102947005](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603102947005.png)\n\n* 菜单栏（Menu Bar）、工具栏(Tool Bar Area) 、状态栏、浮动窗口、中心部件的创建与相关设置\n\n```cpp\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QMenuBar>\n#include <QToolBar>\n#include <QStatusBar>\n#include <QLabel>\n#include <QDockWidget>\n#include <QTextEdit>\n\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    resize(600,400);\n\n    // 菜单栏只能有一个\n    // 创建菜单栏\n    QMenuBar *bar =  menuBar();\n    setMenuBar(bar);\n\n    // 创建菜单\n    QMenu *fileMeanu =  bar->addMenu(\"File\");\n    QMenu *editMeanu =  bar->addMenu(\"Edit\");\n\n    // 创建菜单项\n    QAction *newAction = fileMeanu->addAction(\"New\");\n    fileMeanu->addSeparator();\n    QAction *openAction = fileMeanu->addAction(\"Open\");\n\n    // 工具栏 可以有多个\n    QToolBar *toolbar = new QToolBar(this);\n    addToolBar(Qt::LeftToolBarArea, toolbar);\n\n    toolbar->addAction(\"Debug\");\n    toolbar->addSeparator();\n    toolbar->addAction(\"More\");\n\n    // toolbar->addAction(newAction);\n    // 状态栏\n    QStatusBar *staBar = statusBar();\n    setStatusBar(staBar);\n    QLabel *label = new QLabel(\"Montee\", this);\n    staBar->addPermanentWidget(label);\n\n\n    // 浮动窗口\n    QDockWidget *dockWidget = new QDockWidget(\"fudong\", this);\n    addDockWidget(dockWidget);\n\n    // 中心部件\n    QTextEdit *edit = new QTextEdit(this);\n    setCentralWidget(edit);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n```\n\n效果如图：\n\n![image-20240603144423162](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603144423162.png)\n\n## 资源文件添加\n\n1. Qt Creator 中 UI 设计的使用\n2. Qt Resource File\n\n# 0605【20-】\n\n## 模态和非模态对话框的实现\n\n* 模态对话框：\n* 非模态对话框：\n\n\n\n9712 3876\n","source":"_posts/QT学习.md","raw":"---\n# 基本信息\ntitle: QT 学习记录\ndate: 2024/05/31\ntags: [cpp, QT]\ncategories: [cpp, QT]\ndescription: QT 学习记录\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20220530203948_dd1b1.gif\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20220530203948_dd1b1.gif\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  QT 学习记录 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n\n\n{% timeline %}\n\n<!-- node 2024 年 6 月 1 日 -->\n\n1. 开始学习。\n\n2. 看完第一部分：Qt 简介、Qt 项目模块、按钮控件、信号槽的概念；\n\n3. lambda表达式那里没听懂\n\n{% endtimeline %}\n\n# 0531【01-05】\n\n1. QT 简介、历史、优点**（跨平台、接口简单、一定程度上简化了内存回收）**、版本、成功案例\n2. 创建第一个QT程序 ([MacOS配置Clion的Qt环境的详细步骤（完整版）](https://blog.csdn.net/weixin_45571585/article/details/127074832))\n   1. QT Creator 配置了半天也没成功，决定还是使用 CLion 了\n\n# 0601【06-15】\n\n1. 创建一个按钮，设置按钮大小\n2. 固定窗口大小 `setFixesSize();`\n3. QT 的窗口坐标系，左上角为(0, 0)\n\n## 对象树\n\n* 父类释放内存，子类也自动释放（一定程度上简化了内存管理）\n* 构造自上而下，析构自下而上\n\n![IMG_5985](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5985.jpg)\n\n## 信号和槽\n\n优点：松散耦合，信号的发送端和接收端本身并没有关联，通过 connect 连接，将两端耦合在一起。\n\n```cpp\nconnect(信号的发送者，信号发送端，信号接收者，信号的处理（槽）)\n```\n\n* 信号发送端是一个地址\n* 信号可以连接信号\n* 一个信号可以连接多个槽函数\n* 多个信号可以连接同一个槽函数\n* 信号与槽函数的类型要一一对应\n* 信号的参数个数可以多于槽函数的参数个数\n\n![image-20240601170731941](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240601170731941.png)\n\n\n\n### 自定义信号与槽\n\n1. 自定义信号：\n   * 返回为 void\n   * 需要声明，无需实现\n   * **可以有参数（可以重载）**\n   * 可以写在 signals 下\n2. 自定义槽：\n   * 返回为 void\n   * 需要声明，也需要实现\n   * 可以有参数，可以重载\n   * 可以写到 public slot 或者 public 下\n\n\n\n## lambda表达式\n\n~~有点复杂，听不懂~~\n\n一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。\n\n声明格式如下：\n\n```cpp\n[capture list] (params list) mutable exception-> return type { function body }\n```\n\n各项具体含义如下，\n\n1. capture list：捕获外部变量列表\n2. params list：形参列表\n3. mutable指示符：用来说用是否可以修改捕获的变量\n4. exception：异常设定\n5. return type：返回类型\n6. function body：函数体\n\n\n\n# 0602【16】\n\n复习之前所学的内容\n\n# 0603【17-19】\n\n## QMainWindow\n\n![image-20240603102947005](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603102947005.png)\n\n* 菜单栏（Menu Bar）、工具栏(Tool Bar Area) 、状态栏、浮动窗口、中心部件的创建与相关设置\n\n```cpp\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QMenuBar>\n#include <QToolBar>\n#include <QStatusBar>\n#include <QLabel>\n#include <QDockWidget>\n#include <QTextEdit>\n\nMainWindow::MainWindow(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n    resize(600,400);\n\n    // 菜单栏只能有一个\n    // 创建菜单栏\n    QMenuBar *bar =  menuBar();\n    setMenuBar(bar);\n\n    // 创建菜单\n    QMenu *fileMeanu =  bar->addMenu(\"File\");\n    QMenu *editMeanu =  bar->addMenu(\"Edit\");\n\n    // 创建菜单项\n    QAction *newAction = fileMeanu->addAction(\"New\");\n    fileMeanu->addSeparator();\n    QAction *openAction = fileMeanu->addAction(\"Open\");\n\n    // 工具栏 可以有多个\n    QToolBar *toolbar = new QToolBar(this);\n    addToolBar(Qt::LeftToolBarArea, toolbar);\n\n    toolbar->addAction(\"Debug\");\n    toolbar->addSeparator();\n    toolbar->addAction(\"More\");\n\n    // toolbar->addAction(newAction);\n    // 状态栏\n    QStatusBar *staBar = statusBar();\n    setStatusBar(staBar);\n    QLabel *label = new QLabel(\"Montee\", this);\n    staBar->addPermanentWidget(label);\n\n\n    // 浮动窗口\n    QDockWidget *dockWidget = new QDockWidget(\"fudong\", this);\n    addDockWidget(dockWidget);\n\n    // 中心部件\n    QTextEdit *edit = new QTextEdit(this);\n    setCentralWidget(edit);\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n```\n\n效果如图：\n\n![image-20240603144423162](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603144423162.png)\n\n## 资源文件添加\n\n1. Qt Creator 中 UI 设计的使用\n2. Qt Resource File\n\n# 0605【20-】\n\n## 模态和非模态对话框的实现\n\n* 模态对话框：\n* 非模态对话框：\n\n\n\n9712 3876\n","slug":"QT学习","published":1,"updated":"2024-06-07T03:05:15.767Z","layout":"post","photos":[],"_id":"clx8i4fa20003qt3a7fsk0ofs","content":"<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 6 月 1 日</div><div class=\"body fs14\"><ol><li><p>开始学习。</p></li><li><p>看完第一部分：Qt 简介、Qt 项目模块、按钮控件、信号槽的概念；</p></li><li><p>lambda表达式那里没听懂</p></li></ol></div></div></div>\n\n<h1 id=\"0531【01-05】\"><a href=\"#0531【01-05】\" class=\"headerlink\" title=\"0531【01-05】\"></a>0531【01-05】</h1><ol>\n<li>QT 简介、历史、优点<strong>（跨平台、接口简单、一定程度上简化了内存回收）</strong>、版本、成功案例</li>\n<li>创建第一个QT程序 (<a href=\"https://blog.csdn.net/weixin_45571585/article/details/127074832\">MacOS配置Clion的Qt环境的详细步骤（完整版）</a>)<ol>\n<li>QT Creator 配置了半天也没成功，决定还是使用 CLion 了</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"0601【06-15】\"><a href=\"#0601【06-15】\" class=\"headerlink\" title=\"0601【06-15】\"></a>0601【06-15】</h1><ol>\n<li>创建一个按钮，设置按钮大小</li>\n<li>固定窗口大小 <code>setFixesSize();</code></li>\n<li>QT 的窗口坐标系，左上角为(0, 0)</li>\n</ol>\n<h2 id=\"对象树\"><a href=\"#对象树\" class=\"headerlink\" title=\"对象树\"></a>对象树</h2><ul>\n<li>父类释放内存，子类也自动释放（一定程度上简化了内存管理）</li>\n<li>构造自上而下，析构自下而上</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5985.jpg\" alt=\"IMG_5985\"></p>\n<h2 id=\"信号和槽\"><a href=\"#信号和槽\" class=\"headerlink\" title=\"信号和槽\"></a>信号和槽</h2><p>优点：松散耦合，信号的发送端和接收端本身并没有关联，通过 connect 连接，将两端耦合在一起。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">connect</span>(信号的发送者，信号发送端，信号接收者，信号的处理（槽）)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>信号发送端是一个地址</li>\n<li>信号可以连接信号</li>\n<li>一个信号可以连接多个槽函数</li>\n<li>多个信号可以连接同一个槽函数</li>\n<li>信号与槽函数的类型要一一对应</li>\n<li>信号的参数个数可以多于槽函数的参数个数</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240601170731941.png\" alt=\"image-20240601170731941\"></p>\n<h3 id=\"自定义信号与槽\"><a href=\"#自定义信号与槽\" class=\"headerlink\" title=\"自定义信号与槽\"></a>自定义信号与槽</h3><ol>\n<li>自定义信号：<ul>\n<li>返回为 void</li>\n<li>需要声明，无需实现</li>\n<li><strong>可以有参数（可以重载）</strong></li>\n<li>可以写在 signals 下</li>\n</ul>\n</li>\n<li>自定义槽：<ul>\n<li>返回为 void</li>\n<li>需要声明，也需要实现</li>\n<li>可以有参数，可以重载</li>\n<li>可以写到 public slot 或者 public 下</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h2><p><del>有点复杂，听不懂</del></p>\n<p>一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。</p>\n<p>声明格式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture list] (params list) <span class=\"keyword\">mutable</span> exception-&gt; <span class=\"keyword\">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>\n\n<p>各项具体含义如下，</p>\n<ol>\n<li>capture list：捕获外部变量列表</li>\n<li>params list：形参列表</li>\n<li>mutable指示符：用来说用是否可以修改捕获的变量</li>\n<li>exception：异常设定</li>\n<li>return type：返回类型</li>\n<li>function body：函数体</li>\n</ol>\n<h1 id=\"0602【16】\"><a href=\"#0602【16】\" class=\"headerlink\" title=\"0602【16】\"></a>0602【16】</h1><p>复习之前所学的内容</p>\n<h1 id=\"0603【17-19】\"><a href=\"#0603【17-19】\" class=\"headerlink\" title=\"0603【17-19】\"></a>0603【17-19】</h1><h2 id=\"QMainWindow\"><a href=\"#QMainWindow\" class=\"headerlink\" title=\"QMainWindow\"></a>QMainWindow</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603102947005.png\" alt=\"image-20240603102947005\"></p>\n<ul>\n<li>菜单栏（Menu Bar）、工具栏(Tool Bar Area) 、状态栏、浮动窗口、中心部件的创建与相关设置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mainwindow.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QMenuBar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QToolBar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QStatusBar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QLabel&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QDockWidget&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QTextEdit&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">MainWindow::<span class=\"built_in\">MainWindow</span>(QWidget *parent) :</span><br><span class=\"line\">    <span class=\"built_in\">QMainWindow</span>(parent),</span><br><span class=\"line\">    <span class=\"built_in\">ui</span>(<span class=\"keyword\">new</span> Ui::MainWindow)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ui-&gt;<span class=\"built_in\">setupUi</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">resize</span>(<span class=\"number\">600</span>,<span class=\"number\">400</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 菜单栏只能有一个</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建菜单栏</span></span><br><span class=\"line\">    QMenuBar *bar =  <span class=\"built_in\">menuBar</span>();</span><br><span class=\"line\">    <span class=\"built_in\">setMenuBar</span>(bar);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建菜单</span></span><br><span class=\"line\">    QMenu *fileMeanu =  bar-&gt;<span class=\"built_in\">addMenu</span>(<span class=\"string\">&quot;File&quot;</span>);</span><br><span class=\"line\">    QMenu *editMeanu =  bar-&gt;<span class=\"built_in\">addMenu</span>(<span class=\"string\">&quot;Edit&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建菜单项</span></span><br><span class=\"line\">    QAction *newAction = fileMeanu-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;New&quot;</span>);</span><br><span class=\"line\">    fileMeanu-&gt;<span class=\"built_in\">addSeparator</span>();</span><br><span class=\"line\">    QAction *openAction = fileMeanu-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;Open&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工具栏 可以有多个</span></span><br><span class=\"line\">    QToolBar *toolbar = <span class=\"keyword\">new</span> <span class=\"built_in\">QToolBar</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">addToolBar</span>(Qt::LeftToolBarArea, toolbar);</span><br><span class=\"line\"></span><br><span class=\"line\">    toolbar-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;Debug&quot;</span>);</span><br><span class=\"line\">    toolbar-&gt;<span class=\"built_in\">addSeparator</span>();</span><br><span class=\"line\">    toolbar-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;More&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// toolbar-&gt;addAction(newAction);</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态栏</span></span><br><span class=\"line\">    QStatusBar *staBar = <span class=\"built_in\">statusBar</span>();</span><br><span class=\"line\">    <span class=\"built_in\">setStatusBar</span>(staBar);</span><br><span class=\"line\">    QLabel *label = <span class=\"keyword\">new</span> <span class=\"built_in\">QLabel</span>(<span class=\"string\">&quot;Montee&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    staBar-&gt;<span class=\"built_in\">addPermanentWidget</span>(label);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮动窗口</span></span><br><span class=\"line\">    QDockWidget *dockWidget = <span class=\"keyword\">new</span> <span class=\"built_in\">QDockWidget</span>(<span class=\"string\">&quot;fudong&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">addDockWidget</span>(dockWidget);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中心部件</span></span><br><span class=\"line\">    QTextEdit *edit = <span class=\"keyword\">new</span> <span class=\"built_in\">QTextEdit</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setCentralWidget</span>(edit);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MainWindow::~<span class=\"built_in\">MainWindow</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ui;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603144423162.png\" alt=\"image-20240603144423162\"></p>\n<h2 id=\"资源文件添加\"><a href=\"#资源文件添加\" class=\"headerlink\" title=\"资源文件添加\"></a>资源文件添加</h2><ol>\n<li>Qt Creator 中 UI 设计的使用</li>\n<li>Qt Resource File</li>\n</ol>\n<h1 id=\"0605【20-】\"><a href=\"#0605【20-】\" class=\"headerlink\" title=\"0605【20-】\"></a>0605【20-】</h1><h2 id=\"模态和非模态对话框的实现\"><a href=\"#模态和非模态对话框的实现\" class=\"headerlink\" title=\"模态和非模态对话框的实现\"></a>模态和非模态对话框的实现</h2><ul>\n<li>模态对话框：</li>\n<li>非模态对话框：</li>\n</ul>\n<p>9712 3876</p>\n","excerpt":"","more":"<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 6 月 1 日</div><div class=\"body fs14\"><ol><li><p>开始学习。</p></li><li><p>看完第一部分：Qt 简介、Qt 项目模块、按钮控件、信号槽的概念；</p></li><li><p>lambda表达式那里没听懂</p></li></ol></div></div></div>\n\n<h1 id=\"0531【01-05】\"><a href=\"#0531【01-05】\" class=\"headerlink\" title=\"0531【01-05】\"></a>0531【01-05】</h1><ol>\n<li>QT 简介、历史、优点<strong>（跨平台、接口简单、一定程度上简化了内存回收）</strong>、版本、成功案例</li>\n<li>创建第一个QT程序 (<a href=\"https://blog.csdn.net/weixin_45571585/article/details/127074832\">MacOS配置Clion的Qt环境的详细步骤（完整版）</a>)<ol>\n<li>QT Creator 配置了半天也没成功，决定还是使用 CLion 了</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"0601【06-15】\"><a href=\"#0601【06-15】\" class=\"headerlink\" title=\"0601【06-15】\"></a>0601【06-15】</h1><ol>\n<li>创建一个按钮，设置按钮大小</li>\n<li>固定窗口大小 <code>setFixesSize();</code></li>\n<li>QT 的窗口坐标系，左上角为(0, 0)</li>\n</ol>\n<h2 id=\"对象树\"><a href=\"#对象树\" class=\"headerlink\" title=\"对象树\"></a>对象树</h2><ul>\n<li>父类释放内存，子类也自动释放（一定程度上简化了内存管理）</li>\n<li>构造自上而下，析构自下而上</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5985.jpg\" alt=\"IMG_5985\"></p>\n<h2 id=\"信号和槽\"><a href=\"#信号和槽\" class=\"headerlink\" title=\"信号和槽\"></a>信号和槽</h2><p>优点：松散耦合，信号的发送端和接收端本身并没有关联，通过 connect 连接，将两端耦合在一起。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">connect</span>(信号的发送者，信号发送端，信号接收者，信号的处理（槽）)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>信号发送端是一个地址</li>\n<li>信号可以连接信号</li>\n<li>一个信号可以连接多个槽函数</li>\n<li>多个信号可以连接同一个槽函数</li>\n<li>信号与槽函数的类型要一一对应</li>\n<li>信号的参数个数可以多于槽函数的参数个数</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240601170731941.png\" alt=\"image-20240601170731941\"></p>\n<h3 id=\"自定义信号与槽\"><a href=\"#自定义信号与槽\" class=\"headerlink\" title=\"自定义信号与槽\"></a>自定义信号与槽</h3><ol>\n<li>自定义信号：<ul>\n<li>返回为 void</li>\n<li>需要声明，无需实现</li>\n<li><strong>可以有参数（可以重载）</strong></li>\n<li>可以写在 signals 下</li>\n</ul>\n</li>\n<li>自定义槽：<ul>\n<li>返回为 void</li>\n<li>需要声明，也需要实现</li>\n<li>可以有参数，可以重载</li>\n<li>可以写到 public slot 或者 public 下</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h2><p><del>有点复杂，听不懂</del></p>\n<p>一种在被调用的位置或作为参数传递给函数的位置定义匿名函数对象（闭包）的简便方法。</p>\n<p>声明格式如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[capture list] (params list) <span class=\"keyword\">mutable</span> exception-&gt; <span class=\"keyword\">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>\n\n<p>各项具体含义如下，</p>\n<ol>\n<li>capture list：捕获外部变量列表</li>\n<li>params list：形参列表</li>\n<li>mutable指示符：用来说用是否可以修改捕获的变量</li>\n<li>exception：异常设定</li>\n<li>return type：返回类型</li>\n<li>function body：函数体</li>\n</ol>\n<h1 id=\"0602【16】\"><a href=\"#0602【16】\" class=\"headerlink\" title=\"0602【16】\"></a>0602【16】</h1><p>复习之前所学的内容</p>\n<h1 id=\"0603【17-19】\"><a href=\"#0603【17-19】\" class=\"headerlink\" title=\"0603【17-19】\"></a>0603【17-19】</h1><h2 id=\"QMainWindow\"><a href=\"#QMainWindow\" class=\"headerlink\" title=\"QMainWindow\"></a>QMainWindow</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603102947005.png\" alt=\"image-20240603102947005\"></p>\n<ul>\n<li>菜单栏（Menu Bar）、工具栏(Tool Bar Area) 、状态栏、浮动窗口、中心部件的创建与相关设置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;mainwindow.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&quot;ui_mainwindow.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QMenuBar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QToolBar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QStatusBar&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QLabel&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QDockWidget&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;QTextEdit&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">MainWindow::<span class=\"built_in\">MainWindow</span>(QWidget *parent) :</span><br><span class=\"line\">    <span class=\"built_in\">QMainWindow</span>(parent),</span><br><span class=\"line\">    <span class=\"built_in\">ui</span>(<span class=\"keyword\">new</span> Ui::MainWindow)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ui-&gt;<span class=\"built_in\">setupUi</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">resize</span>(<span class=\"number\">600</span>,<span class=\"number\">400</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 菜单栏只能有一个</span></span><br><span class=\"line\">    <span class=\"comment\">// 创建菜单栏</span></span><br><span class=\"line\">    QMenuBar *bar =  <span class=\"built_in\">menuBar</span>();</span><br><span class=\"line\">    <span class=\"built_in\">setMenuBar</span>(bar);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建菜单</span></span><br><span class=\"line\">    QMenu *fileMeanu =  bar-&gt;<span class=\"built_in\">addMenu</span>(<span class=\"string\">&quot;File&quot;</span>);</span><br><span class=\"line\">    QMenu *editMeanu =  bar-&gt;<span class=\"built_in\">addMenu</span>(<span class=\"string\">&quot;Edit&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建菜单项</span></span><br><span class=\"line\">    QAction *newAction = fileMeanu-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;New&quot;</span>);</span><br><span class=\"line\">    fileMeanu-&gt;<span class=\"built_in\">addSeparator</span>();</span><br><span class=\"line\">    QAction *openAction = fileMeanu-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;Open&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工具栏 可以有多个</span></span><br><span class=\"line\">    QToolBar *toolbar = <span class=\"keyword\">new</span> <span class=\"built_in\">QToolBar</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">addToolBar</span>(Qt::LeftToolBarArea, toolbar);</span><br><span class=\"line\"></span><br><span class=\"line\">    toolbar-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;Debug&quot;</span>);</span><br><span class=\"line\">    toolbar-&gt;<span class=\"built_in\">addSeparator</span>();</span><br><span class=\"line\">    toolbar-&gt;<span class=\"built_in\">addAction</span>(<span class=\"string\">&quot;More&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// toolbar-&gt;addAction(newAction);</span></span><br><span class=\"line\">    <span class=\"comment\">// 状态栏</span></span><br><span class=\"line\">    QStatusBar *staBar = <span class=\"built_in\">statusBar</span>();</span><br><span class=\"line\">    <span class=\"built_in\">setStatusBar</span>(staBar);</span><br><span class=\"line\">    QLabel *label = <span class=\"keyword\">new</span> <span class=\"built_in\">QLabel</span>(<span class=\"string\">&quot;Montee&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    staBar-&gt;<span class=\"built_in\">addPermanentWidget</span>(label);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 浮动窗口</span></span><br><span class=\"line\">    QDockWidget *dockWidget = <span class=\"keyword\">new</span> <span class=\"built_in\">QDockWidget</span>(<span class=\"string\">&quot;fudong&quot;</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">addDockWidget</span>(dockWidget);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 中心部件</span></span><br><span class=\"line\">    QTextEdit *edit = <span class=\"keyword\">new</span> <span class=\"built_in\">QTextEdit</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"built_in\">setCentralWidget</span>(edit);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MainWindow::~<span class=\"built_in\">MainWindow</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ui;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如图：</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240603144423162.png\" alt=\"image-20240603144423162\"></p>\n<h2 id=\"资源文件添加\"><a href=\"#资源文件添加\" class=\"headerlink\" title=\"资源文件添加\"></a>资源文件添加</h2><ol>\n<li>Qt Creator 中 UI 设计的使用</li>\n<li>Qt Resource File</li>\n</ol>\n<h1 id=\"0605【20-】\"><a href=\"#0605【20-】\" class=\"headerlink\" title=\"0605【20-】\"></a>0605【20-】</h1><h2 id=\"模态和非模态对话框的实现\"><a href=\"#模态和非模态对话框的实现\" class=\"headerlink\" title=\"模态和非模态对话框的实现\"></a>模态和非模态对话框的实现</h2><ul>\n<li>模态对话框：</li>\n<li>非模态对话框：</li>\n</ul>\n<p>9712 3876</p>\n"},{"title":"Blog 更新日志暨Hello World","date":"2024-05-06T16:00:00.000Z","description":"用于记录此博客的更新日志；同时，程序员不可越少的一集：问候世界","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/thumbbig-1313894.webp","banner":null,"poster":{"topic":null,"headline":"Blog 更新日志暨Hello World","caption":"用于记录此博客的更新日志；同时，程序员不可越少的一集：问候世界","color":null},"sticky":"tagcloud","mermaid":null,"katex":true,"mathjax":null,"topic":"Blog","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"story","_content":"\n\n{% quot 1. 起航 %}\n\n\n偶然之下看到 [cayzlh](https://www.cayzlh.com) 的博客，非常简洁，脑子一热决定跟个风，经过一个晚上的折腾，终于成功部署。\n\n1. 本站由 [Monty Lee](https://www.montylee.cn) 基于 [Hexo](https://hexo.io/zh-cn/) 框架下的 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1) 主题创建\n2. 使用 [GitHub](https://github.com) 托管代码，[Vercel](https://vercel.com) 实现无服务器部署\n\n\n\n{% quot 2. 更新时间线 %}\n\n{% timeline %}\n\n<!-- node 2024 年 6 月 7 日 -->\n评论功能设置成功\n\n<!-- node 2024 年 5 月 8 日 -->\n完成图床、静态友链的配置\n\n<!-- node 2024 年 5 月 7 日 -->\n部署成功啦！\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png width:300px %}\n\n{% endtimeline %}\n\n\n\n{% quot 3. 待完善 %}\n\n- [ ] **footer 部分的倒计时功能**\n\n  - [x] ~~初步实现功能~~\n\n  - [ ] 美化，参见 [cayzlh](https://www.cayzlh.com)  \n\n    ![](../images/footertime.png)\n\n\n- [ ] **右侧栏公告及索引**\n\n  {% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/undefinedrightsides.png width:200px padding:16px bg:white %}\n\n\n- [ ] **RSS 订阅**\n- [ ] 博客文章密码验证阅读\n- [ ] [小组件配置](https://xaoxuu.com/wiki/stellar/widgets/)\n\n{% quot 4. 已完成 %}\n\n\n- [x] ~~**图床**~~\n\n\n    - [x] ~~暂时使用 [imgtp](https://imgtp.com) 这个在线的免费图床~~\n\n\n\n    - [x] ~~不过觉得安全性不高，后续考虑使用 GitHub 作为图床，本地使用 PigGo 上传，jsDelivr 实现 CDN 加速，参加 [如何使用jsDelivr+Github 实现免费CDN加速?](https://zhuanlan.zhihu.com/p/346643522)~~\n\n\n\n    - [x] ~~实现使用腾讯云 COS+PicGo 实现图床（新买了一个存储桶后，发现去年买的还没过期，伤心了）~~ \n\n\n\n    - [x] PicGo 图床插件设置\n\n- [x] **友链和关于页面**\n\n  - [x] ~~尝试动态友链失败，最终还是选择了静态的友链~~\n\n- [x] 评论插件配置\n\n\n  - [x] 使用 [giscus](https://giscus.app/zh-CN) 作为评论系统\n\n- [x] 文章页面发布和更新时间有问题\n\n  {% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240508230949859.png  %}\n\n  发现是写文章时填写时间有误，只能写年/月/日\n\n\n---\n{% quot 引用 %}\n  - [如何使用jsDelivr+Github 实现免费CDN加速?](https://zhuanlan.zhihu.com/p/346643522)\n  - [如何利用 Github 搭建自己的免费图床？](https://zhuanlan.zhihu.com/p/353775844)\n  - [Stellar - 每个人的独立博客](https://xaoxuu.com/wiki/stellar/#start)\n  - ...\n\n---\n","source":"_posts/hello-world.md","raw":"---\n# 基本信息\ntitle: Blog 更新日志暨Hello World\ndate: 2024/05/07\ntags: [Blog]\ncategories: [Blog]\ndescription: 用于记录此博客的更新日志；同时，程序员不可越少的一集：问候世界\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/thumbbig-1313894.webp\nbanner: \nposter: # 海报（可选，全图封面卡片）\n  topic:   # 可选\n  headline: Blog 更新日志暨Hello World # 必选\n  caption: 用于记录此博客的更新日志；同时，程序员不可越少的一集：问候世界 # 可选\n  color: # 可选\n# 插件\nsticky: tagcloud # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: Blog # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: story # tech/story\n---\n\n\n{% quot 1. 起航 %}\n\n\n偶然之下看到 [cayzlh](https://www.cayzlh.com) 的博客，非常简洁，脑子一热决定跟个风，经过一个晚上的折腾，终于成功部署。\n\n1. 本站由 [Monty Lee](https://www.montylee.cn) 基于 [Hexo](https://hexo.io/zh-cn/) 框架下的 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1) 主题创建\n2. 使用 [GitHub](https://github.com) 托管代码，[Vercel](https://vercel.com) 实现无服务器部署\n\n\n\n{% quot 2. 更新时间线 %}\n\n{% timeline %}\n\n<!-- node 2024 年 6 月 7 日 -->\n评论功能设置成功\n\n<!-- node 2024 年 5 月 8 日 -->\n完成图床、静态友链的配置\n\n<!-- node 2024 年 5 月 7 日 -->\n部署成功啦！\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png width:300px %}\n\n{% endtimeline %}\n\n\n\n{% quot 3. 待完善 %}\n\n- [ ] **footer 部分的倒计时功能**\n\n  - [x] ~~初步实现功能~~\n\n  - [ ] 美化，参见 [cayzlh](https://www.cayzlh.com)  \n\n    ![](../images/footertime.png)\n\n\n- [ ] **右侧栏公告及索引**\n\n  {% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/undefinedrightsides.png width:200px padding:16px bg:white %}\n\n\n- [ ] **RSS 订阅**\n- [ ] 博客文章密码验证阅读\n- [ ] [小组件配置](https://xaoxuu.com/wiki/stellar/widgets/)\n\n{% quot 4. 已完成 %}\n\n\n- [x] ~~**图床**~~\n\n\n    - [x] ~~暂时使用 [imgtp](https://imgtp.com) 这个在线的免费图床~~\n\n\n\n    - [x] ~~不过觉得安全性不高，后续考虑使用 GitHub 作为图床，本地使用 PigGo 上传，jsDelivr 实现 CDN 加速，参加 [如何使用jsDelivr+Github 实现免费CDN加速?](https://zhuanlan.zhihu.com/p/346643522)~~\n\n\n\n    - [x] ~~实现使用腾讯云 COS+PicGo 实现图床（新买了一个存储桶后，发现去年买的还没过期，伤心了）~~ \n\n\n\n    - [x] PicGo 图床插件设置\n\n- [x] **友链和关于页面**\n\n  - [x] ~~尝试动态友链失败，最终还是选择了静态的友链~~\n\n- [x] 评论插件配置\n\n\n  - [x] 使用 [giscus](https://giscus.app/zh-CN) 作为评论系统\n\n- [x] 文章页面发布和更新时间有问题\n\n  {% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240508230949859.png  %}\n\n  发现是写文章时填写时间有误，只能写年/月/日\n\n\n---\n{% quot 引用 %}\n  - [如何使用jsDelivr+Github 实现免费CDN加速?](https://zhuanlan.zhihu.com/p/346643522)\n  - [如何利用 Github 搭建自己的免费图床？](https://zhuanlan.zhihu.com/p/353775844)\n  - [Stellar - 每个人的独立博客](https://xaoxuu.com/wiki/stellar/#start)\n  - ...\n\n---\n","slug":"hello-world","published":1,"updated":"2024-06-07T03:53:22.871Z","layout":"post","photos":[],"_id":"clx8i4fa30006qt3a0mm81r5z","content":"<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">1. 起航</span><span class=\"empty\"></span></p></div>\n\n\n<p>偶然之下看到 <a href=\"https://www.cayzlh.com/\">cayzlh</a> 的博客，非常简洁，脑子一热决定跟个风，经过一个晚上的折腾，终于成功部署。</p>\n<ol>\n<li>本站由 <a href=\"https://www.montylee.cn/\">Monty Lee</a> 基于 <a href=\"https://hexo.io/zh-cn/\">Hexo</a> 框架下的 <a href=\"https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1\">Stellar</a> 主题创建</li>\n<li>使用 <a href=\"https://github.com/\">GitHub</a> 托管代码，<a href=\"https://vercel.com/\">Vercel</a> 实现无服务器部署</li>\n</ol>\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">2. 更新时间线</span><span class=\"empty\"></span></p></div>\n\n<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 6 月 7 日</div><div class=\"body fs14\"><p>评论功能设置成功</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 8 日</div><div class=\"body fs14\"><p>完成图床、静态友链的配置</p></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 7 日</div><div class=\"body fs14\"><p>部署成功啦！</p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png\" style=\"width:300px;\"/></div></div></div></div></div>\n\n\n\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">3. 待完善</span><span class=\"empty\"></span></p></div>\n\n<ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<strong>footer 部分的倒计时功能</strong></p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>初步实现功能</del></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n美化，参见 <a href=\"https://www.cayzlh.com/\">cayzlh</a>  </p>\n<p><img src=\"/../images/footertime.png\"></p>\n</li>\n</ul>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<strong>右侧栏公告及索引</strong></p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\" style=\"background:white;padding:16px;\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/undefinedrightsides.png\" style=\"width:200px;\"/></div></div>\n\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<strong>RSS 订阅</strong></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n博客文章密码验证阅读</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://xaoxuu.com/wiki/stellar/widgets/\">小组件配置</a></p>\n</li>\n</ul>\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">4. 已完成</span><span class=\"empty\"></span></p></div>\n\n\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del><strong>图床</strong></del></p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>暂时使用 <a href=\"https://imgtp.com/\">imgtp</a> 这个在线的免费图床</del></p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>不过觉得安全性不高，后续考虑使用 GitHub 作为图床，本地使用 PigGo 上传，jsDelivr 实现 CDN 加速，参加 <a href=\"https://zhuanlan.zhihu.com/p/346643522\">如何使用jsDelivr+Github 实现免费CDN加速?</a></del></p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>实现使用腾讯云 COS+PicGo 实现图床（新买了一个存储桶后，发现去年买的还没过期，伤心了）</del> </p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \nPicGo 图床插件设置</p>\n</li>\n</ul>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<strong>友链和关于页面</strong></p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <del>尝试动态友链失败，最终还是选择了静态的友链</del></li>\n</ul>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n评论插件配置</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 使用 <a href=\"https://giscus.app/zh-CN\">giscus</a> 作为评论系统</li>\n</ul>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n文章页面发布和更新时间有问题</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240508230949859.png\"/></div></div>\n\n<p>发现是写文章时填写时间有误，只能写年&#x2F;月&#x2F;日</p>\n</li>\n</ul>\n<hr>\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">引用</span><span class=\"empty\"></span></p></div>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/346643522\">如何使用jsDelivr+Github 实现免费CDN加速?</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353775844\">如何利用 Github 搭建自己的免费图床？</a></li>\n<li><a href=\"https://xaoxuu.com/wiki/stellar/#start\">Stellar - 每个人的独立博客</a></li>\n<li>…</li>\n</ul>\n<hr>\n","excerpt":"","more":"<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">1. 起航</span><span class=\"empty\"></span></p></div>\n\n\n<p>偶然之下看到 <a href=\"https://www.cayzlh.com/\">cayzlh</a> 的博客，非常简洁，脑子一热决定跟个风，经过一个晚上的折腾，终于成功部署。</p>\n<ol>\n<li>本站由 <a href=\"https://www.montylee.cn/\">Monty Lee</a> 基于 <a href=\"https://hexo.io/zh-cn/\">Hexo</a> 框架下的 <a href=\"https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1\">Stellar</a> 主题创建</li>\n<li>使用 <a href=\"https://github.com/\">GitHub</a> 托管代码，<a href=\"https://vercel.com/\">Vercel</a> 实现无服务器部署</li>\n</ol>\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">2. 更新时间线</span><span class=\"empty\"></span></p></div>\n\n<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 6 月 7 日</div><div class=\"body fs14\"><p>评论功能设置成功</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 8 日</div><div class=\"body fs14\"><p>完成图床、静态友链的配置</p></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 7 日</div><div class=\"body fs14\"><p>部署成功啦！</p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/hello.png\" style=\"width:300px;\"/></div></div></div></div></div>\n\n\n\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">3. 待完善</span><span class=\"empty\"></span></p></div>\n\n<ul>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<strong>footer 部分的倒计时功能</strong></p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>初步实现功能</del></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n美化，参见 <a href=\"https://www.cayzlh.com/\">cayzlh</a>  </p>\n<p><img src=\"/../images/footertime.png\"></p>\n</li>\n</ul>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<strong>右侧栏公告及索引</strong></p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\" style=\"background:white;padding:16px;\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/undefinedrightsides.png\" style=\"width:200px;\"/></div></div>\n\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<strong>RSS 订阅</strong></p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n博客文章密码验证阅读</p>\n</li>\n<li><p><input disabled=\"\" type=\"checkbox\"> \n<a href=\"https://xaoxuu.com/wiki/stellar/widgets/\">小组件配置</a></p>\n</li>\n</ul>\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">4. 已完成</span><span class=\"empty\"></span></p></div>\n\n\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del><strong>图床</strong></del></p>\n<ul>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>暂时使用 <a href=\"https://imgtp.com/\">imgtp</a> 这个在线的免费图床</del></p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>不过觉得安全性不高，后续考虑使用 GitHub 作为图床，本地使用 PigGo 上传，jsDelivr 实现 CDN 加速，参加 <a href=\"https://zhuanlan.zhihu.com/p/346643522\">如何使用jsDelivr+Github 实现免费CDN加速?</a></del></p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<del>实现使用腾讯云 COS+PicGo 实现图床（新买了一个存储桶后，发现去年买的还没过期，伤心了）</del> </p>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \nPicGo 图床插件设置</p>\n</li>\n</ul>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n<strong>友链和关于页面</strong></p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> <del>尝试动态友链失败，最终还是选择了静态的友链</del></li>\n</ul>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n评论插件配置</p>\n<ul>\n<li><input checked=\"\" disabled=\"\" type=\"checkbox\"> 使用 <a href=\"https://giscus.app/zh-CN\">giscus</a> 作为评论系统</li>\n</ul>\n</li>\n<li><p><input checked=\"\" disabled=\"\" type=\"checkbox\"> \n文章页面发布和更新时间有问题</p>\n<div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240508230949859.png\"/></div></div>\n\n<p>发现是写文章时填写时间有误，只能写年&#x2F;月&#x2F;日</p>\n</li>\n</ul>\n<hr>\n<div class=\"tag-plugin quot\"><p class=\"content\" type=\"text\"><span class=\"empty\"></span><span class=\"text\">引用</span><span class=\"empty\"></span></p></div>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/346643522\">如何使用jsDelivr+Github 实现免费CDN加速?</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/353775844\">如何利用 Github 搭建自己的免费图床？</a></li>\n<li><a href=\"https://xaoxuu.com/wiki/stellar/#start\">Stellar - 每个人的独立博客</a></li>\n<li>…</li>\n</ul>\n<hr>\n"},{"title":"代码随想录","date":"2024-05-27T16:00:00.000Z","description":"代码随想录刷题记录","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/41370f2e263ceb323994939fe9f9ae4e.jpg","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/41370f2e263ceb323994939fe9f9ae4e.jpg","poster":{"topic":null,"headline":"代码随想录刷题记录","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n{% timeline %}\n\n<!-- node 2024 年 5 月 28 日 -->\n\n数组部分结束！\n\n<!-- node 2024 年 5 月 22 日 -->\n\n实习开始，刷题开始！\n\n{% endtimeline %}","source":"_posts/代码随想录.md","raw":"---\n# 基本信息\ntitle: 代码随想录\ndate: 2024/05/28\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 代码随想录刷题记录\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/41370f2e263ceb323994939fe9f9ae4e.jpg\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/41370f2e263ceb323994939fe9f9ae4e.jpg\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  代码随想录刷题记录 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 28 日 -->\n\n数组部分结束！\n\n<!-- node 2024 年 5 月 22 日 -->\n\n实习开始，刷题开始！\n\n{% endtimeline %}","slug":"代码随想录","published":1,"updated":"2024-06-07T03:04:00.281Z","layout":"post","photos":[],"_id":"clx8i4fa40007qt3a0kba3g1e","content":"<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 28 日</div><div class=\"body fs14\"><p>数组部分结束！</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 22 日</div><div class=\"body fs14\"><p>实习开始，刷题开始！</p></div></div></div>","excerpt":"","more":"<div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 28 日</div><div class=\"body fs14\"><p>数组部分结束！</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 22 日</div><div class=\"body fs14\"><p>实习开始，刷题开始！</p></div></div></div>"},{"title":"C++ 学习","date":"2024-05-08T16:00:00.000Z","description":"C++ 学习记录","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/wallhaven-1ppld1.jpg","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/wallhaven-1ppld1.jpg","poster":{"topic":null,"headline":"C++ 学习","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n~~（注：本内容仅供个人学习使用，请点击链接阅读原文）~~\n\n# 时间线\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 13 日 -->\n\n完成第一阶段的案例：通讯录管理系统，\n\n主要学习应用 C++ 的基础语法、指针、结构体等知识。\n\n<!-- node 2024 年 5 月 12 日 -->\n\n面试通过，小声吐槽：实习待遇极差……\n\n这几天将 C++ 基础语法过了一遍。\n\n<!-- node 2024 年 5 月 9 日 -->\n\n中海达面试结束，面试官说实习过程中主要是用 CPP 进行开发，于是决定利用这几天补习相关知识。\n\n{% endtimeline %}\n\n# 问题记录\n\n- [ ] 【20240531】对指针相关概念和操作不熟悉\n- [ ] 【20240601】this 指针\n\n# 学习记录\n* [黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难](https://www.bilibili.com/video/av41559729/?p=1&vd_source=f30eba35d0a8915376778596dfd73224)\n* [黑马视频配套资料](https://github.com/Blitzer207/C-Resource)\n\n![image-20240509175137661](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/cppheima.png)\n\n## 基础语法入门\n* 学习笔记：[C++基础入门](https://www.montylee.cn/2024/05/13/CPP基础/)\n### CMake\n\n学习文章：[CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置](https://juejin.cn/post/6844904015587704839) \n\n## 核心编程\n\n* [内存分区模型](https://juejin.cn/post/7112082561752383496)\n\n## 提高编程\n\n\n\n\n# 引用\n\n* [这才是你最想要的 C++ 学习路线](https://www.zhihu.com/tardis/zm/art/435927070?source_id=1003)\n* [C++那些事](https://github.com/Light-City/CPlusPlusThings?tab=readme-ov-file#c-那些事)\n* [CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置](https://juejin.cn/post/6844904015587704839)\n\n","source":"_posts/CppLearn.md","raw":"---\n# 基本信息\ntitle: C++ 学习\ndate: 2024/05/09\ntags: [cpp, 计算机]\ncategories: [cpp]\ndescription: C++ 学习记录\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/wallhaven-1ppld1.jpg\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/wallhaven-1ppld1.jpg\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  C++ 学习 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n\n~~（注：本内容仅供个人学习使用，请点击链接阅读原文）~~\n\n# 时间线\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 13 日 -->\n\n完成第一阶段的案例：通讯录管理系统，\n\n主要学习应用 C++ 的基础语法、指针、结构体等知识。\n\n<!-- node 2024 年 5 月 12 日 -->\n\n面试通过，小声吐槽：实习待遇极差……\n\n这几天将 C++ 基础语法过了一遍。\n\n<!-- node 2024 年 5 月 9 日 -->\n\n中海达面试结束，面试官说实习过程中主要是用 CPP 进行开发，于是决定利用这几天补习相关知识。\n\n{% endtimeline %}\n\n# 问题记录\n\n- [ ] 【20240531】对指针相关概念和操作不熟悉\n- [ ] 【20240601】this 指针\n\n# 学习记录\n* [黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难](https://www.bilibili.com/video/av41559729/?p=1&vd_source=f30eba35d0a8915376778596dfd73224)\n* [黑马视频配套资料](https://github.com/Blitzer207/C-Resource)\n\n![image-20240509175137661](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/cppheima.png)\n\n## 基础语法入门\n* 学习笔记：[C++基础入门](https://www.montylee.cn/2024/05/13/CPP基础/)\n### CMake\n\n学习文章：[CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置](https://juejin.cn/post/6844904015587704839) \n\n## 核心编程\n\n* [内存分区模型](https://juejin.cn/post/7112082561752383496)\n\n## 提高编程\n\n\n\n\n# 引用\n\n* [这才是你最想要的 C++ 学习路线](https://www.zhihu.com/tardis/zm/art/435927070?source_id=1003)\n* [C++那些事](https://github.com/Light-City/CPlusPlusThings?tab=readme-ov-file#c-那些事)\n* [CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置](https://juejin.cn/post/6844904015587704839)\n\n","slug":"CppLearn","published":1,"updated":"2024-06-07T04:07:15.146Z","layout":"post","photos":[],"_id":"clx8i4fa40008qt3acmj87rfq","content":"<p><del>（注：本内容仅供个人学习使用，请点击链接阅读原文）</del></p>\n<h1 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 13 日</div><div class=\"body fs14\"><p>完成第一阶段的案例：通讯录管理系统，</p><p>主要学习应用 C++ 的基础语法、指针、结构体等知识。</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 12 日</div><div class=\"body fs14\"><p>面试通过，小声吐槽：实习待遇极差……</p><p>这几天将 C++ 基础语法过了一遍。</p></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 9 日</div><div class=\"body fs14\"><p>中海达面试结束，面试官说实习过程中主要是用 CPP 进行开发，于是决定利用这几天补习相关知识。</p></div></div></div>\n\n<h1 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 【20240531】对指针相关概念和操作不熟悉</li>\n<li><input disabled=\"\" type=\"checkbox\"> 【20240601】this 指针</li>\n</ul>\n<h1 id=\"学习记录\"><a href=\"#学习记录\" class=\"headerlink\" title=\"学习记录\"></a>学习记录</h1><ul>\n<li><a href=\"https://www.bilibili.com/video/av41559729/?p=1&vd_source=f30eba35d0a8915376778596dfd73224\">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></li>\n<li><a href=\"https://github.com/Blitzer207/C-Resource\">黑马视频配套资料</a></li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/cppheima.png\" alt=\"image-20240509175137661\"></p>\n<h2 id=\"基础语法入门\"><a href=\"#基础语法入门\" class=\"headerlink\" title=\"基础语法入门\"></a>基础语法入门</h2><ul>\n<li>学习笔记：<a href=\"https://www.montylee.cn/2024/05/13/CPP%E5%9F%BA%E7%A1%80/\">C++基础入门</a></li>\n</ul>\n<h3 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h3><p>学习文章：<a href=\"https://juejin.cn/post/6844904015587704839\">CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置</a> </p>\n<h2 id=\"核心编程\"><a href=\"#核心编程\" class=\"headerlink\" title=\"核心编程\"></a>核心编程</h2><ul>\n<li><a href=\"https://juejin.cn/post/7112082561752383496\">内存分区模型</a></li>\n</ul>\n<h2 id=\"提高编程\"><a href=\"#提高编程\" class=\"headerlink\" title=\"提高编程\"></a>提高编程</h2><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ul>\n<li><a href=\"https://www.zhihu.com/tardis/zm/art/435927070?source_id=1003\">这才是你最想要的 C++ 学习路线</a></li>\n<li><a href=\"https://github.com/Light-City/CPlusPlusThings?tab=readme-ov-file#c-%E9%82%A3%E4%BA%9B%E4%BA%8B\">C++那些事</a></li>\n<li><a href=\"https://juejin.cn/post/6844904015587704839\">CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置</a></li>\n</ul>\n","excerpt":"","more":"<p><del>（注：本内容仅供个人学习使用，请点击链接阅读原文）</del></p>\n<h1 id=\"时间线\"><a href=\"#时间线\" class=\"headerlink\" title=\"时间线\"></a>时间线</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 13 日</div><div class=\"body fs14\"><p>完成第一阶段的案例：通讯录管理系统，</p><p>主要学习应用 C++ 的基础语法、指针、结构体等知识。</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 12 日</div><div class=\"body fs14\"><p>面试通过，小声吐槽：实习待遇极差……</p><p>这几天将 C++ 基础语法过了一遍。</p></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 9 日</div><div class=\"body fs14\"><p>中海达面试结束，面试官说实习过程中主要是用 CPP 进行开发，于是决定利用这几天补习相关知识。</p></div></div></div>\n\n<h1 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h1><ul>\n<li><input disabled=\"\" type=\"checkbox\"> 【20240531】对指针相关概念和操作不熟悉</li>\n<li><input disabled=\"\" type=\"checkbox\"> 【20240601】this 指针</li>\n</ul>\n<h1 id=\"学习记录\"><a href=\"#学习记录\" class=\"headerlink\" title=\"学习记录\"></a>学习记录</h1><ul>\n<li><a href=\"https://www.bilibili.com/video/av41559729/?p=1&vd_source=f30eba35d0a8915376778596dfd73224\">黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难</a></li>\n<li><a href=\"https://github.com/Blitzer207/C-Resource\">黑马视频配套资料</a></li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/cppheima.png\" alt=\"image-20240509175137661\"></p>\n<h2 id=\"基础语法入门\"><a href=\"#基础语法入门\" class=\"headerlink\" title=\"基础语法入门\"></a>基础语法入门</h2><ul>\n<li>学习笔记：<a href=\"https://www.montylee.cn/2024/05/13/CPP%E5%9F%BA%E7%A1%80/\">C++基础入门</a></li>\n</ul>\n<h3 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h3><p>学习文章：<a href=\"https://juejin.cn/post/6844904015587704839\">CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置</a> </p>\n<h2 id=\"核心编程\"><a href=\"#核心编程\" class=\"headerlink\" title=\"核心编程\"></a>核心编程</h2><ul>\n<li><a href=\"https://juejin.cn/post/7112082561752383496\">内存分区模型</a></li>\n</ul>\n<h2 id=\"提高编程\"><a href=\"#提高编程\" class=\"headerlink\" title=\"提高编程\"></a>提高编程</h2><h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h1><ul>\n<li><a href=\"https://www.zhihu.com/tardis/zm/art/435927070?source_id=1003\">这才是你最想要的 C++ 学习路线</a></li>\n<li><a href=\"https://github.com/Light-City/CPlusPlusThings?tab=readme-ov-file#c-%E9%82%A3%E4%BA%9B%E4%BA%8B\">C++那些事</a></li>\n<li><a href=\"https://juejin.cn/post/6844904015587704839\">CMake学习笔记（一）基本概念介绍、入门教程及CLion安装配置</a></li>\n</ul>\n"},{"title":"哈希表part01","date":"2024-06-05T16:00:00.000Z","description":"哈希表part01","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/nezuko-kamado-kimetsu-no-yaiba-hd-wallpaper-x-preview-27.jpg","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/nezuko-kamado-kimetsu-no-yaiba-hd-wallpaper-x-preview-27.jpg","poster":{"topic":null,"headline":"哈希表part01","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n# 哈希表理论基础\n\n哈希表是根据关键码的值而直接进行访问的数据结构。**用来快速判断一个元素是否出现集合里**\n\n![哈希表1](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104234805168.png)\n\n例如要查询一个名字是否在这所学校里。\n\n要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\n\n我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。\n\n将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。\n\n## 哈希函数\n\n![哈希表2](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423484818.png)\n\n\n\n## 哈希碰撞\n\n如图，小李和小王都映射到索引下标为1的位置，这一现象称为**哈希碰撞**。\n\n![哈希表3](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423494884.png)\n\n### 解决方法\n\n1. 拉链法\n\n   * 刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了\n\n   ![哈希表4](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235015226.png)\n\n2. 线性探测法\n\n   * 使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。\n\n     例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示\n\n   ![哈希表5](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235109950.png)\n\n","source":"_posts/哈希表part01.md","raw":"---\n# 基本信息\ntitle: 哈希表part01\ndate: 2024/06/06\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 哈希表part01\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/nezuko-kamado-kimetsu-no-yaiba-hd-wallpaper-x-preview-27.jpg\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/nezuko-kamado-kimetsu-no-yaiba-hd-wallpaper-x-preview-27.jpg\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  哈希表part01 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n# 哈希表理论基础\n\n哈希表是根据关键码的值而直接进行访问的数据结构。**用来快速判断一个元素是否出现集合里**\n\n![哈希表1](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104234805168.png)\n\n例如要查询一个名字是否在这所学校里。\n\n要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。\n\n我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。\n\n将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。\n\n## 哈希函数\n\n![哈希表2](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423484818.png)\n\n\n\n## 哈希碰撞\n\n如图，小李和小王都映射到索引下标为1的位置，这一现象称为**哈希碰撞**。\n\n![哈希表3](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423494884.png)\n\n### 解决方法\n\n1. 拉链法\n\n   * 刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了\n\n   ![哈希表4](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235015226.png)\n\n2. 线性探测法\n\n   * 使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。\n\n     例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示\n\n   ![哈希表5](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235109950.png)\n\n","slug":"哈希表part01","published":1,"updated":"2024-06-07T03:04:07.016Z","layout":"post","photos":[],"_id":"clx8i4fa5000bqt3a3kolhmav","content":"<h1 id=\"哈希表理论基础\"><a href=\"#哈希表理论基础\" class=\"headerlink\" title=\"哈希表理论基础\"></a>哈希表理论基础</h1><p>哈希表是根据关键码的值而直接进行访问的数据结构。<strong>用来快速判断一个元素是否出现集合里</strong></p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104234805168.png\" alt=\"哈希表1\"></p>\n<p>例如要查询一个名字是否在这所学校里。</p>\n<p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p>\n<p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p>\n<p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p>\n<h2 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423484818.png\" alt=\"哈希表2\"></p>\n<h2 id=\"哈希碰撞\"><a href=\"#哈希碰撞\" class=\"headerlink\" title=\"哈希碰撞\"></a>哈希碰撞</h2><p>如图，小李和小王都映射到索引下标为1的位置，这一现象称为<strong>哈希碰撞</strong>。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423494884.png\" alt=\"哈希表3\"></p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li><p>拉链法</p>\n<ul>\n<li>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235015226.png\" alt=\"哈希表4\"></p>\n</li>\n<li><p>线性探测法</p>\n<ul>\n<li><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p>\n<p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示</p>\n</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235109950.png\" alt=\"哈希表5\"></p>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"哈希表理论基础\"><a href=\"#哈希表理论基础\" class=\"headerlink\" title=\"哈希表理论基础\"></a>哈希表理论基础</h1><p>哈希表是根据关键码的值而直接进行访问的数据结构。<strong>用来快速判断一个元素是否出现集合里</strong></p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104234805168.png\" alt=\"哈希表1\"></p>\n<p>例如要查询一个名字是否在这所学校里。</p>\n<p>要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。</p>\n<p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p>\n<p>将学生姓名映射到哈希表上就涉及到了<strong>hash function ，也就是哈希函数</strong>。</p>\n<h2 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423484818.png\" alt=\"哈希表2\"></p>\n<h2 id=\"哈希碰撞\"><a href=\"#哈希碰撞\" class=\"headerlink\" title=\"哈希碰撞\"></a>哈希碰撞</h2><p>如图，小李和小王都映射到索引下标为1的位置，这一现象称为<strong>哈希碰撞</strong>。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/2021010423494884.png\" alt=\"哈希表3\"></p>\n<h3 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h3><ol>\n<li><p>拉链法</p>\n<ul>\n<li>刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235015226.png\" alt=\"哈希表4\"></p>\n</li>\n<li><p>线性探测法</p>\n<ul>\n<li><p>使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。</p>\n<p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示</p>\n</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210104235109950.png\" alt=\"哈希表5\"></p>\n</li>\n</ol>\n"},{"title":"数组part02","date":"2024-05-27T16:00:00.000Z","description":"代数组part02","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211518_nNfZE.gif","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211518_nNfZE.gif","poster":{"topic":null,"headline":"数组part02","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n\n# 977. 有序数组平方【简单】\n\n[LeetCode 官方题解](https://leetcode.cn/problems/squares-of-a-sorted-array/solutions/447736/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/)\n\n## 暴力排序\n\n思路：先平方，再排序\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        for(int i = 0; i < nums.size(); i++) {\n            nums[i] *= nums[i];\n        }\n        sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n```\n\n\n\n[【C++】sort函数使用方法](https://zhuanlan.zhihu.com/p/309291783) : sort 函数是快排的改良版，结合了堆排序等排序方法。\n\n## 双指针\n\n* 思路\n  * 个人理解：\n    * 定义两个指针：**队首指针、队尾指针**\n    * 定义一个与原数组**相同大小**的空数组\n    * 队首指针遍历，同时与队尾指针比较平方后大小，大的那一个放到空数组的队尾\n      * 放到队尾这里也需要定义一个指针用于记录位置信息，如下面代码的 right_result ~~（所以为啥不叫三指针法）~~\n    * 指针重合即停止 (这个判断条件有误，应该是 left <= right，否则会进入死循环)\n\n```cpp\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        int right_result = right;\n        vector<int> result(nums.size(), 0);\n        \n        while (left <= right) {\n            int left_square = nums[left] * nums[left];\n            int right_square = nums[right] * nums[right];\n            \n            if (left_square > right_square) {\n                result[right_result] = left_square;\n                left++;\n            } else {\n                result[right_result] = right_square;\n                right--;\n            }\n            right_result--;\n        }\n        return result;\n    }\n};\n\n```\n\n### [C++ vector容器简析](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)\n\n```cpp\nvector<int> result(nums.size(), 0);\n```\n\n上述代码：创建并初始化了一个名为 result 的 vector<int> 类型的对象，vector<int> 是一个构造函数，可以接受两个参数：\n\n* size：表示vector的大小\n* value：表示vector中每个元素的初始大小\n\n下面详细解释上述代码的含义：\n\n* vector<int>：`vector<int>` 是 C++ 标准库中的一个模板类，用于表示一个动态数组。`vector` 是一个模板类，`<int>` 表示这个 `vector` 将存储 `int` 类型的元素。\n* result：`result` 是这个 `vector<int>` 对象的名称。它是一个变量名，表示我们将使用这个名称来引用这个 `vector` 对象\n* nums.size()：`nums` 是一个 `vector<int>` 类型的对象。`nums.size()` 返回 `nums` 中元素的个数，即 `nums` 的大小。这个大小是一个无符号整数类型（通常是 `size_t`）。\n\n\n\n# 209. 长度最小的子数组【中等】\n\n[代码随想录](https://programmercarl.com/0209.长度最小的子数组.html#算法公开课)\n\n## 个人思路（暴力解）\n\n我的思路应该就是暴力解……\n\n1. 定义外循环用于遍历整个数组\n2. 内循环用于把 i 与后面的元素想加，直到出现 >= target的情况，或者遍历完\n3. 定义一个 int 类型变量 result = 0，用于记录最小连续子数组的长度\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int result = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int sum = 0;\n            for (int j = i; j < nums.size(); j++) {\n                sum += nums[j];\n                if (sum == target) { // 判断条件有误\n                    result = j - i + 1;\n                    continue; // 这里应该修改为 break\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n\n\n\n很遗憾，我的代码错了，GPT给出的问题如下：\n\n1. **条件判断错误**：你在内部循环中检查 `sum == target`，但题目要求的是总和大于等于 `target`。\n2. **结果更新错误**：你没有正确更新 `result`。你需要在找到满足条件的子数组时更新 `result`，并且应该保留最小的长度。\n3. **效率问题**：你的算法是一个 O(n2)*O*(*n*2) 的暴力解法，对于较大的输入数组会导致超时。\n\n修改后的代码如下，\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int result = INT_MAX; // 用于存储最小长度，初始值设为一个很大的数\n        for (int i = 0; i < nums.size(); i++) {\n            int sum = 0;\n            for (int j = i; j < nums.size(); j++) {\n                sum += nums[j];\n                if (sum >= target) {\n                    result = min(result, j - i + 1);\n                    break; // 找到一个符合条件的子数组，跳出内层循环\n                }\n            }\n        }\n        return result == INT_MAX ? 0 : result; // 如果result没有被更新过，返回0\n    }\n};\n\n```\n\n**修改说明：**\n\n1. **条件判断修正**：\n   - 将 `if (sum == target)` 修改为 `if (sum >= target)`，以满足题目要求。\n2. **更新结果**：\n   - 在找到符合条件的子数组时，使用 `result = min(result, j - i + 1)` 来更新最小长度。\n3. **跳出内层循环**：\n   - 一旦找到一个符合条件的子数组，立即跳出内层循环，因为在当前起点 `i` 继续寻找更长的子数组是没有意义的。\n4. **返回结果**：\n   - 如果 `result` 没有被更新，说明没有找到符合条件的子数组，返回 0。\n   - 否则返回 `result`。\n\n> 思路应该是没什么问题了，很不幸，超时了，leetcode给了一个超级离谱的测试样例。\n\n### 三元运算符\n\n```cpp\ncondition ? value_if_true : value_if_false\n```\n\n- **condition**：这是一个布尔表达式，计算结果要么是 `true`，要么是 `false`。\n- **value_if_true**：如果 `condition` 为 `true`，则返回这个值。\n- **value_if_false**：如果 `condition` 为 `false`，则返回这个值。\n\n\n\n## 滑动窗口\n\n![209.长度最小的子数组](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)\n\n所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\n\n在本题中实现滑动窗口，主要确定如下三点：\n\n- 窗口内是什么？\n\n  - 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n\n- 如何移动窗口的起始位置？\n\n  - 窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。\n\n    ![leetcode_209](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210312160441942.png)\n\n- 如何移动窗口的结束位置？\n\n  - 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int result = INT32_MAX;\n        int sum = 0; // 滑动窗口数值之和\n        int i = 0; // 滑动窗口起始位置\n        int subLength = 0; // 滑动窗口的长度\n        for (int j = 0; j < nums.size(); j++) {\n            sum += nums[j];\n            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while (sum >= s) {\n                subLength = (j - i + 1); // 取子序列的长度\n                result = result < subLength ? result : subLength;\n                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            }\n        }\n        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result == INT32_MAX ? 0 : result;\n    }\n};\n```\n\n\n\n# 59. 螺旋矩阵II【中等】\n\n[视频讲解](https://www.bilibili.com/video/BV1SL4y1N7mV/?vd_source=f30eba35d0a8915376778596dfd73224)\n\n这题……毫无思路，可见我对多维矩阵的理解极弱。\n\n题解也看不懂，感觉就是硬套啊，这就是**模拟**的精髓吗？\n\n据说这还是**高频考题**？看来得背下来了。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组\n        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置\n        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理\n        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)\n        int count = 1; // 用来给矩阵中每一个空格赋值\n        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位\n        int i,j;\n        while (loop --) {\n            i = startx;\n            j = starty;\n\n            // 下面开始的四个for就是模拟转了一圈\n            // 模拟填充上行从左到右(左闭右开)\n            for (j; j < n - offset; j++) {\n                res[i][j] = count++;\n            }\n            // 模拟填充右列从上到下(左闭右开)\n            for (i; i < n - offset; i++) {\n                res[i][j] = count++;\n            }\n            // 模拟填充下行从右到左(左闭右开)\n            for (; j > starty; j--) {\n                res[i][j] = count++;\n            }\n            // 模拟填充左列从下到上(左闭右开)\n            for (; i > startx; i--) {\n                res[i][j] = count++;\n            }\n\n            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\n            startx++;\n            starty++;\n\n            // offset 控制每一圈里每一条边遍历的长度\n            offset += 1;\n        }\n\n        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\n        if (n % 2) {\n            res[mid][mid] = count;\n        }\n        return res;\n    }\n};\n```\n\n","source":"_posts/数组part02.md","raw":"---\n# 基本信息\ntitle: 数组part02\ndate: 2024/05/28\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 代数组part02\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211518_nNfZE.gif\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20200317211518_nNfZE.gif\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  数组part02 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n\n\n# 977. 有序数组平方【简单】\n\n[LeetCode 官方题解](https://leetcode.cn/problems/squares-of-a-sorted-array/solutions/447736/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/)\n\n## 暴力排序\n\n思路：先平方，再排序\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        for(int i = 0; i < nums.size(); i++) {\n            nums[i] *= nums[i];\n        }\n        sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n```\n\n\n\n[【C++】sort函数使用方法](https://zhuanlan.zhihu.com/p/309291783) : sort 函数是快排的改良版，结合了堆排序等排序方法。\n\n## 双指针\n\n* 思路\n  * 个人理解：\n    * 定义两个指针：**队首指针、队尾指针**\n    * 定义一个与原数组**相同大小**的空数组\n    * 队首指针遍历，同时与队尾指针比较平方后大小，大的那一个放到空数组的队尾\n      * 放到队尾这里也需要定义一个指针用于记录位置信息，如下面代码的 right_result ~~（所以为啥不叫三指针法）~~\n    * 指针重合即停止 (这个判断条件有误，应该是 left <= right，否则会进入死循环)\n\n```cpp\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        int right_result = right;\n        vector<int> result(nums.size(), 0);\n        \n        while (left <= right) {\n            int left_square = nums[left] * nums[left];\n            int right_square = nums[right] * nums[right];\n            \n            if (left_square > right_square) {\n                result[right_result] = left_square;\n                left++;\n            } else {\n                result[right_result] = right_square;\n                right--;\n            }\n            right_result--;\n        }\n        return result;\n    }\n};\n\n```\n\n### [C++ vector容器简析](https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html)\n\n```cpp\nvector<int> result(nums.size(), 0);\n```\n\n上述代码：创建并初始化了一个名为 result 的 vector<int> 类型的对象，vector<int> 是一个构造函数，可以接受两个参数：\n\n* size：表示vector的大小\n* value：表示vector中每个元素的初始大小\n\n下面详细解释上述代码的含义：\n\n* vector<int>：`vector<int>` 是 C++ 标准库中的一个模板类，用于表示一个动态数组。`vector` 是一个模板类，`<int>` 表示这个 `vector` 将存储 `int` 类型的元素。\n* result：`result` 是这个 `vector<int>` 对象的名称。它是一个变量名，表示我们将使用这个名称来引用这个 `vector` 对象\n* nums.size()：`nums` 是一个 `vector<int>` 类型的对象。`nums.size()` 返回 `nums` 中元素的个数，即 `nums` 的大小。这个大小是一个无符号整数类型（通常是 `size_t`）。\n\n\n\n# 209. 长度最小的子数组【中等】\n\n[代码随想录](https://programmercarl.com/0209.长度最小的子数组.html#算法公开课)\n\n## 个人思路（暴力解）\n\n我的思路应该就是暴力解……\n\n1. 定义外循环用于遍历整个数组\n2. 内循环用于把 i 与后面的元素想加，直到出现 >= target的情况，或者遍历完\n3. 定义一个 int 类型变量 result = 0，用于记录最小连续子数组的长度\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int result = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int sum = 0;\n            for (int j = i; j < nums.size(); j++) {\n                sum += nums[j];\n                if (sum == target) { // 判断条件有误\n                    result = j - i + 1;\n                    continue; // 这里应该修改为 break\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n\n\n\n很遗憾，我的代码错了，GPT给出的问题如下：\n\n1. **条件判断错误**：你在内部循环中检查 `sum == target`，但题目要求的是总和大于等于 `target`。\n2. **结果更新错误**：你没有正确更新 `result`。你需要在找到满足条件的子数组时更新 `result`，并且应该保留最小的长度。\n3. **效率问题**：你的算法是一个 O(n2)*O*(*n*2) 的暴力解法，对于较大的输入数组会导致超时。\n\n修改后的代码如下，\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int result = INT_MAX; // 用于存储最小长度，初始值设为一个很大的数\n        for (int i = 0; i < nums.size(); i++) {\n            int sum = 0;\n            for (int j = i; j < nums.size(); j++) {\n                sum += nums[j];\n                if (sum >= target) {\n                    result = min(result, j - i + 1);\n                    break; // 找到一个符合条件的子数组，跳出内层循环\n                }\n            }\n        }\n        return result == INT_MAX ? 0 : result; // 如果result没有被更新过，返回0\n    }\n};\n\n```\n\n**修改说明：**\n\n1. **条件判断修正**：\n   - 将 `if (sum == target)` 修改为 `if (sum >= target)`，以满足题目要求。\n2. **更新结果**：\n   - 在找到符合条件的子数组时，使用 `result = min(result, j - i + 1)` 来更新最小长度。\n3. **跳出内层循环**：\n   - 一旦找到一个符合条件的子数组，立即跳出内层循环，因为在当前起点 `i` 继续寻找更长的子数组是没有意义的。\n4. **返回结果**：\n   - 如果 `result` 没有被更新，说明没有找到符合条件的子数组，返回 0。\n   - 否则返回 `result`。\n\n> 思路应该是没什么问题了，很不幸，超时了，leetcode给了一个超级离谱的测试样例。\n\n### 三元运算符\n\n```cpp\ncondition ? value_if_true : value_if_false\n```\n\n- **condition**：这是一个布尔表达式，计算结果要么是 `true`，要么是 `false`。\n- **value_if_true**：如果 `condition` 为 `true`，则返回这个值。\n- **value_if_false**：如果 `condition` 为 `false`，则返回这个值。\n\n\n\n## 滑动窗口\n\n![209.长度最小的子数组](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)\n\n所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。\n\n在本题中实现滑动窗口，主要确定如下三点：\n\n- 窗口内是什么？\n\n  - 窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。\n\n- 如何移动窗口的起始位置？\n\n  - 窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。\n\n    ![leetcode_209](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210312160441942.png)\n\n- 如何移动窗口的结束位置？\n\n  - 窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。\n\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int s, vector<int>& nums) {\n        int result = INT32_MAX;\n        int sum = 0; // 滑动窗口数值之和\n        int i = 0; // 滑动窗口起始位置\n        int subLength = 0; // 滑动窗口的长度\n        for (int j = 0; j < nums.size(); j++) {\n            sum += nums[j];\n            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while (sum >= s) {\n                subLength = (j - i + 1); // 取子序列的长度\n                result = result < subLength ? result : subLength;\n                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）\n            }\n        }\n        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result == INT32_MAX ? 0 : result;\n    }\n};\n```\n\n\n\n# 59. 螺旋矩阵II【中等】\n\n[视频讲解](https://www.bilibili.com/video/BV1SL4y1N7mV/?vd_source=f30eba35d0a8915376778596dfd73224)\n\n这题……毫无思路，可见我对多维矩阵的理解极弱。\n\n题解也看不懂，感觉就是硬套啊，这就是**模拟**的精髓吗？\n\n据说这还是**高频考题**？看来得背下来了。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组\n        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置\n        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理\n        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)\n        int count = 1; // 用来给矩阵中每一个空格赋值\n        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位\n        int i,j;\n        while (loop --) {\n            i = startx;\n            j = starty;\n\n            // 下面开始的四个for就是模拟转了一圈\n            // 模拟填充上行从左到右(左闭右开)\n            for (j; j < n - offset; j++) {\n                res[i][j] = count++;\n            }\n            // 模拟填充右列从上到下(左闭右开)\n            for (i; i < n - offset; i++) {\n                res[i][j] = count++;\n            }\n            // 模拟填充下行从右到左(左闭右开)\n            for (; j > starty; j--) {\n                res[i][j] = count++;\n            }\n            // 模拟填充左列从下到上(左闭右开)\n            for (; i > startx; i--) {\n                res[i][j] = count++;\n            }\n\n            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)\n            startx++;\n            starty++;\n\n            // offset 控制每一圈里每一条边遍历的长度\n            offset += 1;\n        }\n\n        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值\n        if (n % 2) {\n            res[mid][mid] = count;\n        }\n        return res;\n    }\n};\n```\n\n","slug":"数组part02","published":1,"updated":"2024-06-07T03:04:55.635Z","layout":"post","photos":[],"_id":"clx8i4fa5000cqt3a8d95h4zu","content":"<h1 id=\"977-有序数组平方【简单】\"><a href=\"#977-有序数组平方【简单】\" class=\"headerlink\" title=\"977. 有序数组平方【简单】\"></a>977. 有序数组平方【简单】</h1><p><a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/solutions/447736/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/\">LeetCode 官方题解</a></p>\n<h2 id=\"暴力排序\"><a href=\"#暴力排序\" class=\"headerlink\" title=\"暴力排序\"></a>暴力排序</h2><p>思路：先平方，再排序</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sortedSquares</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            nums[i] *= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/309291783\">【C++】sort函数使用方法</a> : sort 函数是快排的改良版，结合了堆排序等排序方法。</p>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><ul>\n<li>思路<ul>\n<li>个人理解：<ul>\n<li>定义两个指针：<strong>队首指针、队尾指针</strong></li>\n<li>定义一个与原数组<strong>相同大小</strong>的空数组</li>\n<li>队首指针遍历，同时与队尾指针比较平方后大小，大的那一个放到空数组的队尾<ul>\n<li>放到队尾这里也需要定义一个指针用于记录位置信息，如下面代码的 right_result <del>（所以为啥不叫三指针法）</del></li>\n</ul>\n</li>\n<li>指针重合即停止 (这个判断条件有误，应该是 left &lt;&#x3D; right，否则会进入死循环)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sortedSquares</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right_result = right;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> left_square = nums[left] * nums[left];</span><br><span class=\"line\">            <span class=\"type\">int</span> right_square = nums[right] * nums[right];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left_square &gt; right_square) &#123;</span><br><span class=\"line\">                result[right_result] = left_square;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result[right_result] = right_square;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right_result--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-vector容器简析\"><a href=\"#C-vector容器简析\" class=\"headerlink\" title=\"C++ vector容器简析\"></a><a href=\"https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html\">C++ vector容器简析</a></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码：创建并初始化了一个名为 result 的 vector<int> 类型的对象，vector<int> 是一个构造函数，可以接受两个参数：</p>\n<ul>\n<li>size：表示vector的大小</li>\n<li>value：表示vector中每个元素的初始大小</li>\n</ul>\n<p>下面详细解释上述代码的含义：</p>\n<ul>\n<li>vector<int>：<code>vector&lt;int&gt;</code> 是 C++ 标准库中的一个模板类，用于表示一个动态数组。<code>vector</code> 是一个模板类，<code>&lt;int&gt;</code> 表示这个 <code>vector</code> 将存储 <code>int</code> 类型的元素。</li>\n<li>result：<code>result</code> 是这个 <code>vector&lt;int&gt;</code> 对象的名称。它是一个变量名，表示我们将使用这个名称来引用这个 <code>vector</code> 对象</li>\n<li>nums.size()：<code>nums</code> 是一个 <code>vector&lt;int&gt;</code> 类型的对象。<code>nums.size()</code> 返回 <code>nums</code> 中元素的个数，即 <code>nums</code> 的大小。这个大小是一个无符号整数类型（通常是 <code>size_t</code>）。</li>\n</ul>\n<h1 id=\"209-长度最小的子数组【中等】\"><a href=\"#209-长度最小的子数组【中等】\" class=\"headerlink\" title=\"209. 长度最小的子数组【中等】\"></a>209. 长度最小的子数组【中等】</h1><p><a href=\"https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录</a></p>\n<h2 id=\"个人思路（暴力解）\"><a href=\"#个人思路（暴力解）\" class=\"headerlink\" title=\"个人思路（暴力解）\"></a>个人思路（暴力解）</h2><p>我的思路应该就是暴力解……</p>\n<ol>\n<li>定义外循环用于遍历整个数组</li>\n<li>内循环用于把 i 与后面的元素想加，直到出现 &gt;&#x3D; target的情况，或者遍历完</li>\n<li>定义一个 int 类型变量 result &#x3D; 0，用于记录最小连续子数组的长度</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                sum += nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum == target) &#123; <span class=\"comment\">// 判断条件有误</span></span><br><span class=\"line\">                    result = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>; <span class=\"comment\">// 这里应该修改为 break</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>很遗憾，我的代码错了，GPT给出的问题如下：</p>\n<ol>\n<li><strong>条件判断错误</strong>：你在内部循环中检查 <code>sum == target</code>，但题目要求的是总和大于等于 <code>target</code>。</li>\n<li><strong>结果更新错误</strong>：你没有正确更新 <code>result</code>。你需要在找到满足条件的子数组时更新 <code>result</code>，并且应该保留最小的长度。</li>\n<li><strong>效率问题</strong>：你的算法是一个 O(n2)<em>O</em>(<em>n</em>2) 的暴力解法，对于较大的输入数组会导致超时。</li>\n</ol>\n<p>修改后的代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = INT_MAX; <span class=\"comment\">// 用于存储最小长度，初始值设为一个很大的数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                sum += nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum &gt;= target) &#123;</span><br><span class=\"line\">                    result = <span class=\"built_in\">min</span>(result, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>; <span class=\"comment\">// 找到一个符合条件的子数组，跳出内层循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT_MAX ? <span class=\"number\">0</span> : result; <span class=\"comment\">// 如果result没有被更新过，返回0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>修改说明：</strong></p>\n<ol>\n<li><strong>条件判断修正</strong>：<ul>\n<li>将 <code>if (sum == target)</code> 修改为 <code>if (sum &gt;= target)</code>，以满足题目要求。</li>\n</ul>\n</li>\n<li><strong>更新结果</strong>：<ul>\n<li>在找到符合条件的子数组时，使用 <code>result = min(result, j - i + 1)</code> 来更新最小长度。</li>\n</ul>\n</li>\n<li><strong>跳出内层循环</strong>：<ul>\n<li>一旦找到一个符合条件的子数组，立即跳出内层循环，因为在当前起点 <code>i</code> 继续寻找更长的子数组是没有意义的。</li>\n</ul>\n</li>\n<li><strong>返回结果</strong>：<ul>\n<li>如果 <code>result</code> 没有被更新，说明没有找到符合条件的子数组，返回 0。</li>\n<li>否则返回 <code>result</code>。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>思路应该是没什么问题了，很不幸，超时了，leetcode给了一个超级离谱的测试样例。</p>\n</blockquote>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition ? value_if_true : value_if_false</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>condition</strong>：这是一个布尔表达式，计算结果要么是 <code>true</code>，要么是 <code>false</code>。</li>\n<li><strong>value_if_true</strong>：如果 <code>condition</code> 为 <code>true</code>，则返回这个值。</li>\n<li><strong>value_if_false</strong>：如果 <code>condition</code> 为 <code>false</code>，则返回这个值。</li>\n</ul>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif\" alt=\"209.长度最小的子数组\"></p>\n<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>\n<p>在本题中实现滑动窗口，主要确定如下三点：</p>\n<ul>\n<li><p>窗口内是什么？</p>\n<ul>\n<li>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li>\n</ul>\n</li>\n<li><p>如何移动窗口的起始位置？</p>\n<ul>\n<li><p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210312160441942.png\" alt=\"leetcode_209\"></p>\n</li>\n</ul>\n</li>\n<li><p>如何移动窗口的结束位置？</p>\n<ul>\n<li>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> s, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = INT32_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口数值之和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> subLength = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">            sum += nums[j];</span><br><span class=\"line\">            <span class=\"comment\">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= s) &#123;</span><br><span class=\"line\">                subLength = (j - i + <span class=\"number\">1</span>); <span class=\"comment\">// 取子序列的长度</span></span><br><span class=\"line\">                result = result &lt; subLength ? result : subLength;</span><br><span class=\"line\">                sum -= nums[i++]; <span class=\"comment\">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT32_MAX ? <span class=\"number\">0</span> : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"59-螺旋矩阵II【中等】\"><a href=\"#59-螺旋矩阵II【中等】\" class=\"headerlink\" title=\"59. 螺旋矩阵II【中等】\"></a>59. 螺旋矩阵II【中等】</h1><p><a href=\"https://www.bilibili.com/video/BV1SL4y1N7mV/?vd_source=f30eba35d0a8915376778596dfd73224\">视频讲解</a></p>\n<p>这题……毫无思路，可见我对多维矩阵的理解极弱。</p>\n<p>题解也看不懂，感觉就是硬套啊，这就是<strong>模拟</strong>的精髓吗？</p>\n<p>据说这还是<strong>高频考题</strong>？看来得背下来了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">generateMatrix</span>(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">res</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>)); <span class=\"comment\">// 使用vector定义一个二维数组</span></span><br><span class=\"line\">        <span class=\"type\">int</span> startx = <span class=\"number\">0</span>, starty = <span class=\"number\">0</span>; <span class=\"comment\">// 定义每循环一个圈的起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> loop = n / <span class=\"number\">2</span>; <span class=\"comment\">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mid = n / <span class=\"number\">2</span>; <span class=\"comment\">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">1</span>; <span class=\"comment\">// 用来给矩阵中每一个空格赋值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> offset = <span class=\"number\">1</span>; <span class=\"comment\">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop --) &#123;</span><br><span class=\"line\">            i = startx;</span><br><span class=\"line\">            j = starty;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j; j &lt; n - offset; j++) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i; i &lt; n - offset; i++) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt; starty; j--) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &gt; startx; i--) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class=\"line\">            startx++;</span><br><span class=\"line\">            starty++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class=\"line\">            offset += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            res[mid][mid] = count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"977-有序数组平方【简单】\"><a href=\"#977-有序数组平方【简单】\" class=\"headerlink\" title=\"977. 有序数组平方【简单】\"></a>977. 有序数组平方【简单】</h1><p><a href=\"https://leetcode.cn/problems/squares-of-a-sorted-array/solutions/447736/you-xu-shu-zu-de-ping-fang-by-leetcode-solution/\">LeetCode 官方题解</a></p>\n<h2 id=\"暴力排序\"><a href=\"#暴力排序\" class=\"headerlink\" title=\"暴力排序\"></a>暴力排序</h2><p>思路：先平方，再排序</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sortedSquares</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            nums[i] *= nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nums;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/309291783\">【C++】sort函数使用方法</a> : sort 函数是快排的改良版，结合了堆排序等排序方法。</p>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><ul>\n<li>思路<ul>\n<li>个人理解：<ul>\n<li>定义两个指针：<strong>队首指针、队尾指针</strong></li>\n<li>定义一个与原数组<strong>相同大小</strong>的空数组</li>\n<li>队首指针遍历，同时与队尾指针比较平方后大小，大的那一个放到空数组的队尾<ul>\n<li>放到队尾这里也需要定义一个指针用于记录位置信息，如下面代码的 right_result <del>（所以为啥不叫三指针法）</del></li>\n</ul>\n</li>\n<li>指针重合即停止 (这个判断条件有误，应该是 left &lt;&#x3D; right，否则会进入死循环)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sortedSquares</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right_result = right;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt;= right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> left_square = nums[left] * nums[left];</span><br><span class=\"line\">            <span class=\"type\">int</span> right_square = nums[right] * nums[right];</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left_square &gt; right_square) &#123;</span><br><span class=\"line\">                result[right_result] = left_square;</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result[right_result] = right_square;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            right_result--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-vector容器简析\"><a href=\"#C-vector容器简析\" class=\"headerlink\" title=\"C++ vector容器简析\"></a><a href=\"https://www.runoob.com/w3cnote/cpp-vector-container-analysis.html\">C++ vector容器简析</a></h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码：创建并初始化了一个名为 result 的 vector<int> 类型的对象，vector<int> 是一个构造函数，可以接受两个参数：</p>\n<ul>\n<li>size：表示vector的大小</li>\n<li>value：表示vector中每个元素的初始大小</li>\n</ul>\n<p>下面详细解释上述代码的含义：</p>\n<ul>\n<li>vector<int>：<code>vector&lt;int&gt;</code> 是 C++ 标准库中的一个模板类，用于表示一个动态数组。<code>vector</code> 是一个模板类，<code>&lt;int&gt;</code> 表示这个 <code>vector</code> 将存储 <code>int</code> 类型的元素。</li>\n<li>result：<code>result</code> 是这个 <code>vector&lt;int&gt;</code> 对象的名称。它是一个变量名，表示我们将使用这个名称来引用这个 <code>vector</code> 对象</li>\n<li>nums.size()：<code>nums</code> 是一个 <code>vector&lt;int&gt;</code> 类型的对象。<code>nums.size()</code> 返回 <code>nums</code> 中元素的个数，即 <code>nums</code> 的大小。这个大小是一个无符号整数类型（通常是 <code>size_t</code>）。</li>\n</ul>\n<h1 id=\"209-长度最小的子数组【中等】\"><a href=\"#209-长度最小的子数组【中等】\" class=\"headerlink\" title=\"209. 长度最小的子数组【中等】\"></a>209. 长度最小的子数组【中等】</h1><p><a href=\"https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE\">代码随想录</a></p>\n<h2 id=\"个人思路（暴力解）\"><a href=\"#个人思路（暴力解）\" class=\"headerlink\" title=\"个人思路（暴力解）\"></a>个人思路（暴力解）</h2><p>我的思路应该就是暴力解……</p>\n<ol>\n<li>定义外循环用于遍历整个数组</li>\n<li>内循环用于把 i 与后面的元素想加，直到出现 &gt;&#x3D; target的情况，或者遍历完</li>\n<li>定义一个 int 类型变量 result &#x3D; 0，用于记录最小连续子数组的长度</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                sum += nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum == target) &#123; <span class=\"comment\">// 判断条件有误</span></span><br><span class=\"line\">                    result = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>; <span class=\"comment\">// 这里应该修改为 break</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>很遗憾，我的代码错了，GPT给出的问题如下：</p>\n<ol>\n<li><strong>条件判断错误</strong>：你在内部循环中检查 <code>sum == target</code>，但题目要求的是总和大于等于 <code>target</code>。</li>\n<li><strong>结果更新错误</strong>：你没有正确更新 <code>result</code>。你需要在找到满足条件的子数组时更新 <code>result</code>，并且应该保留最小的长度。</li>\n<li><strong>效率问题</strong>：你的算法是一个 O(n2)<em>O</em>(<em>n</em>2) 的暴力解法，对于较大的输入数组会导致超时。</li>\n</ol>\n<p>修改后的代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = INT_MAX; <span class=\"comment\">// 用于存储最小长度，初始值设为一个很大的数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                sum += nums[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum &gt;= target) &#123;</span><br><span class=\"line\">                    result = <span class=\"built_in\">min</span>(result, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>; <span class=\"comment\">// 找到一个符合条件的子数组，跳出内层循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT_MAX ? <span class=\"number\">0</span> : result; <span class=\"comment\">// 如果result没有被更新过，返回0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>修改说明：</strong></p>\n<ol>\n<li><strong>条件判断修正</strong>：<ul>\n<li>将 <code>if (sum == target)</code> 修改为 <code>if (sum &gt;= target)</code>，以满足题目要求。</li>\n</ul>\n</li>\n<li><strong>更新结果</strong>：<ul>\n<li>在找到符合条件的子数组时，使用 <code>result = min(result, j - i + 1)</code> 来更新最小长度。</li>\n</ul>\n</li>\n<li><strong>跳出内层循环</strong>：<ul>\n<li>一旦找到一个符合条件的子数组，立即跳出内层循环，因为在当前起点 <code>i</code> 继续寻找更长的子数组是没有意义的。</li>\n</ul>\n</li>\n<li><strong>返回结果</strong>：<ul>\n<li>如果 <code>result</code> 没有被更新，说明没有找到符合条件的子数组，返回 0。</li>\n<li>否则返回 <code>result</code>。</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>思路应该是没什么问题了，很不幸，超时了，leetcode给了一个超级离谱的测试样例。</p>\n</blockquote>\n<h3 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">condition ? value_if_true : value_if_false</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>condition</strong>：这是一个布尔表达式，计算结果要么是 <code>true</code>，要么是 <code>false</code>。</li>\n<li><strong>value_if_true</strong>：如果 <code>condition</code> 为 <code>true</code>，则返回这个值。</li>\n<li><strong>value_if_false</strong>：如果 <code>condition</code> 为 <code>false</code>，则返回这个值。</li>\n</ul>\n<h2 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif\" alt=\"209.长度最小的子数组\"></p>\n<p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p>\n<p>在本题中实现滑动窗口，主要确定如下三点：</p>\n<ul>\n<li><p>窗口内是什么？</p>\n<ul>\n<li>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</li>\n</ul>\n</li>\n<li><p>如何移动窗口的起始位置？</p>\n<ul>\n<li><p>窗口的起始位置如何移动：如果当前窗口的值大于等于s了，窗口就要向前移动了（也就是该缩小了）。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210312160441942.png\" alt=\"leetcode_209\"></p>\n</li>\n</ul>\n</li>\n<li><p>如何移动窗口的结束位置？</p>\n<ul>\n<li>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> s, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = INT32_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口数值之和</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> subLength = <span class=\"number\">0</span>; <span class=\"comment\">// 滑动窗口的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">            sum += nums[j];</span><br><span class=\"line\">            <span class=\"comment\">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= s) &#123;</span><br><span class=\"line\">                subLength = (j - i + <span class=\"number\">1</span>); <span class=\"comment\">// 取子序列的长度</span></span><br><span class=\"line\">                result = result &lt; subLength ? result : subLength;</span><br><span class=\"line\">                sum -= nums[i++]; <span class=\"comment\">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT32_MAX ? <span class=\"number\">0</span> : result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"59-螺旋矩阵II【中等】\"><a href=\"#59-螺旋矩阵II【中等】\" class=\"headerlink\" title=\"59. 螺旋矩阵II【中等】\"></a>59. 螺旋矩阵II【中等】</h1><p><a href=\"https://www.bilibili.com/video/BV1SL4y1N7mV/?vd_source=f30eba35d0a8915376778596dfd73224\">视频讲解</a></p>\n<p>这题……毫无思路，可见我对多维矩阵的理解极弱。</p>\n<p>题解也看不懂，感觉就是硬套啊，这就是<strong>模拟</strong>的精髓吗？</p>\n<p>据说这还是<strong>高频考题</strong>？看来得背下来了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">generateMatrix</span>(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">res</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>)); <span class=\"comment\">// 使用vector定义一个二维数组</span></span><br><span class=\"line\">        <span class=\"type\">int</span> startx = <span class=\"number\">0</span>, starty = <span class=\"number\">0</span>; <span class=\"comment\">// 定义每循环一个圈的起始位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> loop = n / <span class=\"number\">2</span>; <span class=\"comment\">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mid = n / <span class=\"number\">2</span>; <span class=\"comment\">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">1</span>; <span class=\"comment\">// 用来给矩阵中每一个空格赋值</span></span><br><span class=\"line\">        <span class=\"type\">int</span> offset = <span class=\"number\">1</span>; <span class=\"comment\">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i,j;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop --) &#123;</span><br><span class=\"line\">            i = startx;</span><br><span class=\"line\">            j = starty;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j; j &lt; n - offset; j++) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i; i &lt; n - offset; i++) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; j &gt; starty; j--) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &gt; startx; i--) &#123;</span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class=\"line\">            startx++;</span><br><span class=\"line\">            starty++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class=\"line\">            offset += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            res[mid][mid] = count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"数组part01","date":"2024-05-27T16:00:00.000Z","description":"代数组part01","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/407EA04208948845D522AAA07D1BB3F1.png","banner":"hhttps://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/407EA04208948845D522AAA07D1BB3F1.png","poster":{"topic":null,"headline":"数组part01","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n\n\n# 数组理论基础\n\n1. 数组是存放在连续内存空间上的相同类型数据的集合。\n\n   ![image-20240522193029336](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193029336.png)\n\n* 数组下标都是从0开始的\n\n* 数组内存空间的地址是连续的（**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址**）\n\n2. 二维数组\n\n   ![image-20240522193547234](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193547234.png)\n\n   不同语言内存管理不同，C++中二维数组是连续分布的，Java 不是。\n\n# 704. 二分查找\n\n[代码随想录](https://programmercarl.com/0704.二分查找.html#思路)\n\n> 大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。~~*(不是很理解)*~~\n\n## 第一种写法\n\n定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。\n\n* while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=\n* if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1\n\n![image-20240524103229994](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240524103229994.png)\n\n## 第二种写法\n\ntarget 是在一个在左闭右开的区间里，也就是**[left, right)**\n\n```cpp\n// 版本二\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)\n        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <\n            int middle = left + ((right - left) >> 1);\n            if (nums[middle] > target) {\n                right = middle; // target 在左区间，在[left, middle)中\n            } else if (nums[middle] < target) {\n                left = middle + 1; // target 在右区间，在[middle + 1, right)中\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值，直接返回下标\n            }\n        }\n        // 未找到目标值\n        return -1;\n    }\n};\n```\n\n# 27. 移除元素\n\n## 暴力解（两层循环）\n\n* 自己写的错误解\n  * 第二层循环的遍历范围有误\n  * 手欠把多打了一个 = ，把赋值写成了判断\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        for(int i = 0; i < size; i++) {\n            if(nums[i] == val) {\n                for(int j = i; j < size; j++) { // 错误1:j只需要遍历到size-1的位置，修改为： j < size-1\n                    nums[j] == nums[j+1]; // 错误2:此处应该是=，进行赋值操作\n                }\n                size--;\n                i--;\n            }\n        }\n        return size;\n\n    }\n};\n```\n\n* 正确解\n\n```cpp\n// 时间复杂度：O(n^2)\n// 空间复杂度：O(1)\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        for (int i = 0; i < size; i++) {\n            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位\n                for (int j = i + 1; j < size; j++) {\n                    nums[j - 1] = nums[j];\n                }\n                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位\n                size--; // 此时数组的大小-1\n            }\n        }\n        return size;\n\n    }\n};\n```\n\n## 双指针法\n\n双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**\n\n### [力扣官方题解](https://leetcode.cn/problems/remove-element/solutions/730203/yi-chu-yuan-su-by-leetcode-solution-svxi/)\n\n由于题目要求删除数组中等于$val$ 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 $right$ 指向当前将要处理的元素，左指针 $left$ 指向下一个将要赋值的位置。\n\n如果右指针指向的元素不等于 $val$，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；\n\n如果右指针指向的元素等于 $val$，它不能在输出数组里，此时左指针不动，右指针右移一位。\n\n整个过程保持不变的性质是：区间  $[0,left)$ 中的元素都不等于 $val$。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。\n\n这样的算法在最坏情况下（输入数组中没有元素等 于$val$），左右指针各遍历了数组一次。\n\n![27.移除元素-双指针法](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)\n\n\n* 自己写的错误解\n\n  * 按照我的这种写法，慢指针就起不到对数组进行移动的效果，最后只是得到了数组里有几个目标值，得不到删除目标值后的数组\n  * 正确解更新在下面的代码中\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int n = nums.size();\n        int slow = 0;\n        for (int fast = 0; fast < n; fast++) {\n            if(nums[fast] != val) {\n              // 添加 nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n        return slow;\n\n    }\n};\n```\n\n","source":"_posts/数组part01.md","raw":"---\n# 基本信息\ntitle: 数组part01\ndate: 2024/05/28\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 代数组part01\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/407EA04208948845D522AAA07D1BB3F1.png\nbanner: hhttps://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/407EA04208948845D522AAA07D1BB3F1.png\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  数组part01 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n\n\n# 数组理论基础\n\n1. 数组是存放在连续内存空间上的相同类型数据的集合。\n\n   ![image-20240522193029336](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193029336.png)\n\n* 数组下标都是从0开始的\n\n* 数组内存空间的地址是连续的（**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址**）\n\n2. 二维数组\n\n   ![image-20240522193547234](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193547234.png)\n\n   不同语言内存管理不同，C++中二维数组是连续分布的，Java 不是。\n\n# 704. 二分查找\n\n[代码随想录](https://programmercarl.com/0704.二分查找.html#思路)\n\n> 大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。~~*(不是很理解)*~~\n\n## 第一种写法\n\n定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。\n\n* while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=\n* if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1\n\n![image-20240524103229994](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240524103229994.png)\n\n## 第二种写法\n\ntarget 是在一个在左闭右开的区间里，也就是**[left, right)**\n\n```cpp\n// 版本二\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)\n        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <\n            int middle = left + ((right - left) >> 1);\n            if (nums[middle] > target) {\n                right = middle; // target 在左区间，在[left, middle)中\n            } else if (nums[middle] < target) {\n                left = middle + 1; // target 在右区间，在[middle + 1, right)中\n            } else { // nums[middle] == target\n                return middle; // 数组中找到目标值，直接返回下标\n            }\n        }\n        // 未找到目标值\n        return -1;\n    }\n};\n```\n\n# 27. 移除元素\n\n## 暴力解（两层循环）\n\n* 自己写的错误解\n  * 第二层循环的遍历范围有误\n  * 手欠把多打了一个 = ，把赋值写成了判断\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        for(int i = 0; i < size; i++) {\n            if(nums[i] == val) {\n                for(int j = i; j < size; j++) { // 错误1:j只需要遍历到size-1的位置，修改为： j < size-1\n                    nums[j] == nums[j+1]; // 错误2:此处应该是=，进行赋值操作\n                }\n                size--;\n                i--;\n            }\n        }\n        return size;\n\n    }\n};\n```\n\n* 正确解\n\n```cpp\n// 时间复杂度：O(n^2)\n// 空间复杂度：O(1)\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int size = nums.size();\n        for (int i = 0; i < size; i++) {\n            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位\n                for (int j = i + 1; j < size; j++) {\n                    nums[j - 1] = nums[j];\n                }\n                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位\n                size--; // 此时数组的大小-1\n            }\n        }\n        return size;\n\n    }\n};\n```\n\n## 双指针法\n\n双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**\n\n### [力扣官方题解](https://leetcode.cn/problems/remove-element/solutions/730203/yi-chu-yuan-su-by-leetcode-solution-svxi/)\n\n由于题目要求删除数组中等于$val$ 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 $right$ 指向当前将要处理的元素，左指针 $left$ 指向下一个将要赋值的位置。\n\n如果右指针指向的元素不等于 $val$，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；\n\n如果右指针指向的元素等于 $val$，它不能在输出数组里，此时左指针不动，右指针右移一位。\n\n整个过程保持不变的性质是：区间  $[0,left)$ 中的元素都不等于 $val$。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。\n\n这样的算法在最坏情况下（输入数组中没有元素等 于$val$），左右指针各遍历了数组一次。\n\n![27.移除元素-双指针法](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)\n\n\n* 自己写的错误解\n\n  * 按照我的这种写法，慢指针就起不到对数组进行移动的效果，最后只是得到了数组里有几个目标值，得不到删除目标值后的数组\n  * 正确解更新在下面的代码中\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int n = nums.size();\n        int slow = 0;\n        for (int fast = 0; fast < n; fast++) {\n            if(nums[fast] != val) {\n              // 添加 nums[slow] = nums[fast];\n                slow++;\n            }\n        }\n        return slow;\n\n    }\n};\n```\n\n","slug":"数组part01","published":1,"updated":"2024-06-07T03:04:50.706Z","layout":"post","photos":[],"_id":"clx8i4fa6000gqt3a0ocxgi1y","content":"<h1 id=\"数组理论基础\"><a href=\"#数组理论基础\" class=\"headerlink\" title=\"数组理论基础\"></a>数组理论基础</h1><ol>\n<li><p>数组是存放在连续内存空间上的相同类型数据的集合。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193029336.png\" alt=\"image-20240522193029336\"></p>\n</li>\n</ol>\n<ul>\n<li><p>数组下标都是从0开始的</p>\n</li>\n<li><p>数组内存空间的地址是连续的（<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址</strong>）</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>二维数组</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193547234.png\" alt=\"image-20240522193547234\"></p>\n<p>不同语言内存管理不同，C++中二维数组是连续分布的，Java 不是。</p>\n</li>\n</ol>\n<h1 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h1><p><a href=\"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF\">代码随想录</a></p>\n<blockquote>\n<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。<del><em>(不是很理解)</em></del></p>\n</blockquote>\n<h2 id=\"第一种写法\"><a href=\"#第一种写法\" class=\"headerlink\" title=\"第一种写法\"></a>第一种写法</h2><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>\n<ul>\n<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>\n<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240524103229994.png\" alt=\"image-20240524103229994\"></p>\n<h2 id=\"第二种写法\"><a href=\"#第二种写法\" class=\"headerlink\" title=\"第二种写法\"></a>第二种写法</h2><p>target 是在一个在左闭右开的区间里，也就是**[left, right)**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 版本二</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = nums.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123; <span class=\"comment\">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class=\"line\">            <span class=\"type\">int</span> middle = left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[middle] &gt; target) &#123;</span><br><span class=\"line\">                right = middle; <span class=\"comment\">// target 在左区间，在[left, middle)中</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[middle] &lt; target) &#123;</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span>; <span class=\"comment\">// target 在右区间，在[middle + 1, right)中</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// nums[middle] == target</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle; <span class=\"comment\">// 数组中找到目标值，直接返回下标</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 未找到目标值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h1><h2 id=\"暴力解（两层循环）\"><a href=\"#暴力解（两层循环）\" class=\"headerlink\" title=\"暴力解（两层循环）\"></a>暴力解（两层循环）</h2><ul>\n<li>自己写的错误解<ul>\n<li>第二层循环的遍历范围有误</li>\n<li>手欠把多打了一个 &#x3D; ，把赋值写成了判断</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; size; j++) &#123; <span class=\"comment\">// 错误1:j只需要遍历到size-1的位置，修改为： j &lt; size-1</span></span><br><span class=\"line\">                    nums[j] == nums[j+<span class=\"number\">1</span>]; <span class=\"comment\">// 错误2:此处应该是=，进行赋值操作</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正确解</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 时间复杂度：O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">// 空间复杂度：O(1)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == val) &#123; <span class=\"comment\">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">                    nums[j - <span class=\"number\">1</span>] = nums[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i--; <span class=\"comment\">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class=\"line\">                size--; <span class=\"comment\">// 此时数组的大小-1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双指针法\"><a href=\"#双指针法\" class=\"headerlink\" title=\"双指针法\"></a>双指针法</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>\n<h3 id=\"力扣官方题解\"><a href=\"#力扣官方题解\" class=\"headerlink\" title=\"力扣官方题解\"></a><a href=\"https://leetcode.cn/problems/remove-element/solutions/730203/yi-chu-yuan-su-by-leetcode-solution-svxi/\">力扣官方题解</a></h3><p>由于题目要求删除数组中等于$val$ 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 $right$ 指向当前将要处理的元素，左指针 $left$ 指向下一个将要赋值的位置。</p>\n<p>如果右指针指向的元素不等于 $val$，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>\n<p>如果右指针指向的元素等于 $val$，它不能在输出数组里，此时左指针不动，右指针右移一位。</p>\n<p>整个过程保持不变的性质是：区间  $[0,left)$ 中的元素都不等于 $val$。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p>\n<p>这样的算法在最坏情况下（输入数组中没有元素等 于$val$），左右指针各遍历了数组一次。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif\" alt=\"27.移除元素-双指针法\"></p>\n<ul>\n<li><p>自己写的错误解</p>\n<ul>\n<li>按照我的这种写法，慢指针就起不到对数组进行移动的效果，最后只是得到了数组里有几个目标值，得不到删除目标值后的数组</li>\n<li>正确解更新在下面的代码中</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> fast = <span class=\"number\">0</span>; fast &lt; n; fast++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fast] != val) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 添加 nums[slow] = nums[fast];</span></span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"数组理论基础\"><a href=\"#数组理论基础\" class=\"headerlink\" title=\"数组理论基础\"></a>数组理论基础</h1><ol>\n<li><p>数组是存放在连续内存空间上的相同类型数据的集合。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193029336.png\" alt=\"image-20240522193029336\"></p>\n</li>\n</ol>\n<ul>\n<li><p>数组下标都是从0开始的</p>\n</li>\n<li><p>数组内存空间的地址是连续的（<strong>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址</strong>）</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>二维数组</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240522193547234.png\" alt=\"image-20240522193547234\"></p>\n<p>不同语言内存管理不同，C++中二维数组是连续分布的，Java 不是。</p>\n</li>\n</ol>\n<h1 id=\"704-二分查找\"><a href=\"#704-二分查找\" class=\"headerlink\" title=\"704. 二分查找\"></a>704. 二分查找</h1><p><a href=\"https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html#%E6%80%9D%E8%B7%AF\">代码随想录</a></p>\n<blockquote>\n<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。<del><em>(不是很理解)</em></del></p>\n</blockquote>\n<h2 id=\"第一种写法\"><a href=\"#第一种写法\" class=\"headerlink\" title=\"第一种写法\"></a>第一种写法</h2><p>定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p>\n<ul>\n<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>\n<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li>\n</ul>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image-20240524103229994.png\" alt=\"image-20240524103229994\"></p>\n<h2 id=\"第二种写法\"><a href=\"#第二种写法\" class=\"headerlink\" title=\"第二种写法\"></a>第二种写法</h2><p>target 是在一个在左闭右开的区间里，也就是**[left, right)**</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 版本二</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> right = nums.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 定义target在左闭右开的区间里，即：[left, right)</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123; <span class=\"comment\">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span></span><br><span class=\"line\">            <span class=\"type\">int</span> middle = left + ((right - left) &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[middle] &gt; target) &#123;</span><br><span class=\"line\">                right = middle; <span class=\"comment\">// target 在左区间，在[left, middle)中</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[middle] &lt; target) &#123;</span><br><span class=\"line\">                left = middle + <span class=\"number\">1</span>; <span class=\"comment\">// target 在右区间，在[middle + 1, right)中</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// nums[middle] == target</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> middle; <span class=\"comment\">// 数组中找到目标值，直接返回下标</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 未找到目标值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27. 移除元素\"></a>27. 移除元素</h1><h2 id=\"暴力解（两层循环）\"><a href=\"#暴力解（两层循环）\" class=\"headerlink\" title=\"暴力解（两层循环）\"></a>暴力解（两层循环）</h2><ul>\n<li>自己写的错误解<ul>\n<li>第二层循环的遍历范围有误</li>\n<li>手欠把多打了一个 &#x3D; ，把赋值写成了判断</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] == val) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; size; j++) &#123; <span class=\"comment\">// 错误1:j只需要遍历到size-1的位置，修改为： j &lt; size-1</span></span><br><span class=\"line\">                    nums[j] == nums[j+<span class=\"number\">1</span>]; <span class=\"comment\">// 错误2:此处应该是=，进行赋值操作</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                size--;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正确解</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 时间复杂度：O(n^2)</span></span><br><span class=\"line\"><span class=\"comment\">// 空间复杂度：O(1)</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == val) &#123; <span class=\"comment\">// 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; size; j++) &#123;</span><br><span class=\"line\">                    nums[j - <span class=\"number\">1</span>] = nums[j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                i--; <span class=\"comment\">// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class=\"line\">                size--; <span class=\"comment\">// 此时数组的大小-1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"双指针法\"><a href=\"#双指针法\" class=\"headerlink\" title=\"双指针法\"></a>双指针法</h2><p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>\n<h3 id=\"力扣官方题解\"><a href=\"#力扣官方题解\" class=\"headerlink\" title=\"力扣官方题解\"></a><a href=\"https://leetcode.cn/problems/remove-element/solutions/730203/yi-chu-yuan-su-by-leetcode-solution-svxi/\">力扣官方题解</a></h3><p>由于题目要求删除数组中等于$val$ 的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针 $right$ 指向当前将要处理的元素，左指针 $left$ 指向下一个将要赋值的位置。</p>\n<p>如果右指针指向的元素不等于 $val$，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>\n<p>如果右指针指向的元素等于 $val$，它不能在输出数组里，此时左指针不动，右指针右移一位。</p>\n<p>整个过程保持不变的性质是：区间  $[0,left)$ 中的元素都不等于 $val$。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。</p>\n<p>这样的算法在最坏情况下（输入数组中没有元素等 于$val$），左右指针各遍历了数组一次。</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif\" alt=\"27.移除元素-双指针法\"></p>\n<ul>\n<li><p>自己写的错误解</p>\n<ul>\n<li>按照我的这种写法，慢指针就起不到对数组进行移动的效果，最后只是得到了数组里有几个目标值，得不到删除目标值后的数组</li>\n<li>正确解更新在下面的代码中</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> fast = <span class=\"number\">0</span>; fast &lt; n; fast++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fast] != val) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 添加 nums[slow] = nums[fast];</span></span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"VS 去除程序运行时的控制台","date":"2024-05-28T16:00:00.000Z","description":"VS 去除程序运行时的控制台","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/006BFMdqly1gfcskjuy1ij31kw13gjz0.jpg","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/006BFMdqly1gfcskjuy1ij31kw13gjz0.jpg","poster":{"topic":null,"headline":"VS 去除程序运行时的控制台","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"# 问题\n\n如图所示，在程序运行时，会出现控制台窗口，一开始以为是QT的问题，解决后觉得应该不是？\n\n![IMG_5939](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5939.JPG)\n\n# 解决步骤\n\n大体流程和前面几篇文章类似，在这里主要说一下我在实际操作过程中遇到的问题，\n\n1. 右键：项目\\属性\\链接器\\系统\\子系统\n\n   * **如果你的项目工程文件很多，需要先看一下运行时控制台窗口的进入地址（上图控制台窗口右上角），在解决方案资源管理器中找到对应的项目进行右击进入属性面板**\n\n2. 子系统 选择 窗口（/SUBSYSTEM:WINDOWS）原来可能是 控制台（/SUBSYSTEM:CONSOLE）\n\n   ![img](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA6Zu36Zi15aSq6Ziz%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16.png) \n\n# 学习文档\n\n没想好起什么名字，实际上是我在解决这个问题时，查找阅读的相关文章。\n\n> * [VS2010/VS2013/VS2015/vs2017隐藏控制台程序的黑框](https://blog.csdn.net/zy_505775013/article/details/107432177)\n> * [去掉console黑窗口的方法（qt和vs）](https://www.cnblogs.com/yimaochun/archive/2011/07/29/2120653.html)\n> * [【vs】如何去掉控制台](https://blog.csdn.net/sinat_29158831/article/details/123503032)","source":"_posts/VS去除程序运行时的控制台【黑框】.md","raw":"---\n# 基本信息\ntitle: VS 去除程序运行时的控制台\ndate: 2024/05/29\ntags: [cpp, 计算机, debug]\ncategories: [debug, cpp]\ndescription: VS 去除程序运行时的控制台\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/006BFMdqly1gfcskjuy1ij31kw13gjz0.jpg\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/006BFMdqly1gfcskjuy1ij31kw13gjz0.jpg\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  VS 去除程序运行时的控制台 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n# 问题\n\n如图所示，在程序运行时，会出现控制台窗口，一开始以为是QT的问题，解决后觉得应该不是？\n\n![IMG_5939](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5939.JPG)\n\n# 解决步骤\n\n大体流程和前面几篇文章类似，在这里主要说一下我在实际操作过程中遇到的问题，\n\n1. 右键：项目\\属性\\链接器\\系统\\子系统\n\n   * **如果你的项目工程文件很多，需要先看一下运行时控制台窗口的进入地址（上图控制台窗口右上角），在解决方案资源管理器中找到对应的项目进行右击进入属性面板**\n\n2. 子系统 选择 窗口（/SUBSYSTEM:WINDOWS）原来可能是 控制台（/SUBSYSTEM:CONSOLE）\n\n   ![img](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA6Zu36Zi15aSq6Ziz%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16.png) \n\n# 学习文档\n\n没想好起什么名字，实际上是我在解决这个问题时，查找阅读的相关文章。\n\n> * [VS2010/VS2013/VS2015/vs2017隐藏控制台程序的黑框](https://blog.csdn.net/zy_505775013/article/details/107432177)\n> * [去掉console黑窗口的方法（qt和vs）](https://www.cnblogs.com/yimaochun/archive/2011/07/29/2120653.html)\n> * [【vs】如何去掉控制台](https://blog.csdn.net/sinat_29158831/article/details/123503032)","slug":"VS去除程序运行时的控制台【黑框】","published":1,"updated":"2024-06-07T03:05:24.868Z","layout":"post","photos":[],"_id":"clx8i4fa7000jqt3a9sfj6k0z","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>如图所示，在程序运行时，会出现控制台窗口，一开始以为是QT的问题，解决后觉得应该不是？</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5939.JPG\" alt=\"IMG_5939\"></p>\n<h1 id=\"解决步骤\"><a href=\"#解决步骤\" class=\"headerlink\" title=\"解决步骤\"></a>解决步骤</h1><p>大体流程和前面几篇文章类似，在这里主要说一下我在实际操作过程中遇到的问题，</p>\n<ol>\n<li><p>右键：项目\\属性\\链接器\\系统\\子系统</p>\n<ul>\n<li><strong>如果你的项目工程文件很多，需要先看一下运行时控制台窗口的进入地址（上图控制台窗口右上角），在解决方案资源管理器中找到对应的项目进行右击进入属性面板</strong></li>\n</ul>\n</li>\n<li><p>子系统 选择 窗口（&#x2F;SUBSYSTEM:WINDOWS）原来可能是 控制台（&#x2F;SUBSYSTEM:CONSOLE）</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA6Zu36Zi15aSq6Ziz%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h1 id=\"学习文档\"><a href=\"#学习文档\" class=\"headerlink\" title=\"学习文档\"></a>学习文档</h1><p>没想好起什么名字，实际上是我在解决这个问题时，查找阅读的相关文章。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/zy_505775013/article/details/107432177\">VS2010&#x2F;VS2013&#x2F;VS2015&#x2F;vs2017隐藏控制台程序的黑框</a></li>\n<li><a href=\"https://www.cnblogs.com/yimaochun/archive/2011/07/29/2120653.html\">去掉console黑窗口的方法（qt和vs）</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_29158831/article/details/123503032\">【vs】如何去掉控制台</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>如图所示，在程序运行时，会出现控制台窗口，一开始以为是QT的问题，解决后觉得应该不是？</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/IMG_5939.JPG\" alt=\"IMG_5939\"></p>\n<h1 id=\"解决步骤\"><a href=\"#解决步骤\" class=\"headerlink\" title=\"解决步骤\"></a>解决步骤</h1><p>大体流程和前面几篇文章类似，在这里主要说一下我在实际操作过程中遇到的问题，</p>\n<ol>\n<li><p>右键：项目\\属性\\链接器\\系统\\子系统</p>\n<ul>\n<li><strong>如果你的项目工程文件很多，需要先看一下运行时控制台窗口的进入地址（上图控制台窗口右上角），在解决方案资源管理器中找到对应的项目进行右击进入属性面板</strong></li>\n</ul>\n</li>\n<li><p>子系统 选择 窗口（&#x2F;SUBSYSTEM:WINDOWS）原来可能是 控制台（&#x2F;SUBSYSTEM:CONSOLE）</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/watermark%2Ctype_d3F5LXplbmhlaQ%2Cshadow_50%2Ctext_Q1NETiBA6Zu36Zi15aSq6Ziz%2Csize_20%2Ccolor_FFFFFF%2Ct_70%2Cg_se%2Cx_16.png\" alt=\"img\"></p>\n</li>\n</ol>\n<h1 id=\"学习文档\"><a href=\"#学习文档\" class=\"headerlink\" title=\"学习文档\"></a>学习文档</h1><p>没想好起什么名字，实际上是我在解决这个问题时，查找阅读的相关文章。</p>\n<blockquote>\n<ul>\n<li><a href=\"https://blog.csdn.net/zy_505775013/article/details/107432177\">VS2010&#x2F;VS2013&#x2F;VS2015&#x2F;vs2017隐藏控制台程序的黑框</a></li>\n<li><a href=\"https://www.cnblogs.com/yimaochun/archive/2011/07/29/2120653.html\">去掉console黑窗口的方法（qt和vs）</a></li>\n<li><a href=\"https://blog.csdn.net/sinat_29158831/article/details/123503032\">【vs】如何去掉控制台</a></li>\n</ul>\n</blockquote>\n"},{"title":"链表part01","date":"2024-05-30T16:00:00.000Z","description":"链表part01","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image.jpeg","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image.jpeg","poster":{"topic":null,"headline":"链表part01","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n# 203. [移除链表元素【简单】](https://leetcode.cn/problems/remove-linked-list-elements/description/)\n\n先补一下链表使用C++语言的相关实现，概念知识在上一片博文：\n\n学习文档：[链表的C++实现](https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html)\n\n## 基本结构\n\n```cpp\ntemplate<typename T>\nstruct Node {\n        T _value;            // 元素值\n        Node<T> *_next;      // 后继链指针\n\n        // 构造函数\n        Node() { _next = NULL; }                             // 默认构造函数\n        Node(const T &val) { _value = val; _next = NULL; }   // 指定元素值的构造器\n        // 访问器函数\n        T &value() { return _value; }                        // 访问元素值\n        Node<T> *next() { return _next; }                    // 返回后继指针\n        void set_next(Node<T> *next) { _next = next; }       // 设置后继指针\n};\n```\n\n元素值的访问器 `value()` 返回的是成员变量 `_value` 的引用，所以只要这一个访问器就能同时满足外部程序对元素值进行读写的功能要求，例如：\n\n```cpp\nNode<int> n(2);      // 创建一个元素值为2的节点\nint v = n.value();   // 读取元素值\nn.value()--;         // 元素值减一\nn.value() = 3 * 3;   // 设置元素值\n```\n\n## 元素增删\n\n```cpp\n// 模板类定义，用于创建一个泛型链表\ntemplate<typename T>\nstruct LinkedList {\n    // 插入和删除操作\n    void push_front(const T &val); // 在链表头部插入一个新元素\n    void insert(const T &val, const LinkedList<T>::Indicator prev); // 在指定位置后插入一个新元素\n\nprivate:\n    struct _Node; // 前向声明节点结构体\n    _Node *_head; // 链表的头节点指针\n    size_t _size; // 链表的大小\n\n    // 内部类，用于指示链表中的位置\n    struct Indicator {\n        _Node *_ptr; // 指向链表中某个节点的指针\n    };\n};\n\n// 在链表头部插入一个新元素\ntemplate<typename T>\nvoid LinkedList<T>::push_front(const T &val)\n{\n    // 创建一个新节点，并将其值初始化为val\n    LinkedList<T>::_Node *new_node = new LinkedList<T>::_Node(val);\n    \n    // 将新节点的_next指针指向当前头节点的下一个节点\n    new_node->_next = _head->_next;\n    \n    // 将头节点的_next指针指向新节点\n    _head->_next = new_node;\n    \n    // 链表大小加1\n    ++_size;\n}\n\n// 在指定位置后插入一个新元素\ntemplate<typename T>\nvoid LinkedList<T>::insert(const T &val, const LinkedList<T>::Indicator prev)\n{\n    // 创建一个新节点，并将其值初始化为val\n    LinkedList<T>::_Node *new_node = new LinkedList<T>::_Node(val);\n    \n    // 将新节点的_next指针指向prev指针所指节点的下一个节点\n    new_node->_next = prev._ptr->_next;\n    \n    // 将prev指针所指节点的_next指针指向新节点\n    prev._ptr->_next = new_node;\n    \n    // 链表大小加1\n    ++_size;\n}\n\n```\n\n\n\n```cpp\n// 模板类定义，用于创建一个泛型链表\ntemplate<typename T>\nstruct LinkedList {\n    // 删除操作\n    void pop_front(); // 删除链表头部的元素\n    void erase(LinkedList<T>::Indicator prev); // 删除指定位置后的元素\n    void clear(); // 清空链表\n\nprivate:\n    struct _Node; // 前向声明节点结构体\n    _Node *_head; // 链表的头节点指针\n    size_t _size; // 链表的大小\n\n    // 内部类，用于指示链表中的位置\n    struct Indicator {\n        _Node *_ptr; // 指向链表中某个节点的指针\n    };\n};\n\n// 删除链表头部的元素\ntemplate<typename T>\nvoid LinkedList<T>::pop_front()\n{\n    // 如果链表为空，直接返回\n    if (_size == 0) return;\n\n    // 指向头节点后的第一个节点\n    LinkedList<T>::_Node *node = _head->_next;\n\n    // 将头节点的_next指针指向第二个节点\n    _head->_next = node->_next;\n\n    // 删除第一个节点\n    delete node;\n\n    // 链表大小减1\n    --_size;\n}\n\n// 删除指定位置后的元素\ntemplate<typename T>\nvoid LinkedList<T>::erase(LinkedList<T>::Indicator prev)\n{\n    // 如果prev指针无效或其后的节点不存在，直接返回\n    if (!prev._ptr || !prev._ptr->_next) return;\n\n    // 指向prev指针后的第一个节点\n    LinkedList<T>::_Node *node = prev._ptr->_next;\n\n    // 将prev指针的_next指针指向第二个节点\n    prev._ptr->_next = node->_next;\n\n    // 删除第一个节点\n    delete node;\n\n    // 链表大小减1\n    --_size;\n}\n\n// 清空链表\ntemplate<typename T>\nvoid LinkedList<T>::clear()\n{\n    // 指向头节点后的第一个节点\n    LinkedList<T>::_Node *p = _head->_next, *next;\n\n    // 遍历链表，逐个删除所有节点\n    while (p) {\n        next = p->_next; // 保存下一个节点的指针\n        delete p; // 删除当前节点\n        p = next; // 移动到下一个节点\n    }\n\n    // 链表大小置0\n    _size = 0;\n    \n    // 将头节点的_next指针置空\n    _head->_next = NULL;\n}\n\n```\n\n## 题解\n\n![203_链表删除元素6](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210316095619221.png)\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        while(head != NULL && head->val == val) {\n            ListNode* tmp = head;\n            head = head->next;\n            delete tmp;\n        }\n\n        ListNode* cur = head;\n        while(cur != NULL && cur->next != NULL) {\n            if(cur->next->val == val) {\n                ListNode* tmp = cur->next;\n                cur->next = cur->next->next;\n                delete tmp;\n            }\n            else cur = cur->next;\n        }\n\n        return head;\n    }\n};\n```\n\n### 代码逻辑\n\n1. **删除头节点中所有值等于 `val` 的节点**：\n\n   - `while (head != NULL && head->val == val)`：只要头节点存在且值等于 `val`，就删除头节点。\n   - `ListNode* tmp = head; head = head->next; delete tmp;`：保存当前头节点，更新头节点指针，然后删除原头节点。\n\n2. **删除链表中间部分值等于 `val` 的节点**：\n\n   - `ListNode* cur = head;`：初始化 `cur` 指针，指向当前节点。\n   - `while (cur != NULL && cur->next != NULL)`：遍历链表，直到 `cur` 或其下一个节点为 `NULL`。\n   - `if (cur->next->val == val)` ：如果 `cur` 的下一个节点值等于 `val`，则删除该节点。\n      - `ListNode* tmp = cur->next; cur->next = cur->next->next; delete tmp;`：保存要删除的节点，更新 `cur` 的 `next` 指针，删除节点。\n   \n      - `else { cur = cur->next; }`：如果 `cur` 的下一个节点值不等于 `val`，则移动到下一个节点。\n   \n3. 返回值\n\n- `return head;`：返回更新后的链表头节点指针。\n\n### 为什么需要 `tmp`\n\n定义一个 `tmp` 变量是**为了安全地删除节点**。删除节点时，需要先保存该节点的地址，以便在更新指针后能够正确地释放该节点的内存。如果直接修改指针而不保存节点地址，可能会导致内存泄漏或访问已经释放的内存。\n\n# 707. [设计链表【中等】](https://leetcode.cn/problems/design-linked-list/description/)\n\nLeetCode 官方题解写的挺好的，跟着敲了一遍，熟悉一下链表增删改查等相关操作。\n\n在链表类中实现这些功能：\n\n- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\n- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n```cpp\nclass MyLinkedList {\npublic:\n    // 构造函数：初始化链表，设置大小为0，并创建一个哨兵节点\n    MyLinkedList() {\n        this->size = 0;\n        this->head = new ListNode(0);\n    }\n    \n    // 获取链表中第index个节点的值。如果索引无效，则返回-1\n    int get(int index) {\n        // 检查索引是否有效\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        // 初始化指针指向哨兵节点\n        ListNode *cur = head;\n        // 遍历链表，找到第index个节点\n        for (int i = 0; i <= index; i++) {\n            cur = cur->next;\n        }\n        // 返回第index个节点的值\n        return cur->val;\n    }\n    \n    // 在链表头部添加一个值为val的节点\n    void addAtHead(int val) {\n        // 在索引0处添加新节点\n        addAtIndex(0, val);\n    }\n    \n    // 在链表尾部添加一个值为val的节点\n    void addAtTail(int val) {\n        // 在链表的末尾添加新节点\n        addAtIndex(size, val);\n    }\n    \n    // 在链表的第index个节点之前插入值为val的节点\n    // 如果index等于链表的长度，则插入到链表的末尾\n    // 如果index大于链表的长度，则不插入节点\n    void addAtIndex(int index, int val) {\n        // 如果索引大于链表的大小，则不进行插入\n        if (index > size) {\n            return;\n        }\n        // 确保索引不小于0\n        index = max(0, index);\n        // 链表大小加1\n        size++;\n        // 初始化指针指向哨兵节点\n        ListNode *pred = head;\n        // 遍历链表，找到第index个节点的前驱节点\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        // 创建新节点\n        ListNode *toAdd = new ListNode(val);\n        // 插入新节点\n        toAdd->next = pred->next;\n        pred->next = toAdd;\n    }\n    \n    // 删除链表中第index个节点\n    void deleteAtIndex(int index) {\n        // 检查索引是否有效\n        if (index < 0 || index >= size) {\n            return;\n        }\n        // 链表大小减1\n        size--;\n        // 初始化指针指向哨兵节点\n        ListNode *pred = head;\n        // 遍历链表，找到第index个节点的前驱节点\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        // 保存要删除的节点\n        ListNode *p = pred->next;\n        // 更新前驱节点的next指针\n        pred->next = pred->next->next;\n        // 删除节点，释放内存\n        delete p;\n    }\n    \nprivate:\n    // 链表的大小\n    int size;\n    // 指向哨兵节点的指针\n    ListNode *head;\n};\n\n```\n\n\n\n# 206. 反转链表【简单】\n\n## 个人思路\n\n两个方法：\n\n1. 定义一个新的链表，然后找到原链表的最后一个元素，作为新链表的头节点(\n\n   * **发现这种方法反而很复杂，因为链表找最后一个元素很麻烦，而且单链表是不知道前一个元素是什么的，因此无论时间还是空间都比第二种更复杂**\n\n2. 第二种，把所有链表的指针原地反转即可，如图：\n\n   ![img](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)\n\n\n## 题解（双指针法）\n\n   ```cpp\n   /**\n    * Definition for singly-linked list.\n    * struct ListNode {\n    *     int val;\n    *     ListNode *next;\n    *     ListNode() : val(0), next(nullptr) {}\n    *     ListNode(int x) : val(x), next(nullptr) {}\n    *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n    * };\n    */\n   class Solution {\n   public:\n       ListNode* reverseList(ListNode* head) {\n           ListNode* prev = nullptr;\n           ListNode* curr = head;\n           while(curr != NULL) {\n               ListNode* next = curr->next;\n               curr->next = prev;\n               prev = curr;\n               curr = next;\n           }\n           return prev;\n       }\n   };\n   ```\n\n   \n\n\n\n## 个人问题\n\n* 对指针的相关操作还是过于陌生\n\n","source":"_posts/链表part01.md","raw":"---\n# 基本信息\ntitle: 链表part01\ndate: 2024/05/31\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 链表part01\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image.jpeg\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/image.jpeg\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  链表part01 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n# 203. [移除链表元素【简单】](https://leetcode.cn/problems/remove-linked-list-elements/description/)\n\n先补一下链表使用C++语言的相关实现，概念知识在上一片博文：\n\n学习文档：[链表的C++实现](https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html)\n\n## 基本结构\n\n```cpp\ntemplate<typename T>\nstruct Node {\n        T _value;            // 元素值\n        Node<T> *_next;      // 后继链指针\n\n        // 构造函数\n        Node() { _next = NULL; }                             // 默认构造函数\n        Node(const T &val) { _value = val; _next = NULL; }   // 指定元素值的构造器\n        // 访问器函数\n        T &value() { return _value; }                        // 访问元素值\n        Node<T> *next() { return _next; }                    // 返回后继指针\n        void set_next(Node<T> *next) { _next = next; }       // 设置后继指针\n};\n```\n\n元素值的访问器 `value()` 返回的是成员变量 `_value` 的引用，所以只要这一个访问器就能同时满足外部程序对元素值进行读写的功能要求，例如：\n\n```cpp\nNode<int> n(2);      // 创建一个元素值为2的节点\nint v = n.value();   // 读取元素值\nn.value()--;         // 元素值减一\nn.value() = 3 * 3;   // 设置元素值\n```\n\n## 元素增删\n\n```cpp\n// 模板类定义，用于创建一个泛型链表\ntemplate<typename T>\nstruct LinkedList {\n    // 插入和删除操作\n    void push_front(const T &val); // 在链表头部插入一个新元素\n    void insert(const T &val, const LinkedList<T>::Indicator prev); // 在指定位置后插入一个新元素\n\nprivate:\n    struct _Node; // 前向声明节点结构体\n    _Node *_head; // 链表的头节点指针\n    size_t _size; // 链表的大小\n\n    // 内部类，用于指示链表中的位置\n    struct Indicator {\n        _Node *_ptr; // 指向链表中某个节点的指针\n    };\n};\n\n// 在链表头部插入一个新元素\ntemplate<typename T>\nvoid LinkedList<T>::push_front(const T &val)\n{\n    // 创建一个新节点，并将其值初始化为val\n    LinkedList<T>::_Node *new_node = new LinkedList<T>::_Node(val);\n    \n    // 将新节点的_next指针指向当前头节点的下一个节点\n    new_node->_next = _head->_next;\n    \n    // 将头节点的_next指针指向新节点\n    _head->_next = new_node;\n    \n    // 链表大小加1\n    ++_size;\n}\n\n// 在指定位置后插入一个新元素\ntemplate<typename T>\nvoid LinkedList<T>::insert(const T &val, const LinkedList<T>::Indicator prev)\n{\n    // 创建一个新节点，并将其值初始化为val\n    LinkedList<T>::_Node *new_node = new LinkedList<T>::_Node(val);\n    \n    // 将新节点的_next指针指向prev指针所指节点的下一个节点\n    new_node->_next = prev._ptr->_next;\n    \n    // 将prev指针所指节点的_next指针指向新节点\n    prev._ptr->_next = new_node;\n    \n    // 链表大小加1\n    ++_size;\n}\n\n```\n\n\n\n```cpp\n// 模板类定义，用于创建一个泛型链表\ntemplate<typename T>\nstruct LinkedList {\n    // 删除操作\n    void pop_front(); // 删除链表头部的元素\n    void erase(LinkedList<T>::Indicator prev); // 删除指定位置后的元素\n    void clear(); // 清空链表\n\nprivate:\n    struct _Node; // 前向声明节点结构体\n    _Node *_head; // 链表的头节点指针\n    size_t _size; // 链表的大小\n\n    // 内部类，用于指示链表中的位置\n    struct Indicator {\n        _Node *_ptr; // 指向链表中某个节点的指针\n    };\n};\n\n// 删除链表头部的元素\ntemplate<typename T>\nvoid LinkedList<T>::pop_front()\n{\n    // 如果链表为空，直接返回\n    if (_size == 0) return;\n\n    // 指向头节点后的第一个节点\n    LinkedList<T>::_Node *node = _head->_next;\n\n    // 将头节点的_next指针指向第二个节点\n    _head->_next = node->_next;\n\n    // 删除第一个节点\n    delete node;\n\n    // 链表大小减1\n    --_size;\n}\n\n// 删除指定位置后的元素\ntemplate<typename T>\nvoid LinkedList<T>::erase(LinkedList<T>::Indicator prev)\n{\n    // 如果prev指针无效或其后的节点不存在，直接返回\n    if (!prev._ptr || !prev._ptr->_next) return;\n\n    // 指向prev指针后的第一个节点\n    LinkedList<T>::_Node *node = prev._ptr->_next;\n\n    // 将prev指针的_next指针指向第二个节点\n    prev._ptr->_next = node->_next;\n\n    // 删除第一个节点\n    delete node;\n\n    // 链表大小减1\n    --_size;\n}\n\n// 清空链表\ntemplate<typename T>\nvoid LinkedList<T>::clear()\n{\n    // 指向头节点后的第一个节点\n    LinkedList<T>::_Node *p = _head->_next, *next;\n\n    // 遍历链表，逐个删除所有节点\n    while (p) {\n        next = p->_next; // 保存下一个节点的指针\n        delete p; // 删除当前节点\n        p = next; // 移动到下一个节点\n    }\n\n    // 链表大小置0\n    _size = 0;\n    \n    // 将头节点的_next指针置空\n    _head->_next = NULL;\n}\n\n```\n\n## 题解\n\n![203_链表删除元素6](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210316095619221.png)\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        while(head != NULL && head->val == val) {\n            ListNode* tmp = head;\n            head = head->next;\n            delete tmp;\n        }\n\n        ListNode* cur = head;\n        while(cur != NULL && cur->next != NULL) {\n            if(cur->next->val == val) {\n                ListNode* tmp = cur->next;\n                cur->next = cur->next->next;\n                delete tmp;\n            }\n            else cur = cur->next;\n        }\n\n        return head;\n    }\n};\n```\n\n### 代码逻辑\n\n1. **删除头节点中所有值等于 `val` 的节点**：\n\n   - `while (head != NULL && head->val == val)`：只要头节点存在且值等于 `val`，就删除头节点。\n   - `ListNode* tmp = head; head = head->next; delete tmp;`：保存当前头节点，更新头节点指针，然后删除原头节点。\n\n2. **删除链表中间部分值等于 `val` 的节点**：\n\n   - `ListNode* cur = head;`：初始化 `cur` 指针，指向当前节点。\n   - `while (cur != NULL && cur->next != NULL)`：遍历链表，直到 `cur` 或其下一个节点为 `NULL`。\n   - `if (cur->next->val == val)` ：如果 `cur` 的下一个节点值等于 `val`，则删除该节点。\n      - `ListNode* tmp = cur->next; cur->next = cur->next->next; delete tmp;`：保存要删除的节点，更新 `cur` 的 `next` 指针，删除节点。\n   \n      - `else { cur = cur->next; }`：如果 `cur` 的下一个节点值不等于 `val`，则移动到下一个节点。\n   \n3. 返回值\n\n- `return head;`：返回更新后的链表头节点指针。\n\n### 为什么需要 `tmp`\n\n定义一个 `tmp` 变量是**为了安全地删除节点**。删除节点时，需要先保存该节点的地址，以便在更新指针后能够正确地释放该节点的内存。如果直接修改指针而不保存节点地址，可能会导致内存泄漏或访问已经释放的内存。\n\n# 707. [设计链表【中等】](https://leetcode.cn/problems/design-linked-list/description/)\n\nLeetCode 官方题解写的挺好的，跟着敲了一遍，熟悉一下链表增删改查等相关操作。\n\n在链表类中实现这些功能：\n\n- get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\n- addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\n- addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\n- addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\n- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\n\n```cpp\nclass MyLinkedList {\npublic:\n    // 构造函数：初始化链表，设置大小为0，并创建一个哨兵节点\n    MyLinkedList() {\n        this->size = 0;\n        this->head = new ListNode(0);\n    }\n    \n    // 获取链表中第index个节点的值。如果索引无效，则返回-1\n    int get(int index) {\n        // 检查索引是否有效\n        if (index < 0 || index >= size) {\n            return -1;\n        }\n        // 初始化指针指向哨兵节点\n        ListNode *cur = head;\n        // 遍历链表，找到第index个节点\n        for (int i = 0; i <= index; i++) {\n            cur = cur->next;\n        }\n        // 返回第index个节点的值\n        return cur->val;\n    }\n    \n    // 在链表头部添加一个值为val的节点\n    void addAtHead(int val) {\n        // 在索引0处添加新节点\n        addAtIndex(0, val);\n    }\n    \n    // 在链表尾部添加一个值为val的节点\n    void addAtTail(int val) {\n        // 在链表的末尾添加新节点\n        addAtIndex(size, val);\n    }\n    \n    // 在链表的第index个节点之前插入值为val的节点\n    // 如果index等于链表的长度，则插入到链表的末尾\n    // 如果index大于链表的长度，则不插入节点\n    void addAtIndex(int index, int val) {\n        // 如果索引大于链表的大小，则不进行插入\n        if (index > size) {\n            return;\n        }\n        // 确保索引不小于0\n        index = max(0, index);\n        // 链表大小加1\n        size++;\n        // 初始化指针指向哨兵节点\n        ListNode *pred = head;\n        // 遍历链表，找到第index个节点的前驱节点\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        // 创建新节点\n        ListNode *toAdd = new ListNode(val);\n        // 插入新节点\n        toAdd->next = pred->next;\n        pred->next = toAdd;\n    }\n    \n    // 删除链表中第index个节点\n    void deleteAtIndex(int index) {\n        // 检查索引是否有效\n        if (index < 0 || index >= size) {\n            return;\n        }\n        // 链表大小减1\n        size--;\n        // 初始化指针指向哨兵节点\n        ListNode *pred = head;\n        // 遍历链表，找到第index个节点的前驱节点\n        for (int i = 0; i < index; i++) {\n            pred = pred->next;\n        }\n        // 保存要删除的节点\n        ListNode *p = pred->next;\n        // 更新前驱节点的next指针\n        pred->next = pred->next->next;\n        // 删除节点，释放内存\n        delete p;\n    }\n    \nprivate:\n    // 链表的大小\n    int size;\n    // 指向哨兵节点的指针\n    ListNode *head;\n};\n\n```\n\n\n\n# 206. 反转链表【简单】\n\n## 个人思路\n\n两个方法：\n\n1. 定义一个新的链表，然后找到原链表的最后一个元素，作为新链表的头节点(\n\n   * **发现这种方法反而很复杂，因为链表找最后一个元素很麻烦，而且单链表是不知道前一个元素是什么的，因此无论时间还是空间都比第二种更复杂**\n\n2. 第二种，把所有链表的指针原地反转即可，如图：\n\n   ![img](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)\n\n\n## 题解（双指针法）\n\n   ```cpp\n   /**\n    * Definition for singly-linked list.\n    * struct ListNode {\n    *     int val;\n    *     ListNode *next;\n    *     ListNode() : val(0), next(nullptr) {}\n    *     ListNode(int x) : val(x), next(nullptr) {}\n    *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n    * };\n    */\n   class Solution {\n   public:\n       ListNode* reverseList(ListNode* head) {\n           ListNode* prev = nullptr;\n           ListNode* curr = head;\n           while(curr != NULL) {\n               ListNode* next = curr->next;\n               curr->next = prev;\n               prev = curr;\n               curr = next;\n           }\n           return prev;\n       }\n   };\n   ```\n\n   \n\n\n\n## 个人问题\n\n* 对指针的相关操作还是过于陌生\n\n","slug":"链表part01","published":1,"updated":"2024-06-07T03:04:36.526Z","layout":"post","photos":[],"_id":"clx8i4fa7000nqt3a53s41qjq","content":"<h1 id=\"203-移除链表元素【简单】\"><a href=\"#203-移除链表元素【简单】\" class=\"headerlink\" title=\"203. 移除链表元素【简单】\"></a>203. <a href=\"https://leetcode.cn/problems/remove-linked-list-elements/description/\">移除链表元素【简单】</a></h1><p>先补一下链表使用C++语言的相关实现，概念知识在上一片博文：</p>\n<p>学习文档：<a href=\"https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html\">链表的C++实现</a></p>\n<h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        T _value;            <span class=\"comment\">// 元素值</span></span><br><span class=\"line\">        Node&lt;T&gt; *_next;      <span class=\"comment\">// 后继链指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>() &#123; _next = <span class=\"literal\">NULL</span>; &#125;                             <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(<span class=\"type\">const</span> T &amp;val) &#123; _value = val; _next = <span class=\"literal\">NULL</span>; &#125;   <span class=\"comment\">// 指定元素值的构造器</span></span><br><span class=\"line\">        <span class=\"comment\">// 访问器函数</span></span><br><span class=\"line\">        <span class=\"function\">T &amp;<span class=\"title\">value</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> _value; &#125;                        <span class=\"comment\">// 访问元素值</span></span><br><span class=\"line\">        <span class=\"function\">Node&lt;T&gt; *<span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> _next; &#125;                    <span class=\"comment\">// 返回后继指针</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_next</span><span class=\"params\">(Node&lt;T&gt; *next)</span> </span>&#123; _next = next; &#125;       <span class=\"comment\">// 设置后继指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>元素值的访问器 <code>value()</code> 返回的是成员变量 <code>_value</code> 的引用，所以只要这一个访问器就能同时满足外部程序对元素值进行读写的功能要求，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">n</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;      <span class=\"comment\">// 创建一个元素值为2的节点</span></span><br><span class=\"line\"><span class=\"type\">int</span> v = n.<span class=\"built_in\">value</span>();   <span class=\"comment\">// 读取元素值</span></span><br><span class=\"line\">n.<span class=\"built_in\">value</span>()--;         <span class=\"comment\">// 元素值减一</span></span><br><span class=\"line\">n.<span class=\"built_in\">value</span>() = <span class=\"number\">3</span> * <span class=\"number\">3</span>;   <span class=\"comment\">// 设置元素值</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元素增删\"><a href=\"#元素增删\" class=\"headerlink\" title=\"元素增删\"></a>元素增删</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模板类定义，用于创建一个泛型链表</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">LinkedList</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 插入和删除操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_front</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;val)</span></span>; <span class=\"comment\">// 在链表头部插入一个新元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> LinkedList&lt;T&gt;::Indicator prev)</span></span>; <span class=\"comment\">// 在指定位置后插入一个新元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">_Node</span>; <span class=\"comment\">// 前向声明节点结构体</span></span><br><span class=\"line\">    _Node *_head; <span class=\"comment\">// 链表的头节点指针</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> _size; <span class=\"comment\">// 链表的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类，用于指示链表中的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Indicator</span> &#123;</span><br><span class=\"line\">        _Node *_ptr; <span class=\"comment\">// 指向链表中某个节点的指针</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在链表头部插入一个新元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">push_front</span>(<span class=\"type\">const</span> T &amp;val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新节点，并将其值初始化为val</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *new_node = <span class=\"keyword\">new</span> LinkedList&lt;T&gt;::_Node(val);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将新节点的_next指针指向当前头节点的下一个节点</span></span><br><span class=\"line\">    new_node-&gt;_next = _head-&gt;_next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将头节点的_next指针指向新节点</span></span><br><span class=\"line\">    _head-&gt;_next = new_node;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 链表大小加1</span></span><br><span class=\"line\">    ++_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在指定位置后插入一个新元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">insert</span>(<span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> LinkedList&lt;T&gt;::Indicator prev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新节点，并将其值初始化为val</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *new_node = <span class=\"keyword\">new</span> LinkedList&lt;T&gt;::_Node(val);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将新节点的_next指针指向prev指针所指节点的下一个节点</span></span><br><span class=\"line\">    new_node-&gt;_next = prev._ptr-&gt;_next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将prev指针所指节点的_next指针指向新节点</span></span><br><span class=\"line\">    prev._ptr-&gt;_next = new_node;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 链表大小加1</span></span><br><span class=\"line\">    ++_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模板类定义，用于创建一个泛型链表</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">LinkedList</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 删除操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop_front</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 删除链表头部的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(LinkedList&lt;T&gt;::Indicator prev)</span></span>; <span class=\"comment\">// 删除指定位置后的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 清空链表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">_Node</span>; <span class=\"comment\">// 前向声明节点结构体</span></span><br><span class=\"line\">    _Node *_head; <span class=\"comment\">// 链表的头节点指针</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> _size; <span class=\"comment\">// 链表的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类，用于指示链表中的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Indicator</span> &#123;</span><br><span class=\"line\">        _Node *_ptr; <span class=\"comment\">// 指向链表中某个节点的指针</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除链表头部的元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">pop_front</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果链表为空，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向头节点后的第一个节点</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *node = _head-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将头节点的_next指针指向第二个节点</span></span><br><span class=\"line\">    _head-&gt;_next = node-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除第一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表大小减1</span></span><br><span class=\"line\">    --_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除指定位置后的元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">erase</span>(LinkedList&lt;T&gt;::Indicator prev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果prev指针无效或其后的节点不存在，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev._ptr || !prev._ptr-&gt;_next) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向prev指针后的第一个节点</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *node = prev._ptr-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将prev指针的_next指针指向第二个节点</span></span><br><span class=\"line\">    prev._ptr-&gt;_next = node-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除第一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表大小减1</span></span><br><span class=\"line\">    --_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空链表</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">clear</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指向头节点后的第一个节点</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *p = _head-&gt;_next, *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历链表，逐个删除所有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        next = p-&gt;_next; <span class=\"comment\">// 保存下一个节点的指针</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p; <span class=\"comment\">// 删除当前节点</span></span><br><span class=\"line\">        p = next; <span class=\"comment\">// 移动到下一个节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表大小置0</span></span><br><span class=\"line\">    _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将头节点的_next指针置空</span></span><br><span class=\"line\">    _head-&gt;_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210316095619221.png\" alt=\"203_链表删除元素6\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeElements</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span> &amp;&amp; head-&gt;val == val) &#123;</span><br><span class=\"line\">            ListNode* tmp = head;</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">NULL</span> &amp;&amp; cur-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;next-&gt;val == val) &#123;</span><br><span class=\"line\">                ListNode* tmp = cur-&gt;next;</span><br><span class=\"line\">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码逻辑\"><a href=\"#代码逻辑\" class=\"headerlink\" title=\"代码逻辑\"></a>代码逻辑</h3><ol>\n<li><p><strong>删除头节点中所有值等于 <code>val</code> 的节点</strong>：</p>\n<ul>\n<li><code>while (head != NULL &amp;&amp; head-&gt;val == val)</code>：只要头节点存在且值等于 <code>val</code>，就删除头节点。</li>\n<li><code>ListNode* tmp = head; head = head-&gt;next; delete tmp;</code>：保存当前头节点，更新头节点指针，然后删除原头节点。</li>\n</ul>\n</li>\n<li><p><strong>删除链表中间部分值等于 <code>val</code> 的节点</strong>：</p>\n<ul>\n<li><code>ListNode* cur = head;</code>：初始化 <code>cur</code> 指针，指向当前节点。</li>\n<li><code>while (cur != NULL &amp;&amp; cur-&gt;next != NULL)</code>：遍历链表，直到 <code>cur</code> 或其下一个节点为 <code>NULL</code>。</li>\n<li><code>if (cur-&gt;next-&gt;val == val)</code> ：如果 <code>cur</code> 的下一个节点值等于 <code>val</code>，则删除该节点。<ul>\n<li><p><code>ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp;</code>：保存要删除的节点，更新 <code>cur</code> 的 <code>next</code> 指针，删除节点。</p>\n</li>\n<li><p><code>else &#123; cur = cur-&gt;next; &#125;</code>：如果 <code>cur</code> 的下一个节点值不等于 <code>val</code>，则移动到下一个节点。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>返回值</p>\n</li>\n</ol>\n<ul>\n<li><code>return head;</code>：返回更新后的链表头节点指针。</li>\n</ul>\n<h3 id=\"为什么需要-tmp\"><a href=\"#为什么需要-tmp\" class=\"headerlink\" title=\"为什么需要 tmp\"></a>为什么需要 <code>tmp</code></h3><p>定义一个 <code>tmp</code> 变量是<strong>为了安全地删除节点</strong>。删除节点时，需要先保存该节点的地址，以便在更新指针后能够正确地释放该节点的内存。如果直接修改指针而不保存节点地址，可能会导致内存泄漏或访问已经释放的内存。</p>\n<h1 id=\"707-设计链表【中等】\"><a href=\"#707-设计链表【中等】\" class=\"headerlink\" title=\"707. 设计链表【中等】\"></a>707. <a href=\"https://leetcode.cn/problems/design-linked-list/description/\">设计链表【中等】</a></h1><p>LeetCode 官方题解写的挺好的，跟着敲了一遍，熟悉一下链表增删改查等相关操作。</p>\n<p>在链表类中实现这些功能：</p>\n<ul>\n<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>\n<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>\n<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>\n<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>\n<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：初始化链表，设置大小为0，并创建一个哨兵节点</span></span><br><span class=\"line\">    <span class=\"built_in\">MyLinkedList</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;head = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取链表中第index个节点的值。如果索引无效，则返回-1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查索引是否有效</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化指针指向哨兵节点</span></span><br><span class=\"line\">        ListNode *cur = head;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，找到第index个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= index; i++) &#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回第index个节点的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表头部添加一个值为val的节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtHead</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在索引0处添加新节点</span></span><br><span class=\"line\">        <span class=\"built_in\">addAtIndex</span>(<span class=\"number\">0</span>, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表尾部添加一个值为val的节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtTail</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在链表的末尾添加新节点</span></span><br><span class=\"line\">        <span class=\"built_in\">addAtIndex</span>(size, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表的第index个节点之前插入值为val的节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果index等于链表的长度，则插入到链表的末尾</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果index大于链表的长度，则不插入节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果索引大于链表的大小，则不进行插入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 确保索引不小于0</span></span><br><span class=\"line\">        index = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">        <span class=\"comment\">// 链表大小加1</span></span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化指针指向哨兵节点</span></span><br><span class=\"line\">        ListNode *pred = head;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，找到第index个节点的前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            pred = pred-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\">        ListNode *toAdd = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(val);</span><br><span class=\"line\">        <span class=\"comment\">// 插入新节点</span></span><br><span class=\"line\">        toAdd-&gt;next = pred-&gt;next;</span><br><span class=\"line\">        pred-&gt;next = toAdd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 删除链表中第index个节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查索引是否有效</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 链表大小减1</span></span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化指针指向哨兵节点</span></span><br><span class=\"line\">        ListNode *pred = head;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，找到第index个节点的前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            pred = pred-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 保存要删除的节点</span></span><br><span class=\"line\">        ListNode *p = pred-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 更新前驱节点的next指针</span></span><br><span class=\"line\">        pred-&gt;next = pred-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 删除节点，释放内存</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 链表的大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 指向哨兵节点的指针</span></span><br><span class=\"line\">    ListNode *head;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"206-反转链表【简单】\"><a href=\"#206-反转链表【简单】\" class=\"headerlink\" title=\"206. 反转链表【简单】\"></a>206. 反转链表【简单】</h1><h2 id=\"个人思路\"><a href=\"#个人思路\" class=\"headerlink\" title=\"个人思路\"></a>个人思路</h2><p>两个方法：</p>\n<ol>\n<li><p>定义一个新的链表，然后找到原链表的最后一个元素，作为新链表的头节点(</p>\n<ul>\n<li><strong>发现这种方法反而很复杂，因为链表找最后一个元素很麻烦，而且单链表是不知道前一个元素是什么的，因此无论时间还是空间都比第二种更复杂</strong></li>\n</ul>\n</li>\n<li><p>第二种，把所有链表的指针原地反转即可，如图：</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif\" alt=\"img\"></p>\n</li>\n</ol>\n<h2 id=\"题解（双指针法）\"><a href=\"#题解（双指针法）\" class=\"headerlink\" title=\"题解（双指针法）\"></a>题解（双指针法）</h2>   <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* curr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            ListNode* next = curr-&gt;next;</span><br><span class=\"line\">            curr-&gt;next = prev;</span><br><span class=\"line\">            prev = curr;</span><br><span class=\"line\">            curr = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"个人问题\"><a href=\"#个人问题\" class=\"headerlink\" title=\"个人问题\"></a>个人问题</h2><ul>\n<li>对指针的相关操作还是过于陌生</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"203-移除链表元素【简单】\"><a href=\"#203-移除链表元素【简单】\" class=\"headerlink\" title=\"203. 移除链表元素【简单】\"></a>203. <a href=\"https://leetcode.cn/problems/remove-linked-list-elements/description/\">移除链表元素【简单】</a></h1><p>先补一下链表使用C++语言的相关实现，概念知识在上一片博文：</p>\n<p>学习文档：<a href=\"https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html\">链表的C++实现</a></p>\n<h2 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        T _value;            <span class=\"comment\">// 元素值</span></span><br><span class=\"line\">        Node&lt;T&gt; *_next;      <span class=\"comment\">// 后继链指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>() &#123; _next = <span class=\"literal\">NULL</span>; &#125;                             <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(<span class=\"type\">const</span> T &amp;val) &#123; _value = val; _next = <span class=\"literal\">NULL</span>; &#125;   <span class=\"comment\">// 指定元素值的构造器</span></span><br><span class=\"line\">        <span class=\"comment\">// 访问器函数</span></span><br><span class=\"line\">        <span class=\"function\">T &amp;<span class=\"title\">value</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> _value; &#125;                        <span class=\"comment\">// 访问元素值</span></span><br><span class=\"line\">        <span class=\"function\">Node&lt;T&gt; *<span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> _next; &#125;                    <span class=\"comment\">// 返回后继指针</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">set_next</span><span class=\"params\">(Node&lt;T&gt; *next)</span> </span>&#123; _next = next; &#125;       <span class=\"comment\">// 设置后继指针</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>元素值的访问器 <code>value()</code> 返回的是成员变量 <code>_value</code> 的引用，所以只要这一个访问器就能同时满足外部程序对元素值进行读写的功能要求，例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Node&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">n</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;      <span class=\"comment\">// 创建一个元素值为2的节点</span></span><br><span class=\"line\"><span class=\"type\">int</span> v = n.<span class=\"built_in\">value</span>();   <span class=\"comment\">// 读取元素值</span></span><br><span class=\"line\">n.<span class=\"built_in\">value</span>()--;         <span class=\"comment\">// 元素值减一</span></span><br><span class=\"line\">n.<span class=\"built_in\">value</span>() = <span class=\"number\">3</span> * <span class=\"number\">3</span>;   <span class=\"comment\">// 设置元素值</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元素增删\"><a href=\"#元素增删\" class=\"headerlink\" title=\"元素增删\"></a>元素增删</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模板类定义，用于创建一个泛型链表</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">LinkedList</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 插入和删除操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push_front</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;val)</span></span>; <span class=\"comment\">// 在链表头部插入一个新元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> LinkedList&lt;T&gt;::Indicator prev)</span></span>; <span class=\"comment\">// 在指定位置后插入一个新元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">_Node</span>; <span class=\"comment\">// 前向声明节点结构体</span></span><br><span class=\"line\">    _Node *_head; <span class=\"comment\">// 链表的头节点指针</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> _size; <span class=\"comment\">// 链表的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类，用于指示链表中的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Indicator</span> &#123;</span><br><span class=\"line\">        _Node *_ptr; <span class=\"comment\">// 指向链表中某个节点的指针</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在链表头部插入一个新元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">push_front</span>(<span class=\"type\">const</span> T &amp;val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新节点，并将其值初始化为val</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *new_node = <span class=\"keyword\">new</span> LinkedList&lt;T&gt;::_Node(val);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将新节点的_next指针指向当前头节点的下一个节点</span></span><br><span class=\"line\">    new_node-&gt;_next = _head-&gt;_next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将头节点的_next指针指向新节点</span></span><br><span class=\"line\">    _head-&gt;_next = new_node;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 链表大小加1</span></span><br><span class=\"line\">    ++_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在指定位置后插入一个新元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">insert</span>(<span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> LinkedList&lt;T&gt;::Indicator prev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个新节点，并将其值初始化为val</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *new_node = <span class=\"keyword\">new</span> LinkedList&lt;T&gt;::_Node(val);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将新节点的_next指针指向prev指针所指节点的下一个节点</span></span><br><span class=\"line\">    new_node-&gt;_next = prev._ptr-&gt;_next;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将prev指针所指节点的_next指针指向新节点</span></span><br><span class=\"line\">    prev._ptr-&gt;_next = new_node;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 链表大小加1</span></span><br><span class=\"line\">    ++_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 模板类定义，用于创建一个泛型链表</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">LinkedList</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 删除操作</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">pop_front</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 删除链表头部的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">erase</span><span class=\"params\">(LinkedList&lt;T&gt;::Indicator prev)</span></span>; <span class=\"comment\">// 删除指定位置后的元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 清空链表</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">_Node</span>; <span class=\"comment\">// 前向声明节点结构体</span></span><br><span class=\"line\">    _Node *_head; <span class=\"comment\">// 链表的头节点指针</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> _size; <span class=\"comment\">// 链表的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 内部类，用于指示链表中的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">Indicator</span> &#123;</span><br><span class=\"line\">        _Node *_ptr; <span class=\"comment\">// 指向链表中某个节点的指针</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除链表头部的元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">pop_front</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果链表为空，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_size == <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向头节点后的第一个节点</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *node = _head-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将头节点的_next指针指向第二个节点</span></span><br><span class=\"line\">    _head-&gt;_next = node-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除第一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表大小减1</span></span><br><span class=\"line\">    --_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除指定位置后的元素</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">erase</span>(LinkedList&lt;T&gt;::Indicator prev)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果prev指针无效或其后的节点不存在，直接返回</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!prev._ptr || !prev._ptr-&gt;_next) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指向prev指针后的第一个节点</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *node = prev._ptr-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将prev指针的_next指针指向第二个节点</span></span><br><span class=\"line\">    prev._ptr-&gt;_next = node-&gt;_next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除第一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> node;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表大小减1</span></span><br><span class=\"line\">    --_size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 清空链表</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"type\">void</span> LinkedList&lt;T&gt;::<span class=\"built_in\">clear</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指向头节点后的第一个节点</span></span><br><span class=\"line\">    LinkedList&lt;T&gt;::_Node *p = _head-&gt;_next, *next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历链表，逐个删除所有节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p) &#123;</span><br><span class=\"line\">        next = p-&gt;_next; <span class=\"comment\">// 保存下一个节点的指针</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p; <span class=\"comment\">// 删除当前节点</span></span><br><span class=\"line\">        p = next; <span class=\"comment\">// 移动到下一个节点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 链表大小置0</span></span><br><span class=\"line\">    _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将头节点的_next指针置空</span></span><br><span class=\"line\">    _head-&gt;_next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/20210316095619221.png\" alt=\"203_链表删除元素6\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeElements</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"literal\">NULL</span> &amp;&amp; head-&gt;val == val) &#123;</span><br><span class=\"line\">            ListNode* tmp = head;</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">NULL</span> &amp;&amp; cur-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;next-&gt;val == val) &#123;</span><br><span class=\"line\">                ListNode* tmp = cur-&gt;next;</span><br><span class=\"line\">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码逻辑\"><a href=\"#代码逻辑\" class=\"headerlink\" title=\"代码逻辑\"></a>代码逻辑</h3><ol>\n<li><p><strong>删除头节点中所有值等于 <code>val</code> 的节点</strong>：</p>\n<ul>\n<li><code>while (head != NULL &amp;&amp; head-&gt;val == val)</code>：只要头节点存在且值等于 <code>val</code>，就删除头节点。</li>\n<li><code>ListNode* tmp = head; head = head-&gt;next; delete tmp;</code>：保存当前头节点，更新头节点指针，然后删除原头节点。</li>\n</ul>\n</li>\n<li><p><strong>删除链表中间部分值等于 <code>val</code> 的节点</strong>：</p>\n<ul>\n<li><code>ListNode* cur = head;</code>：初始化 <code>cur</code> 指针，指向当前节点。</li>\n<li><code>while (cur != NULL &amp;&amp; cur-&gt;next != NULL)</code>：遍历链表，直到 <code>cur</code> 或其下一个节点为 <code>NULL</code>。</li>\n<li><code>if (cur-&gt;next-&gt;val == val)</code> ：如果 <code>cur</code> 的下一个节点值等于 <code>val</code>，则删除该节点。<ul>\n<li><p><code>ListNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp;</code>：保存要删除的节点，更新 <code>cur</code> 的 <code>next</code> 指针，删除节点。</p>\n</li>\n<li><p><code>else &#123; cur = cur-&gt;next; &#125;</code>：如果 <code>cur</code> 的下一个节点值不等于 <code>val</code>，则移动到下一个节点。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>返回值</p>\n</li>\n</ol>\n<ul>\n<li><code>return head;</code>：返回更新后的链表头节点指针。</li>\n</ul>\n<h3 id=\"为什么需要-tmp\"><a href=\"#为什么需要-tmp\" class=\"headerlink\" title=\"为什么需要 tmp\"></a>为什么需要 <code>tmp</code></h3><p>定义一个 <code>tmp</code> 变量是<strong>为了安全地删除节点</strong>。删除节点时，需要先保存该节点的地址，以便在更新指针后能够正确地释放该节点的内存。如果直接修改指针而不保存节点地址，可能会导致内存泄漏或访问已经释放的内存。</p>\n<h1 id=\"707-设计链表【中等】\"><a href=\"#707-设计链表【中等】\" class=\"headerlink\" title=\"707. 设计链表【中等】\"></a>707. <a href=\"https://leetcode.cn/problems/design-linked-list/description/\">设计链表【中等】</a></h1><p>LeetCode 官方题解写的挺好的，跟着敲了一遍，熟悉一下链表增删改查等相关操作。</p>\n<p>在链表类中实现这些功能：</p>\n<ul>\n<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>\n<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>\n<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>\n<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>\n<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数：初始化链表，设置大小为0，并创建一个哨兵节点</span></span><br><span class=\"line\">    <span class=\"built_in\">MyLinkedList</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>-&gt;head = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取链表中第index个节点的值。如果索引无效，则返回-1</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查索引是否有效</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化指针指向哨兵节点</span></span><br><span class=\"line\">        ListNode *cur = head;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，找到第index个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= index; i++) &#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 返回第index个节点的值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表头部添加一个值为val的节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtHead</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在索引0处添加新节点</span></span><br><span class=\"line\">        <span class=\"built_in\">addAtIndex</span>(<span class=\"number\">0</span>, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表尾部添加一个值为val的节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtTail</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在链表的末尾添加新节点</span></span><br><span class=\"line\">        <span class=\"built_in\">addAtIndex</span>(size, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表的第index个节点之前插入值为val的节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果index等于链表的长度，则插入到链表的末尾</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果index大于链表的长度，则不插入节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果索引大于链表的大小，则不进行插入</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 确保索引不小于0</span></span><br><span class=\"line\">        index = <span class=\"built_in\">max</span>(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">        <span class=\"comment\">// 链表大小加1</span></span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化指针指向哨兵节点</span></span><br><span class=\"line\">        ListNode *pred = head;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，找到第index个节点的前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            pred = pred-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 创建新节点</span></span><br><span class=\"line\">        ListNode *toAdd = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(val);</span><br><span class=\"line\">        <span class=\"comment\">// 插入新节点</span></span><br><span class=\"line\">        toAdd-&gt;next = pred-&gt;next;</span><br><span class=\"line\">        pred-&gt;next = toAdd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 删除链表中第index个节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 检查索引是否有效</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 链表大小减1</span></span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化指针指向哨兵节点</span></span><br><span class=\"line\">        ListNode *pred = head;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历链表，找到第index个节点的前驱节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            pred = pred-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 保存要删除的节点</span></span><br><span class=\"line\">        ListNode *p = pred-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 更新前驱节点的next指针</span></span><br><span class=\"line\">        pred-&gt;next = pred-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"comment\">// 删除节点，释放内存</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 链表的大小</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    <span class=\"comment\">// 指向哨兵节点的指针</span></span><br><span class=\"line\">    ListNode *head;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"206-反转链表【简单】\"><a href=\"#206-反转链表【简单】\" class=\"headerlink\" title=\"206. 反转链表【简单】\"></a>206. 反转链表【简单】</h1><h2 id=\"个人思路\"><a href=\"#个人思路\" class=\"headerlink\" title=\"个人思路\"></a>个人思路</h2><p>两个方法：</p>\n<ol>\n<li><p>定义一个新的链表，然后找到原链表的最后一个元素，作为新链表的头节点(</p>\n<ul>\n<li><strong>发现这种方法反而很复杂，因为链表找最后一个元素很麻烦，而且单链表是不知道前一个元素是什么的，因此无论时间还是空间都比第二种更复杂</strong></li>\n</ul>\n</li>\n<li><p>第二种，把所有链表的指针原地反转即可，如图：</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif\" alt=\"img\"></p>\n</li>\n</ol>\n<h2 id=\"题解（双指针法）\"><a href=\"#题解（双指针法）\" class=\"headerlink\" title=\"题解（双指针法）\"></a>题解（双指针法）</h2>   <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* prev = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        ListNode* curr = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curr != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            ListNode* next = curr-&gt;next;</span><br><span class=\"line\">            curr-&gt;next = prev;</span><br><span class=\"line\">            prev = curr;</span><br><span class=\"line\">            curr = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"个人问题\"><a href=\"#个人问题\" class=\"headerlink\" title=\"个人问题\"></a>个人问题</h2><ul>\n<li>对指针的相关操作还是过于陌生</li>\n</ul>\n"},{"title":"国漫：《神印王座》","date":"2024-05-07T16:00:00.000Z","description":"《神印王座》是在我小学时候看的小说了，那会《斗罗大陆》正火，受其影响，我去看了三少的其他书，其中《神印王座》给我留下的印象最深刻。","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0005.jpg","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/3a8bfe84234b40349fc3e8968ba975bc.jpeg","poster":{"topic":null,"headline":"国漫：《神印王座》","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"二次元","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"story","_content":"\n# 前言\n周围二次元的浓度实在是太高了，从宿舍到科协，不过大家都是看日漫，似乎看国漫是一件很反常的事……\n\n# 神印王座\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 28 日 -->\n\nWOC，采儿这个眼神杀我！\n\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC108%E9%9B%86_0001.gif width:300px %}\n\n\n\n<!-- node 2024 年 5 月 13 日 -->\n\n谁能拒绝叫自己主人的月夜啊！！！\n\n\n\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC75%E9%9B%86_0003.jpg width:300px %}\n\n<!-- node 2024 年 5 月 10 日 -->\n\n采儿的六道循回试炼太凶残了。\n\n<!-- node 2024 年 5 月 10 日 -->\n龙皓晨实在是太帅了！！！ \n\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC30%E9%9B%86_0002.gif width:300px %}\n\n{% endtimeline %}\n\n# 我的动漫之路\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 8 日 -->\n\n《神印王座》第一季看完了！（纠正一下，已经更新的看完了）\n\n<!-- node 2024 年 5 月 8 日 -->\n寒假的时候就看过一段时间《神印王座》，后来不知道为啥就不看了，今天又开始看了。\n\n<!-- node 2024 年 5 月 6 日 -->\n使用 Vidhub 和 Emby 搭建了一个影视资源库，从咸鱼上买了 Emby 一个账号。\n首页给我推荐《亏成首富从游戏开始》，我是土狗我爱看，一天就看完了。\n\n<!-- node 2023 年 1 月 1 日 -->\n大二的时候无聊看了《鬼灭之刃》的前三季，炎柱死的时候给我难受了好一会二，不过我的心是恋柱的。\n\n<!-- node 2020 年 1 月 1 日 -->\n大概高中的时候看过《刀剑神域》，亚丝娜最后被玷污的时候，真的想把反派掐死。\n\n<!-- node 2017 年 1 月 1 日 -->\n《火影忍者》，具体时间记不清了，断断续续地看了很久，但是依然没看完，700多集实在是太难坚持了。\n\n{% endtimeline %}\n\n\n\n# 碎碎念\n\n下图是第一季26集中的部分截图，主要是龙皓晨和韩羽猎魔团考核对战的情节。之所以对这部分情节印象深刻，是因为在韩羽输了比赛后，他爷爷对他的质问，顺势重温骑士十大守则：谦卑、诚实、怜悯、英勇、公正、牺牲、荣誉、执着、仁爱、正义。\n\n每每听到一群人大喊这十大守则的时候，我都觉得自己的中二之魂又开始觉醒了，哈哈哈哈，很巧的是我的座右铭是，温良慎独，自由从容。\n\n## 温良慎独\n\n慎独，语出《礼记·中庸》：“莫见乎隐，莫显乎微，故君子慎其独也”。第一次见到这个词就莫名地有一种亲切感，觉得这是自己立身立命的根本所在，也是人对自己要求的一种极高的境界。\n\n## 自由从容\n\n这四个字更像是自己对未来的憧憬，以及新时代青年的一种追求。\n\n今天，2024年的5月9日下午一点三十五分，我即将接受中海达的面试，曾经遥不可及的工作，现如今竟已恍然如入局，仓促至极，我真的可以“自由从容”吗？更多的时候，觉得自己是在被时代，被周边的一切推着向前挪步。\n\n{% gallery %}\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/3a8bfe84234b40349fc3e8968ba975bc.jpeg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0005.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC25%E9%9B%86_0001.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0020.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0047.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0022.jpg)\n{% endgallery %}\n\n\n\n\n# 待看\n\n* 星域四万年\n* 凡人修仙转\n\n","source":"_posts/神印王座.md","raw":"---\n# 基本信息\ntitle: 国漫：《神印王座》\ndate: 2024/05/08\ntags: [Blog]\ncategories: [动漫]\ndescription: 《神印王座》是在我小学时候看的小说了，那会《斗罗大陆》正火，受其影响，我去看了三少的其他书，其中《神印王座》给我留下的印象最深刻。\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0005.jpg\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/3a8bfe84234b40349fc3e8968ba975bc.jpeg\nposter: # 海报（可选，全图封面卡片）\n  topic:  # 可选\n  headline:  国漫：《神印王座》 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 二次元 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: story # tech/story\n---\n\n# 前言\n周围二次元的浓度实在是太高了，从宿舍到科协，不过大家都是看日漫，似乎看国漫是一件很反常的事……\n\n# 神印王座\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 28 日 -->\n\nWOC，采儿这个眼神杀我！\n\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC108%E9%9B%86_0001.gif width:300px %}\n\n\n\n<!-- node 2024 年 5 月 13 日 -->\n\n谁能拒绝叫自己主人的月夜啊！！！\n\n\n\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC75%E9%9B%86_0003.jpg width:300px %}\n\n<!-- node 2024 年 5 月 10 日 -->\n\n采儿的六道循回试炼太凶残了。\n\n<!-- node 2024 年 5 月 10 日 -->\n龙皓晨实在是太帅了！！！ \n\n{% image https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC30%E9%9B%86_0002.gif width:300px %}\n\n{% endtimeline %}\n\n# 我的动漫之路\n\n{% timeline %}\n\n<!-- node 2024 年 5 月 8 日 -->\n\n《神印王座》第一季看完了！（纠正一下，已经更新的看完了）\n\n<!-- node 2024 年 5 月 8 日 -->\n寒假的时候就看过一段时间《神印王座》，后来不知道为啥就不看了，今天又开始看了。\n\n<!-- node 2024 年 5 月 6 日 -->\n使用 Vidhub 和 Emby 搭建了一个影视资源库，从咸鱼上买了 Emby 一个账号。\n首页给我推荐《亏成首富从游戏开始》，我是土狗我爱看，一天就看完了。\n\n<!-- node 2023 年 1 月 1 日 -->\n大二的时候无聊看了《鬼灭之刃》的前三季，炎柱死的时候给我难受了好一会二，不过我的心是恋柱的。\n\n<!-- node 2020 年 1 月 1 日 -->\n大概高中的时候看过《刀剑神域》，亚丝娜最后被玷污的时候，真的想把反派掐死。\n\n<!-- node 2017 年 1 月 1 日 -->\n《火影忍者》，具体时间记不清了，断断续续地看了很久，但是依然没看完，700多集实在是太难坚持了。\n\n{% endtimeline %}\n\n\n\n# 碎碎念\n\n下图是第一季26集中的部分截图，主要是龙皓晨和韩羽猎魔团考核对战的情节。之所以对这部分情节印象深刻，是因为在韩羽输了比赛后，他爷爷对他的质问，顺势重温骑士十大守则：谦卑、诚实、怜悯、英勇、公正、牺牲、荣誉、执着、仁爱、正义。\n\n每每听到一群人大喊这十大守则的时候，我都觉得自己的中二之魂又开始觉醒了，哈哈哈哈，很巧的是我的座右铭是，温良慎独，自由从容。\n\n## 温良慎独\n\n慎独，语出《礼记·中庸》：“莫见乎隐，莫显乎微，故君子慎其独也”。第一次见到这个词就莫名地有一种亲切感，觉得这是自己立身立命的根本所在，也是人对自己要求的一种极高的境界。\n\n## 自由从容\n\n这四个字更像是自己对未来的憧憬，以及新时代青年的一种追求。\n\n今天，2024年的5月9日下午一点三十五分，我即将接受中海达的面试，曾经遥不可及的工作，现如今竟已恍然如入局，仓促至极，我真的可以“自由从容”吗？更多的时候，觉得自己是在被时代，被周边的一切推着向前挪步。\n\n{% gallery %}\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/3a8bfe84234b40349fc3e8968ba975bc.jpeg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0005.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC25%E9%9B%86_0001.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0020.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0047.jpg)\n![](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0022.jpg)\n{% endgallery %}\n\n\n\n\n# 待看\n\n* 星域四万年\n* 凡人修仙转\n\n","slug":"神印王座","published":1,"updated":"2024-06-07T03:04:46.092Z","layout":"post","photos":[],"_id":"clx8i4fa8000oqt3aedl7dv49","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>周围二次元的浓度实在是太高了，从宿舍到科协，不过大家都是看日漫，似乎看国漫是一件很反常的事……</p>\n<h1 id=\"神印王座\"><a href=\"#神印王座\" class=\"headerlink\" title=\"神印王座\"></a>神印王座</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 28 日</div><div class=\"body fs14\"><p>WOC，采儿这个眼神杀我！</p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC108%E9%9B%86_0001.gif\" style=\"width:300px;\"/></div></div></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 13 日</div><div class=\"body fs14\"><p>谁能拒绝叫自己主人的月夜啊！！！</p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC75%E9%9B%86_0003.jpg\" style=\"width:300px;\"/></div></div></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 10 日</div><div class=\"body fs14\"><p>采儿的六道循回试炼太凶残了。</p></div></div><div class=\"timenode\" index=\"3\"><div class=\"header\">2024 年 5 月 10 日</div><div class=\"body fs14\"><p>龙皓晨实在是太帅了！！！ </p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC30%E9%9B%86_0002.gif\" style=\"width:300px;\"/></div></div></div></div></div>\n\n<h1 id=\"我的动漫之路\"><a href=\"#我的动漫之路\" class=\"headerlink\" title=\"我的动漫之路\"></a>我的动漫之路</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 8 日</div><div class=\"body fs14\"><p>《神印王座》第一季看完了！（纠正一下，已经更新的看完了）</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 8 日</div><div class=\"body fs14\"><p>寒假的时候就看过一段时间《神印王座》，后来不知道为啥就不看了，今天又开始看了。</p></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 6 日</div><div class=\"body fs14\"><p>使用 Vidhub 和 Emby 搭建了一个影视资源库，从咸鱼上买了 Emby 一个账号。<br>首页给我推荐《亏成首富从游戏开始》，我是土狗我爱看，一天就看完了。</p></div></div><div class=\"timenode\" index=\"3\"><div class=\"header\">2023 年 1 月 1 日</div><div class=\"body fs14\"><p>大二的时候无聊看了《鬼灭之刃》的前三季，炎柱死的时候给我难受了好一会二，不过我的心是恋柱的。</p></div></div><div class=\"timenode\" index=\"4\"><div class=\"header\">2020 年 1 月 1 日</div><div class=\"body fs14\"><p>大概高中的时候看过《刀剑神域》，亚丝娜最后被玷污的时候，真的想把反派掐死。</p></div></div><div class=\"timenode\" index=\"5\"><div class=\"header\">2017 年 1 月 1 日</div><div class=\"body fs14\"><p>《火影忍者》，具体时间记不清了，断断续续地看了很久，但是依然没看完，700多集实在是太难坚持了。</p></div></div></div>\n\n\n\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>下图是第一季26集中的部分截图，主要是龙皓晨和韩羽猎魔团考核对战的情节。之所以对这部分情节印象深刻，是因为在韩羽输了比赛后，他爷爷对他的质问，顺势重温骑士十大守则：谦卑、诚实、怜悯、英勇、公正、牺牲、荣誉、执着、仁爱、正义。</p>\n<p>每每听到一群人大喊这十大守则的时候，我都觉得自己的中二之魂又开始觉醒了，哈哈哈哈，很巧的是我的座右铭是，温良慎独，自由从容。</p>\n<h2 id=\"温良慎独\"><a href=\"#温良慎独\" class=\"headerlink\" title=\"温良慎独\"></a>温良慎独</h2><p>慎独，语出《礼记·中庸》：“莫见乎隐，莫显乎微，故君子慎其独也”。第一次见到这个词就莫名地有一种亲切感，觉得这是自己立身立命的根本所在，也是人对自己要求的一种极高的境界。</p>\n<h2 id=\"自由从容\"><a href=\"#自由从容\" class=\"headerlink\" title=\"自由从容\"></a>自由从容</h2><p>这四个字更像是自己对未来的憧憬，以及新时代青年的一种追求。</p>\n<p>今天，2024年的5月9日下午一点三十五分，我即将接受中海达的面试，曾经遥不可及的工作，现如今竟已恍然如入局，仓促至极，我真的可以“自由从容”吗？更多的时候，觉得自己是在被时代，被周边的一切推着向前挪步。</p>\n<div class=\"tag-plugin gallery grid-box\" size=\"mix\" ratio=\"square\"><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/3a8bfe84234b40349fc3e8968ba975bc.jpeg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0005.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC25%E9%9B%86_0001.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0020.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0047.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0022.jpg\"/><div class=\"image-meta\"></div></div></div>\n\n\n\n\n<h1 id=\"待看\"><a href=\"#待看\" class=\"headerlink\" title=\"待看\"></a>待看</h1><ul>\n<li>星域四万年</li>\n<li>凡人修仙转</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>周围二次元的浓度实在是太高了，从宿舍到科协，不过大家都是看日漫，似乎看国漫是一件很反常的事……</p>\n<h1 id=\"神印王座\"><a href=\"#神印王座\" class=\"headerlink\" title=\"神印王座\"></a>神印王座</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 28 日</div><div class=\"body fs14\"><p>WOC，采儿这个眼神杀我！</p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC108%E9%9B%86_0001.gif\" style=\"width:300px;\"/></div></div></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 13 日</div><div class=\"body fs14\"><p>谁能拒绝叫自己主人的月夜啊！！！</p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC75%E9%9B%86_0003.jpg\" style=\"width:300px;\"/></div></div></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 10 日</div><div class=\"body fs14\"><p>采儿的六道循回试炼太凶残了。</p></div></div><div class=\"timenode\" index=\"3\"><div class=\"header\">2024 年 5 月 10 日</div><div class=\"body fs14\"><p>龙皓晨实在是太帅了！！！ </p><div class=\"tag-plugin image\"><div class=\"image-bg\"><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC30%E9%9B%86_0002.gif\" style=\"width:300px;\"/></div></div></div></div></div>\n\n<h1 id=\"我的动漫之路\"><a href=\"#我的动漫之路\" class=\"headerlink\" title=\"我的动漫之路\"></a>我的动漫之路</h1><div class=\"tag-plugin timeline\"><div class=\"timenode\" index=\"0\"><div class=\"header\">2024 年 5 月 8 日</div><div class=\"body fs14\"><p>《神印王座》第一季看完了！（纠正一下，已经更新的看完了）</p></div></div><div class=\"timenode\" index=\"1\"><div class=\"header\">2024 年 5 月 8 日</div><div class=\"body fs14\"><p>寒假的时候就看过一段时间《神印王座》，后来不知道为啥就不看了，今天又开始看了。</p></div></div><div class=\"timenode\" index=\"2\"><div class=\"header\">2024 年 5 月 6 日</div><div class=\"body fs14\"><p>使用 Vidhub 和 Emby 搭建了一个影视资源库，从咸鱼上买了 Emby 一个账号。<br>首页给我推荐《亏成首富从游戏开始》，我是土狗我爱看，一天就看完了。</p></div></div><div class=\"timenode\" index=\"3\"><div class=\"header\">2023 年 1 月 1 日</div><div class=\"body fs14\"><p>大二的时候无聊看了《鬼灭之刃》的前三季，炎柱死的时候给我难受了好一会二，不过我的心是恋柱的。</p></div></div><div class=\"timenode\" index=\"4\"><div class=\"header\">2020 年 1 月 1 日</div><div class=\"body fs14\"><p>大概高中的时候看过《刀剑神域》，亚丝娜最后被玷污的时候，真的想把反派掐死。</p></div></div><div class=\"timenode\" index=\"5\"><div class=\"header\">2017 年 1 月 1 日</div><div class=\"body fs14\"><p>《火影忍者》，具体时间记不清了，断断续续地看了很久，但是依然没看完，700多集实在是太难坚持了。</p></div></div></div>\n\n\n\n<h1 id=\"碎碎念\"><a href=\"#碎碎念\" class=\"headerlink\" title=\"碎碎念\"></a>碎碎念</h1><p>下图是第一季26集中的部分截图，主要是龙皓晨和韩羽猎魔团考核对战的情节。之所以对这部分情节印象深刻，是因为在韩羽输了比赛后，他爷爷对他的质问，顺势重温骑士十大守则：谦卑、诚实、怜悯、英勇、公正、牺牲、荣誉、执着、仁爱、正义。</p>\n<p>每每听到一群人大喊这十大守则的时候，我都觉得自己的中二之魂又开始觉醒了，哈哈哈哈，很巧的是我的座右铭是，温良慎独，自由从容。</p>\n<h2 id=\"温良慎独\"><a href=\"#温良慎独\" class=\"headerlink\" title=\"温良慎独\"></a>温良慎独</h2><p>慎独，语出《礼记·中庸》：“莫见乎隐，莫显乎微，故君子慎其独也”。第一次见到这个词就莫名地有一种亲切感，觉得这是自己立身立命的根本所在，也是人对自己要求的一种极高的境界。</p>\n<h2 id=\"自由从容\"><a href=\"#自由从容\" class=\"headerlink\" title=\"自由从容\"></a>自由从容</h2><p>这四个字更像是自己对未来的憧憬，以及新时代青年的一种追求。</p>\n<p>今天，2024年的5月9日下午一点三十五分，我即将接受中海达的面试，曾经遥不可及的工作，现如今竟已恍然如入局，仓促至极，我真的可以“自由从容”吗？更多的时候，觉得自己是在被时代，被周边的一切推着向前挪步。</p>\n<div class=\"tag-plugin gallery grid-box\" size=\"mix\" ratio=\"square\"><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/3a8bfe84234b40349fc3e8968ba975bc.jpeg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0005.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC25%E9%9B%86_0001.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0020.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0047.jpg\"/><div class=\"image-meta\"></div></div><div class=\"grid-cell\"><img data-fancybox=\"gallery-1\" src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/%E7%A5%9E%E5%8D%B0%E7%8E%8B%E5%BA%A7%20%E7%AC%AC1%E5%AD%A3%20%E7%AC%AC26%E9%9B%86_0022.jpg\"/><div class=\"image-meta\"></div></div></div>\n\n\n\n\n<h1 id=\"待看\"><a href=\"#待看\" class=\"headerlink\" title=\"待看\"></a>待看</h1><ul>\n<li>星域四万年</li>\n<li>凡人修仙转</li>\n</ul>\n"},{"title":"链表part02","date":"2024-05-30T16:00:00.000Z","description":"链表part02","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/C8167B63922595B3E70BC8E35E68A4A5.png","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/C8167B63922595B3E70BC8E35E68A4A5.png","poster":{"topic":null,"headline":"链表part01","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n# 24. 两两交换链表中的节点【中等】\n\n## 题解\n\n没有什么特殊的方法，不过要注意一下几点：\n\n1. 画图理解思路，注意每个结点的位置（前链是否还存在，后链连接的是谁）\n2. 理解临时结点的作用\n   * 如果不设置临时结点，以`cur->next = cur->next->next;`为例，在进行这条语句后，之前的 `cur` 的下一个结点将会找不到自己的位置\n3. while 循环的判断条件\n   1. `cur->next != nullptr`：这个条件确保了当前节点 `cur` 的下一个节点存在，即保证了在执行交换操作时不会出现空指针异常。\n   2. `cur->next->next != nullptr`：这个条件确保了当前节点 `cur` 的下下个节点存在，即保证了至少有两个节点可以进行交换操作。\n\n\n## 虚拟头结点\n\n虚拟头节点是一个在链表头部添加的额外节点，它不存储任何实际的数据，只是作为辅助。虚拟头节点的引入可以简化链表操作的逻辑，并解决一些特殊情况下的边界问题。\n\n通过引入虚拟头节点，我们可以在处理链表时统一操作逻辑。**无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作**。这减少了代码中的条件判断，使得代码更加简洁和易于理解。\n\n虚拟头节点还能够**解决空链表的情况**。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。\n\n`GPT` 的回答：\n\n虚拟头节点在这段代码中的作用是简化链表操作，特别是在处理头节点时的边界情况处理。具体来说，虚拟头节点的作用包括以下几点：\n\n1. **简化边界情况处理**：通过引入虚拟头节点，可以避免在处理头节点时需要特殊处理的情况。在这段代码中，虚拟头节点 `dumyHead` 的存在使得整个链表的操作更加统一，不需要单独考虑头节点的情况。\n\n2. **方便链表操作**：虚拟头节点可以作为一个占位符，使得链表操作更加灵活。在这段代码中，虚拟头节点的 `next` 指针指向真正的头节点，通过操作虚拟头节点，可以方便地操作链表的头部和其他部分。\n\n3. **简化节点插入操作**：在链表中插入节点时，如果没有虚拟头节点，需要特殊处理头节点的情况。有了虚拟头节点，插入操作可以变得更加统一和简单，不需要单独处理头节点。\n\n4. **避免空指针异常**：通过引入虚拟头节点，可以避免在链表操作中出现空指针异常。在这段代码中，虚拟头节点的存在保证了 `cur->next` 不会为空，避免了空指针异常的可能性。\n\n# 19. 删除链表的倒数第N个节点【中等】\n\n## 思路\n\n### 个人思路\n\n两次循环，显然时间复杂度为 $O(n^2)$\n\n1. 第一层循环用于确定链表的长度\n2. 第二次循环用于找到倒数第 N 个结点\n\n代码如下，\n\n```cpp\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *dummyHead = new ListNode(0); // 创建一个虚拟头节点\n        dummyHead->next = head; // 将虚拟头节点指向链表头部\n        ListNode *cur = dummyHead;\n        int size = 0;\n\n        // 计算链表长度\n        while(cur->next != nullptr) {\n            size++;\n            cur = cur->next;\n        }\n\n        int index = size - n;\n        cur = dummyHead;\n\n        // 移动到要删除节点的前一个节点\n        for(int i = 0; i < index; i++) {\n            cur = cur->next;\n        }\n\n        // 删除倒数第 n 个节点\n        ListNode *tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n\n        return dummyHead->next; // 返回链表头部\n    }\n};\n\n```\n\n### 快慢指针\n\n双指针的经典应用，如果要删除倒数第 n 个节点，让 fast 移动 n 步，然后让 fast 和 slow 同时移动，直到 fast 指向链表末尾。删掉 slow 所指向的节点就可以了。\n\n```cpp\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        ListNode* slow = dummyHead;\n        ListNode* fast = dummyHead;\n        while(n-- && fast != NULL) {\n            fast = fast->next;\n        }\n        fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点\n        while (fast != NULL) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        slow->next = slow->next->next; \n        \n        // ListNode *tmp = slow->next;  C++释放内存的逻辑\n        // slow->next = tmp->next;\n        // delete tmp;\n        \n        return dummyHead->next;\n    }\n};\n```\n\n# 160. 链表相交【简单】\n\n## 思路和代码\n\n### 我的思路（暴力解）\n\n* 两层循环进行比对，代码如下（这是我个人写的代码，相关错误已在注释中指出）\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      // 不需要的代码\n      //  ListNode* dummyHeadA = new ListNode(0);\n      //  dummyHeadA->next = headA;\n        ListNode* dummyHeadB = new ListNode(0);\n        dummyHeadB->next = headB;\n\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        while(curA != NULL) {\n            while(curB != NULL) {\n              // 错误1:应该是比较结点本身，而不是结点的值\n                if(curA->val == curB->val) {\n                    return curA->val; // 错误2:题目要求返回的是链表\n                }\n                curB = curB->next;\n            }\n            curA = curA->next;\n          //错误3:内存循环后没有重置curB指针\n        }\n        return NULL;\n    }\n};\n\n```\n\n修改都的代码如下，\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* dummyHeadB = new ListNode(0);\n        dummyHeadB->next = headB;\n\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        while(curA != NULL) {\n            while(curB != NULL) {\n                if(curA == curB) {\n                    return curA;\n                }\n                curB = curB->next;\n            }\n            curA = curA->next;\n            curB = dummyHeadB;\n        }\n        return NULL;\n    }\n};\n```\n\n### 双指针\n\n代码如下，\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // 如果任意一个链表为空，则不可能有相交节点\n        if (headA == NULL || headB == NULL) return NULL;\n\n        // 初始化两个指针\n        ListNode* a = headA;\n        ListNode* b = headB;\n\n        // 遍历两个链表\n        while (a != b) {\n            // 如果指针a到达链表A的末尾，则将其重置到链表B的头节点\n            a = (a == NULL) ? headB : a->next;\n            // 如果指针b到达链表B的末尾，则将其重置到链表A的头节点\n            b = (b == NULL) ? headA : b->next;\n        }\n\n        // 如果两个指针相遇，则返回相交节点；否则返回NULL\n        return a;\n    }\n};\n\n```\n\n其中比较难以理解的是遍历链表部分，有点取巧的成分在里面，可以画个图模拟一下，\n\n```cpp\n// while (a != b) {\n//     a = (a == NULL) ? headB : a->next;\n//     b = (b == NULL) ? headA : b->next;\n// }\n// 三元表达式含义同下面的代码：\n\nif (a == NULL) {\n    a = headB;\n} else {\n    a = a->next;\n}\n\nif (b == NULL) {\n    b = headA;\n} else {\n    b = b->next;\n}\n\n```\n\n- **循环条件**：当 `a` 和 `b` 不相等时继续循环。\n- **指针移动**：\n  - 如果 `a` 到达了链表 `A` 的末尾（即 `a == NULL`），则将 `a` 指向链表 `B` 的头节点 `headB`。否则，将 `a` 移动到下一个节点 `a->next`。\n  - 同样地，如果 `b` 到达了链表 `B` 的末尾（即 `b == NULL`），则将 `b` 指向链表 `A` 的头节点 `headA`。否则，将 `b` 移动到下一个节点 `b->next`。\n\n# 142. 环形链表II[中等]\n\n## 思路\n\n看不懂，直接上代码吧！\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇\n            if (slow == fast) {\n                ListNode* index1 = fast;\n                ListNode* index2 = head;\n                while (index1 != index2) {\n                    index1 = index1->next;\n                    index2 = index2->next;\n                }\n                return index2; // 返回环的入口\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n","source":"_posts/链表part02.md","raw":"---\n# 基本信息\ntitle: 链表part02\ndate: 2024/05/31\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 链表part02\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/C8167B63922595B3E70BC8E35E68A4A5.png\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/C8167B63922595B3E70BC8E35E68A4A5.png\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  链表part01 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n# 24. 两两交换链表中的节点【中等】\n\n## 题解\n\n没有什么特殊的方法，不过要注意一下几点：\n\n1. 画图理解思路，注意每个结点的位置（前链是否还存在，后链连接的是谁）\n2. 理解临时结点的作用\n   * 如果不设置临时结点，以`cur->next = cur->next->next;`为例，在进行这条语句后，之前的 `cur` 的下一个结点将会找不到自己的位置\n3. while 循环的判断条件\n   1. `cur->next != nullptr`：这个条件确保了当前节点 `cur` 的下一个节点存在，即保证了在执行交换操作时不会出现空指针异常。\n   2. `cur->next->next != nullptr`：这个条件确保了当前节点 `cur` 的下下个节点存在，即保证了至少有两个节点可以进行交换操作。\n\n\n## 虚拟头结点\n\n虚拟头节点是一个在链表头部添加的额外节点，它不存储任何实际的数据，只是作为辅助。虚拟头节点的引入可以简化链表操作的逻辑，并解决一些特殊情况下的边界问题。\n\n通过引入虚拟头节点，我们可以在处理链表时统一操作逻辑。**无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作**。这减少了代码中的条件判断，使得代码更加简洁和易于理解。\n\n虚拟头节点还能够**解决空链表的情况**。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。\n\n`GPT` 的回答：\n\n虚拟头节点在这段代码中的作用是简化链表操作，特别是在处理头节点时的边界情况处理。具体来说，虚拟头节点的作用包括以下几点：\n\n1. **简化边界情况处理**：通过引入虚拟头节点，可以避免在处理头节点时需要特殊处理的情况。在这段代码中，虚拟头节点 `dumyHead` 的存在使得整个链表的操作更加统一，不需要单独考虑头节点的情况。\n\n2. **方便链表操作**：虚拟头节点可以作为一个占位符，使得链表操作更加灵活。在这段代码中，虚拟头节点的 `next` 指针指向真正的头节点，通过操作虚拟头节点，可以方便地操作链表的头部和其他部分。\n\n3. **简化节点插入操作**：在链表中插入节点时，如果没有虚拟头节点，需要特殊处理头节点的情况。有了虚拟头节点，插入操作可以变得更加统一和简单，不需要单独处理头节点。\n\n4. **避免空指针异常**：通过引入虚拟头节点，可以避免在链表操作中出现空指针异常。在这段代码中，虚拟头节点的存在保证了 `cur->next` 不会为空，避免了空指针异常的可能性。\n\n# 19. 删除链表的倒数第N个节点【中等】\n\n## 思路\n\n### 个人思路\n\n两次循环，显然时间复杂度为 $O(n^2)$\n\n1. 第一层循环用于确定链表的长度\n2. 第二次循环用于找到倒数第 N 个结点\n\n代码如下，\n\n```cpp\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *dummyHead = new ListNode(0); // 创建一个虚拟头节点\n        dummyHead->next = head; // 将虚拟头节点指向链表头部\n        ListNode *cur = dummyHead;\n        int size = 0;\n\n        // 计算链表长度\n        while(cur->next != nullptr) {\n            size++;\n            cur = cur->next;\n        }\n\n        int index = size - n;\n        cur = dummyHead;\n\n        // 移动到要删除节点的前一个节点\n        for(int i = 0; i < index; i++) {\n            cur = cur->next;\n        }\n\n        // 删除倒数第 n 个节点\n        ListNode *tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n\n        return dummyHead->next; // 返回链表头部\n    }\n};\n\n```\n\n### 快慢指针\n\n双指针的经典应用，如果要删除倒数第 n 个节点，让 fast 移动 n 步，然后让 fast 和 slow 同时移动，直到 fast 指向链表末尾。删掉 slow 所指向的节点就可以了。\n\n```cpp\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        ListNode* slow = dummyHead;\n        ListNode* fast = dummyHead;\n        while(n-- && fast != NULL) {\n            fast = fast->next;\n        }\n        fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点\n        while (fast != NULL) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        slow->next = slow->next->next; \n        \n        // ListNode *tmp = slow->next;  C++释放内存的逻辑\n        // slow->next = tmp->next;\n        // delete tmp;\n        \n        return dummyHead->next;\n    }\n};\n```\n\n# 160. 链表相交【简单】\n\n## 思路和代码\n\n### 我的思路（暴力解）\n\n* 两层循环进行比对，代码如下（这是我个人写的代码，相关错误已在注释中指出）\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n      // 不需要的代码\n      //  ListNode* dummyHeadA = new ListNode(0);\n      //  dummyHeadA->next = headA;\n        ListNode* dummyHeadB = new ListNode(0);\n        dummyHeadB->next = headB;\n\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        while(curA != NULL) {\n            while(curB != NULL) {\n              // 错误1:应该是比较结点本身，而不是结点的值\n                if(curA->val == curB->val) {\n                    return curA->val; // 错误2:题目要求返回的是链表\n                }\n                curB = curB->next;\n            }\n            curA = curA->next;\n          //错误3:内存循环后没有重置curB指针\n        }\n        return NULL;\n    }\n};\n\n```\n\n修改都的代码如下，\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* dummyHeadB = new ListNode(0);\n        dummyHeadB->next = headB;\n\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        while(curA != NULL) {\n            while(curB != NULL) {\n                if(curA == curB) {\n                    return curA;\n                }\n                curB = curB->next;\n            }\n            curA = curA->next;\n            curB = dummyHeadB;\n        }\n        return NULL;\n    }\n};\n```\n\n### 双指针\n\n代码如下，\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // 如果任意一个链表为空，则不可能有相交节点\n        if (headA == NULL || headB == NULL) return NULL;\n\n        // 初始化两个指针\n        ListNode* a = headA;\n        ListNode* b = headB;\n\n        // 遍历两个链表\n        while (a != b) {\n            // 如果指针a到达链表A的末尾，则将其重置到链表B的头节点\n            a = (a == NULL) ? headB : a->next;\n            // 如果指针b到达链表B的末尾，则将其重置到链表A的头节点\n            b = (b == NULL) ? headA : b->next;\n        }\n\n        // 如果两个指针相遇，则返回相交节点；否则返回NULL\n        return a;\n    }\n};\n\n```\n\n其中比较难以理解的是遍历链表部分，有点取巧的成分在里面，可以画个图模拟一下，\n\n```cpp\n// while (a != b) {\n//     a = (a == NULL) ? headB : a->next;\n//     b = (b == NULL) ? headA : b->next;\n// }\n// 三元表达式含义同下面的代码：\n\nif (a == NULL) {\n    a = headB;\n} else {\n    a = a->next;\n}\n\nif (b == NULL) {\n    b = headA;\n} else {\n    b = b->next;\n}\n\n```\n\n- **循环条件**：当 `a` 和 `b` 不相等时继续循环。\n- **指针移动**：\n  - 如果 `a` 到达了链表 `A` 的末尾（即 `a == NULL`），则将 `a` 指向链表 `B` 的头节点 `headB`。否则，将 `a` 移动到下一个节点 `a->next`。\n  - 同样地，如果 `b` 到达了链表 `B` 的末尾（即 `b == NULL`），则将 `b` 指向链表 `A` 的头节点 `headA`。否则，将 `b` 移动到下一个节点 `b->next`。\n\n# 142. 环形链表II[中等]\n\n## 思路\n\n看不懂，直接上代码吧！\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != NULL && fast->next != NULL) {\n            slow = slow->next;\n            fast = fast->next->next;\n            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇\n            if (slow == fast) {\n                ListNode* index1 = fast;\n                ListNode* index2 = head;\n                while (index1 != index2) {\n                    index1 = index1->next;\n                    index2 = index2->next;\n                }\n                return index2; // 返回环的入口\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n","slug":"链表part02","published":1,"updated":"2024-06-07T03:10:21.610Z","layout":"post","photos":[],"_id":"clx8i4fa8000sqt3a2m8wh971","content":"<h1 id=\"24-两两交换链表中的节点【中等】\"><a href=\"#24-两两交换链表中的节点【中等】\" class=\"headerlink\" title=\"24. 两两交换链表中的节点【中等】\"></a>24. 两两交换链表中的节点【中等】</h1><h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>没有什么特殊的方法，不过要注意一下几点：</p>\n<ol>\n<li>画图理解思路，注意每个结点的位置（前链是否还存在，后链连接的是谁）</li>\n<li>理解临时结点的作用<ul>\n<li>如果不设置临时结点，以<code>cur-&gt;next = cur-&gt;next-&gt;next;</code>为例，在进行这条语句后，之前的 <code>cur</code> 的下一个结点将会找不到自己的位置</li>\n</ul>\n</li>\n<li>while 循环的判断条件<ol>\n<li><code>cur-&gt;next != nullptr</code>：这个条件确保了当前节点 <code>cur</code> 的下一个节点存在，即保证了在执行交换操作时不会出现空指针异常。</li>\n<li><code>cur-&gt;next-&gt;next != nullptr</code>：这个条件确保了当前节点 <code>cur</code> 的下下个节点存在，即保证了至少有两个节点可以进行交换操作。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"虚拟头结点\"><a href=\"#虚拟头结点\" class=\"headerlink\" title=\"虚拟头结点\"></a>虚拟头结点</h2><p>虚拟头节点是一个在链表头部添加的额外节点，它不存储任何实际的数据，只是作为辅助。虚拟头节点的引入可以简化链表操作的逻辑，并解决一些特殊情况下的边界问题。</p>\n<p>通过引入虚拟头节点，我们可以在处理链表时统一操作逻辑。<strong>无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作</strong>。这减少了代码中的条件判断，使得代码更加简洁和易于理解。</p>\n<p>虚拟头节点还能够<strong>解决空链表的情况</strong>。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。</p>\n<p><code>GPT</code> 的回答：</p>\n<p>虚拟头节点在这段代码中的作用是简化链表操作，特别是在处理头节点时的边界情况处理。具体来说，虚拟头节点的作用包括以下几点：</p>\n<ol>\n<li><p><strong>简化边界情况处理</strong>：通过引入虚拟头节点，可以避免在处理头节点时需要特殊处理的情况。在这段代码中，虚拟头节点 <code>dumyHead</code> 的存在使得整个链表的操作更加统一，不需要单独考虑头节点的情况。</p>\n</li>\n<li><p><strong>方便链表操作</strong>：虚拟头节点可以作为一个占位符，使得链表操作更加灵活。在这段代码中，虚拟头节点的 <code>next</code> 指针指向真正的头节点，通过操作虚拟头节点，可以方便地操作链表的头部和其他部分。</p>\n</li>\n<li><p><strong>简化节点插入操作</strong>：在链表中插入节点时，如果没有虚拟头节点，需要特殊处理头节点的情况。有了虚拟头节点，插入操作可以变得更加统一和简单，不需要单独处理头节点。</p>\n</li>\n<li><p><strong>避免空指针异常</strong>：通过引入虚拟头节点，可以避免在链表操作中出现空指针异常。在这段代码中，虚拟头节点的存在保证了 <code>cur-&gt;next</code> 不会为空，避免了空指针异常的可能性。</p>\n</li>\n</ol>\n<h1 id=\"19-删除链表的倒数第N个节点【中等】\"><a href=\"#19-删除链表的倒数第N个节点【中等】\" class=\"headerlink\" title=\"19. 删除链表的倒数第N个节点【中等】\"></a>19. 删除链表的倒数第N个节点【中等】</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"个人思路\"><a href=\"#个人思路\" class=\"headerlink\" title=\"个人思路\"></a>个人思路</h3><p>两次循环，显然时间复杂度为 $O(n^2)$</p>\n<ol>\n<li>第一层循环用于确定链表的长度</li>\n<li>第二次循环用于找到倒数第 N 个结点</li>\n</ol>\n<p>代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>); <span class=\"comment\">// 创建一个虚拟头节点</span></span><br><span class=\"line\">        dummyHead-&gt;next = head; <span class=\"comment\">// 将虚拟头节点指向链表头部</span></span><br><span class=\"line\">        ListNode *cur = dummyHead;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算链表长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> index = size - n;</span><br><span class=\"line\">        cur = dummyHead;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移动到要删除节点的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除倒数第 n 个节点</span></span><br><span class=\"line\">        ListNode *tmp = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead-&gt;next; <span class=\"comment\">// 返回链表头部</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快慢指针\"><a href=\"#快慢指针\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h3><p>双指针的经典应用，如果要删除倒数第 n 个节点，让 fast 移动 n 步，然后让 fast 和 slow 同时移动，直到 fast 指向链表末尾。删掉 slow 所指向的节点就可以了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHead-&gt;next = head;</span><br><span class=\"line\">        ListNode* slow = dummyHead;</span><br><span class=\"line\">        ListNode* fast = dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &amp;&amp; fast != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fast = fast-&gt;next; <span class=\"comment\">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow-&gt;next = slow-&gt;next-&gt;next; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class=\"line\">        <span class=\"comment\">// delete tmp;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"160-链表相交【简单】\"><a href=\"#160-链表相交【简单】\" class=\"headerlink\" title=\"160. 链表相交【简单】\"></a>160. 链表相交【简单】</h1><h2 id=\"思路和代码\"><a href=\"#思路和代码\" class=\"headerlink\" title=\"思路和代码\"></a>思路和代码</h2><h3 id=\"我的思路（暴力解）\"><a href=\"#我的思路（暴力解）\" class=\"headerlink\" title=\"我的思路（暴力解）\"></a>我的思路（暴力解）</h3><ul>\n<li>两层循环进行比对，代码如下（这是我个人写的代码，相关错误已在注释中指出）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不需要的代码</span></span><br><span class=\"line\">      <span class=\"comment\">//  ListNode* dummyHeadA = new ListNode(0);</span></span><br><span class=\"line\">      <span class=\"comment\">//  dummyHeadA-&gt;next = headA;</span></span><br><span class=\"line\">        ListNode* dummyHeadB = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHeadB-&gt;next = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curA = headA;</span><br><span class=\"line\">        ListNode* curB = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curA != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(curB != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 错误1:应该是比较结点本身，而不是结点的值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(curA-&gt;val == curB-&gt;val) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> curA-&gt;val; <span class=\"comment\">// 错误2:题目要求返回的是链表</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                curB = curB-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">          <span class=\"comment\">//错误3:内存循环后没有重置curB指针</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>修改都的代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummyHeadB = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHeadB-&gt;next = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curA = headA;</span><br><span class=\"line\">        ListNode* curB = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curA != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(curB != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(curA == curB) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> curA;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                curB = curB-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">            curB = dummyHeadB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果任意一个链表为空，则不可能有相交节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"literal\">NULL</span> || headB == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化两个指针</span></span><br><span class=\"line\">        ListNode* a = headA;</span><br><span class=\"line\">        ListNode* b = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历两个链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a != b) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果指针a到达链表A的末尾，则将其重置到链表B的头节点</span></span><br><span class=\"line\">            a = (a == <span class=\"literal\">NULL</span>) ? headB : a-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果指针b到达链表B的末尾，则将其重置到链表A的头节点</span></span><br><span class=\"line\">            b = (b == <span class=\"literal\">NULL</span>) ? headA : b-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果两个指针相遇，则返回相交节点；否则返回NULL</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中比较难以理解的是遍历链表部分，有点取巧的成分在里面，可以画个图模拟一下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// while (a != b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     a = (a == NULL) ? headB : a-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">//     b = (b == NULL) ? headA : b-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 三元表达式含义同下面的代码：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    a = headB;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    a = a-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (b == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    b = headA;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    b = b-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>循环条件</strong>：当 <code>a</code> 和 <code>b</code> 不相等时继续循环。</li>\n<li><strong>指针移动</strong>：<ul>\n<li>如果 <code>a</code> 到达了链表 <code>A</code> 的末尾（即 <code>a == NULL</code>），则将 <code>a</code> 指向链表 <code>B</code> 的头节点 <code>headB</code>。否则，将 <code>a</code> 移动到下一个节点 <code>a-&gt;next</code>。</li>\n<li>同样地，如果 <code>b</code> 到达了链表 <code>B</code> 的末尾（即 <code>b == NULL</code>），则将 <code>b</code> 指向链表 <code>A</code> 的头节点 <code>headA</code>。否则，将 <code>b</code> 移动到下一个节点 <code>b-&gt;next</code>。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"142-环形链表II-中等\"><a href=\"#142-环形链表II-中等\" class=\"headerlink\" title=\"142. 环形链表II[中等]\"></a>142. 环形链表II[中等]</h1><h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>看不懂，直接上代码吧！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* fast = head;</span><br><span class=\"line\">        ListNode* slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">                ListNode* index1 = fast;</span><br><span class=\"line\">                ListNode* index2 = head;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (index1 != index2) &#123;</span><br><span class=\"line\">                    index1 = index1-&gt;next;</span><br><span class=\"line\">                    index2 = index2-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index2; <span class=\"comment\">// 返回环的入口</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h1 id=\"24-两两交换链表中的节点【中等】\"><a href=\"#24-两两交换链表中的节点【中等】\" class=\"headerlink\" title=\"24. 两两交换链表中的节点【中等】\"></a>24. 两两交换链表中的节点【中等】</h1><h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>没有什么特殊的方法，不过要注意一下几点：</p>\n<ol>\n<li>画图理解思路，注意每个结点的位置（前链是否还存在，后链连接的是谁）</li>\n<li>理解临时结点的作用<ul>\n<li>如果不设置临时结点，以<code>cur-&gt;next = cur-&gt;next-&gt;next;</code>为例，在进行这条语句后，之前的 <code>cur</code> 的下一个结点将会找不到自己的位置</li>\n</ul>\n</li>\n<li>while 循环的判断条件<ol>\n<li><code>cur-&gt;next != nullptr</code>：这个条件确保了当前节点 <code>cur</code> 的下一个节点存在，即保证了在执行交换操作时不会出现空指针异常。</li>\n<li><code>cur-&gt;next-&gt;next != nullptr</code>：这个条件确保了当前节点 <code>cur</code> 的下下个节点存在，即保证了至少有两个节点可以进行交换操作。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"虚拟头结点\"><a href=\"#虚拟头结点\" class=\"headerlink\" title=\"虚拟头结点\"></a>虚拟头结点</h2><p>虚拟头节点是一个在链表头部添加的额外节点，它不存储任何实际的数据，只是作为辅助。虚拟头节点的引入可以简化链表操作的逻辑，并解决一些特殊情况下的边界问题。</p>\n<p>通过引入虚拟头节点，我们可以在处理链表时统一操作逻辑。<strong>无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作</strong>。这减少了代码中的条件判断，使得代码更加简洁和易于理解。</p>\n<p>虚拟头节点还能够<strong>解决空链表的情况</strong>。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。</p>\n<p><code>GPT</code> 的回答：</p>\n<p>虚拟头节点在这段代码中的作用是简化链表操作，特别是在处理头节点时的边界情况处理。具体来说，虚拟头节点的作用包括以下几点：</p>\n<ol>\n<li><p><strong>简化边界情况处理</strong>：通过引入虚拟头节点，可以避免在处理头节点时需要特殊处理的情况。在这段代码中，虚拟头节点 <code>dumyHead</code> 的存在使得整个链表的操作更加统一，不需要单独考虑头节点的情况。</p>\n</li>\n<li><p><strong>方便链表操作</strong>：虚拟头节点可以作为一个占位符，使得链表操作更加灵活。在这段代码中，虚拟头节点的 <code>next</code> 指针指向真正的头节点，通过操作虚拟头节点，可以方便地操作链表的头部和其他部分。</p>\n</li>\n<li><p><strong>简化节点插入操作</strong>：在链表中插入节点时，如果没有虚拟头节点，需要特殊处理头节点的情况。有了虚拟头节点，插入操作可以变得更加统一和简单，不需要单独处理头节点。</p>\n</li>\n<li><p><strong>避免空指针异常</strong>：通过引入虚拟头节点，可以避免在链表操作中出现空指针异常。在这段代码中，虚拟头节点的存在保证了 <code>cur-&gt;next</code> 不会为空，避免了空指针异常的可能性。</p>\n</li>\n</ol>\n<h1 id=\"19-删除链表的倒数第N个节点【中等】\"><a href=\"#19-删除链表的倒数第N个节点【中等】\" class=\"headerlink\" title=\"19. 删除链表的倒数第N个节点【中等】\"></a>19. 删除链表的倒数第N个节点【中等】</h1><h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><h3 id=\"个人思路\"><a href=\"#个人思路\" class=\"headerlink\" title=\"个人思路\"></a>个人思路</h3><p>两次循环，显然时间复杂度为 $O(n^2)$</p>\n<ol>\n<li>第一层循环用于确定链表的长度</li>\n<li>第二次循环用于找到倒数第 N 个结点</li>\n</ol>\n<p>代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode *dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>); <span class=\"comment\">// 创建一个虚拟头节点</span></span><br><span class=\"line\">        dummyHead-&gt;next = head; <span class=\"comment\">// 将虚拟头节点指向链表头部</span></span><br><span class=\"line\">        ListNode *cur = dummyHead;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 计算链表长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> index = size - n;</span><br><span class=\"line\">        cur = dummyHead;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 移动到要删除节点的前一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除倒数第 n 个节点</span></span><br><span class=\"line\">        ListNode *tmp = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead-&gt;next; <span class=\"comment\">// 返回链表头部</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快慢指针\"><a href=\"#快慢指针\" class=\"headerlink\" title=\"快慢指针\"></a>快慢指针</h3><p>双指针的经典应用，如果要删除倒数第 n 个节点，让 fast 移动 n 步，然后让 fast 和 slow 同时移动，直到 fast 指向链表末尾。删掉 slow 所指向的节点就可以了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHead-&gt;next = head;</span><br><span class=\"line\">        ListNode* slow = dummyHead;</span><br><span class=\"line\">        ListNode* fast = dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &amp;&amp; fast != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fast = fast-&gt;next; <span class=\"comment\">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow-&gt;next = slow-&gt;next-&gt;next; </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// ListNode *tmp = slow-&gt;next;  C++释放内存的逻辑</span></span><br><span class=\"line\">        <span class=\"comment\">// slow-&gt;next = tmp-&gt;next;</span></span><br><span class=\"line\">        <span class=\"comment\">// delete tmp;</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"160-链表相交【简单】\"><a href=\"#160-链表相交【简单】\" class=\"headerlink\" title=\"160. 链表相交【简单】\"></a>160. 链表相交【简单】</h1><h2 id=\"思路和代码\"><a href=\"#思路和代码\" class=\"headerlink\" title=\"思路和代码\"></a>思路和代码</h2><h3 id=\"我的思路（暴力解）\"><a href=\"#我的思路（暴力解）\" class=\"headerlink\" title=\"我的思路（暴力解）\"></a>我的思路（暴力解）</h3><ul>\n<li>两层循环进行比对，代码如下（这是我个人写的代码，相关错误已在注释中指出）</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 不需要的代码</span></span><br><span class=\"line\">      <span class=\"comment\">//  ListNode* dummyHeadA = new ListNode(0);</span></span><br><span class=\"line\">      <span class=\"comment\">//  dummyHeadA-&gt;next = headA;</span></span><br><span class=\"line\">        ListNode* dummyHeadB = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHeadB-&gt;next = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curA = headA;</span><br><span class=\"line\">        ListNode* curB = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curA != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(curB != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 错误1:应该是比较结点本身，而不是结点的值</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(curA-&gt;val == curB-&gt;val) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> curA-&gt;val; <span class=\"comment\">// 错误2:题目要求返回的是链表</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                curB = curB-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">          <span class=\"comment\">//错误3:内存循环后没有重置curB指针</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>修改都的代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummyHeadB = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHeadB-&gt;next = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* curA = headA;</span><br><span class=\"line\">        ListNode* curB = headB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(curA != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(curB != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(curA == curB) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> curA;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                curB = curB-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">            curB = dummyHeadB;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>代码如下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果任意一个链表为空，则不可能有相交节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headA == <span class=\"literal\">NULL</span> || headB == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化两个指针</span></span><br><span class=\"line\">        ListNode* a = headA;</span><br><span class=\"line\">        ListNode* b = headB;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历两个链表</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (a != b) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果指针a到达链表A的末尾，则将其重置到链表B的头节点</span></span><br><span class=\"line\">            a = (a == <span class=\"literal\">NULL</span>) ? headB : a-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">// 如果指针b到达链表B的末尾，则将其重置到链表A的头节点</span></span><br><span class=\"line\">            b = (b == <span class=\"literal\">NULL</span>) ? headA : b-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果两个指针相遇，则返回相交节点；否则返回NULL</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其中比较难以理解的是遍历链表部分，有点取巧的成分在里面，可以画个图模拟一下，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// while (a != b) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     a = (a == NULL) ? headB : a-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">//     b = (b == NULL) ? headA : b-&gt;next;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 三元表达式含义同下面的代码：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    a = headB;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    a = a-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (b == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    b = headA;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    b = b-&gt;next;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>循环条件</strong>：当 <code>a</code> 和 <code>b</code> 不相等时继续循环。</li>\n<li><strong>指针移动</strong>：<ul>\n<li>如果 <code>a</code> 到达了链表 <code>A</code> 的末尾（即 <code>a == NULL</code>），则将 <code>a</code> 指向链表 <code>B</code> 的头节点 <code>headB</code>。否则，将 <code>a</code> 移动到下一个节点 <code>a-&gt;next</code>。</li>\n<li>同样地，如果 <code>b</code> 到达了链表 <code>B</code> 的末尾（即 <code>b == NULL</code>），则将 <code>b</code> 指向链表 <code>A</code> 的头节点 <code>headA</code>。否则，将 <code>b</code> 移动到下一个节点 <code>b-&gt;next</code>。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"142-环形链表II-中等\"><a href=\"#142-环形链表II-中等\" class=\"headerlink\" title=\"142. 环形链表II[中等]\"></a>142. 环形链表II[中等]</h1><h2 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>看不懂，直接上代码吧！</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* fast = head;</span><br><span class=\"line\">        ListNode* slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"literal\">NULL</span> &amp;&amp; fast-&gt;next != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">            <span class=\"comment\">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">                ListNode* index1 = fast;</span><br><span class=\"line\">                ListNode* index2 = head;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (index1 != index2) &#123;</span><br><span class=\"line\">                    index1 = index1-&gt;next;</span><br><span class=\"line\">                    index2 = index2-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> index2; <span class=\"comment\">// 返回环的入口</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"链表基础知识","date":"2024-05-27T16:00:00.000Z","description":"链表基础知识","cover":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/v2-239662070cf2381e66413bc42f001a64_r.jpg.png","banner":"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/v2-239662070cf2381e66413bc42f001a64_r.jpg.png","poster":{"topic":null,"headline":"代码随想录刷题记录","caption":null,"color":null},"sticky":null,"mermaid":null,"katex":true,"mathjax":null,"topic":"计算机","author":"Montee","references":null,"comments":1,"indexing":null,"breadcrumb":null,"leftbar":null,"rightbar":null,"h1":null,"type":"tech","_content":"\n# [代码随想录](https://programmercarl.com/链表理论基础.html#链表的类型)\n\n# [C++ 算法编程指南](https://majorli.github.io/algo_guide/index.html)\n\n> 仅作个人学习笔记使用，读者如需详细深入学习，请点击上方链接\n\n## 1. 链表的概念\n\n> 注意一下相关名词，还有链表的特点。\n\n**链表**采用链式存储结构来实现线性表。\n\n* 特点：\n  * 每一个元素都至多有一个唯一确定的前驱，也至多有一个唯一确定的后继；\n  * 链表中的元素在实际的物理存储上并不要求一个接一个存放，链表可以在任意内存位置随意存放各个元素。\n\n为了维持元素之间逻辑上的前驱后继关系，链表为每一个元素附加上表示其前后关系的指针，\n\n* **前链：**指向前驱元素的指针\n* **后链：**指向后继元素的指针\n* 元素的值和它的前后链组合在一起形成一个**元素节点**，简称**节点**\n* 节点才是**链表的基本存储单元**，所有元素的节点通过前后链串接起来形成链表。\n\n\n\n* **单链表：**链表中的每一个元素节点都只有一个后链\n* **双链表：**每一个元素节点同时有一个后链和一个前链\n\n示例：有一个整数序列[1,2,3]，其物理地址可以存放在内存的任意位置，通过链来维持前后关系。~~（双链表中：红色为后链，蓝色为前链）~~\n\n![../../_images/317_linkedlist_mem.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_mem.png)\n\n### 1.1 链表的定义\n\n* 单链表的定义：\n\n  ```cpp\n  struct Node {\n          int value;   // 元素值\n          Node *next;  // 后链指针\n  \n          Node(int val = 0) { value = val; next = NULL; } // 构造函数\n  };\n  ```\n\n* 如果希望让链表能像STL库的那些容器一样，可以支持任意数据类型，那么可以将节点定义为模板结构，比如下面这个双向链表节点的结构\n\n  ```cpp\n  template <typename T>\n  struct Node {\n          T value;     // 元素值\n          Node *next;  // 后链指针\n          Node *prev;  // 前链指针\n  \n          Node() { next = NULL; prev = NULL; }      // 默认构造函数\n          Node(const T &val) { value = val; next = NULL; prev = NULL; }  // 指定元素值的构造函数\n  };\n  ```\n\n\n\n### 1.2 头指针、尾指针\n\n> 链表只能沿着链的方向迭代遍历节点，无法根据下标直接访问指定位置上的元素，需要按下标访问时要从头节点开始逐个向后寻找，这是一个线性时间 𝑂(𝑛) 的操作。\n\n因此，我们需要告诉链表链表头和链表尾在哪里，自然而然的出现了“**头指针（head）**”和“**尾指针（tail）**”\n\n![../../_images/317_linkedlist_2.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_2.png)\n\n### 1.3 循环链表\n\n挺好理解的，就是**首尾相连**。\n\n* **循环单链表中尾节点的后继不再是空指针而是指向头指针**；\n* 循环双链表中尾节点的后继指向头节点，头节点的前驱指向尾节点。\n* 这样一来，表被改造成了一个环，\n* 从而也就没有了严格意义上的头尾节点，所以这种循环链表中我们通常会用一个**当前指针**（current）来代替原来的头尾指针。\n\n## 2. 元素的插入与删除\n\n链表最大的优势是可以实现常数时间 𝑂(1) 的元素增删操作。\n\n代码操作看这里：[链表的C++实现](https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html)\n\n### 插入\n\n向链表中指定位置插入一个元素的操作如下图：\n\n![../../_images/317_linkedlist_ins.png](https://majorli.github.io/algo_guide/_images/317_linkedlist_ins.png)\n\n### 删除\n\n![../../_images/317_linkedlist_era.png](https://majorli.github.io/algo_guide/_images/317_linkedlist_era.png)\n\n","source":"_posts/链表基础知识.md","raw":"---\n# 基本信息\ntitle: 链表基础知识\ndate: 2024/05/28\ntags: [cpp, 计算机, leetcode, 秋招, 算法]\ncategories: [cpp, 题解]\ndescription: 链表基础知识\n# 封面\ncover: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/v2-239662070cf2381e66413bc42f001a64_r.jpg.png\nbanner: https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/v2-239662070cf2381e66413bc42f001a64_r.jpg.png\nposter:  # 海报（可选，全图封面卡片）\n  topic: # 可选\n  headline:  代码随想录刷题记录 # 必选\n  caption:  # 可选\n  color:  # 可选\n# 插件\nsticky: # 数字越大越靠前\nmermaid:\nkatex: true\nmathjax: \n# 可选\ntopic: 计算机 # 专栏 id\nauthor: Montee\nreferences:\ncomments: # 设置 false 禁止评论\nindexing: # 设置 false 避免被搜索\nbreadcrumb: # 设置 false 隐藏面包屑导航\nleftbar: \nrightbar:\nh1: # 设置为 '' 隐藏标题\ntype: tech # tech/story\n---\n\n# [代码随想录](https://programmercarl.com/链表理论基础.html#链表的类型)\n\n# [C++ 算法编程指南](https://majorli.github.io/algo_guide/index.html)\n\n> 仅作个人学习笔记使用，读者如需详细深入学习，请点击上方链接\n\n## 1. 链表的概念\n\n> 注意一下相关名词，还有链表的特点。\n\n**链表**采用链式存储结构来实现线性表。\n\n* 特点：\n  * 每一个元素都至多有一个唯一确定的前驱，也至多有一个唯一确定的后继；\n  * 链表中的元素在实际的物理存储上并不要求一个接一个存放，链表可以在任意内存位置随意存放各个元素。\n\n为了维持元素之间逻辑上的前驱后继关系，链表为每一个元素附加上表示其前后关系的指针，\n\n* **前链：**指向前驱元素的指针\n* **后链：**指向后继元素的指针\n* 元素的值和它的前后链组合在一起形成一个**元素节点**，简称**节点**\n* 节点才是**链表的基本存储单元**，所有元素的节点通过前后链串接起来形成链表。\n\n\n\n* **单链表：**链表中的每一个元素节点都只有一个后链\n* **双链表：**每一个元素节点同时有一个后链和一个前链\n\n示例：有一个整数序列[1,2,3]，其物理地址可以存放在内存的任意位置，通过链来维持前后关系。~~（双链表中：红色为后链，蓝色为前链）~~\n\n![../../_images/317_linkedlist_mem.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_mem.png)\n\n### 1.1 链表的定义\n\n* 单链表的定义：\n\n  ```cpp\n  struct Node {\n          int value;   // 元素值\n          Node *next;  // 后链指针\n  \n          Node(int val = 0) { value = val; next = NULL; } // 构造函数\n  };\n  ```\n\n* 如果希望让链表能像STL库的那些容器一样，可以支持任意数据类型，那么可以将节点定义为模板结构，比如下面这个双向链表节点的结构\n\n  ```cpp\n  template <typename T>\n  struct Node {\n          T value;     // 元素值\n          Node *next;  // 后链指针\n          Node *prev;  // 前链指针\n  \n          Node() { next = NULL; prev = NULL; }      // 默认构造函数\n          Node(const T &val) { value = val; next = NULL; prev = NULL; }  // 指定元素值的构造函数\n  };\n  ```\n\n\n\n### 1.2 头指针、尾指针\n\n> 链表只能沿着链的方向迭代遍历节点，无法根据下标直接访问指定位置上的元素，需要按下标访问时要从头节点开始逐个向后寻找，这是一个线性时间 𝑂(𝑛) 的操作。\n\n因此，我们需要告诉链表链表头和链表尾在哪里，自然而然的出现了“**头指针（head）**”和“**尾指针（tail）**”\n\n![../../_images/317_linkedlist_2.png](https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_2.png)\n\n### 1.3 循环链表\n\n挺好理解的，就是**首尾相连**。\n\n* **循环单链表中尾节点的后继不再是空指针而是指向头指针**；\n* 循环双链表中尾节点的后继指向头节点，头节点的前驱指向尾节点。\n* 这样一来，表被改造成了一个环，\n* 从而也就没有了严格意义上的头尾节点，所以这种循环链表中我们通常会用一个**当前指针**（current）来代替原来的头尾指针。\n\n## 2. 元素的插入与删除\n\n链表最大的优势是可以实现常数时间 𝑂(1) 的元素增删操作。\n\n代码操作看这里：[链表的C++实现](https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html)\n\n### 插入\n\n向链表中指定位置插入一个元素的操作如下图：\n\n![../../_images/317_linkedlist_ins.png](https://majorli.github.io/algo_guide/_images/317_linkedlist_ins.png)\n\n### 删除\n\n![../../_images/317_linkedlist_era.png](https://majorli.github.io/algo_guide/_images/317_linkedlist_era.png)\n\n","slug":"链表基础知识","published":1,"updated":"2024-06-07T03:04:30.493Z","layout":"post","photos":[],"_id":"clx8i4fa8000uqt3a7duqdymp","content":"<h1 id=\"代码随想录\"><a href=\"#代码随想录\" class=\"headerlink\" title=\"代码随想录\"></a><a href=\"https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\">代码随想录</a></h1><h1 id=\"C-算法编程指南\"><a href=\"#C-算法编程指南\" class=\"headerlink\" title=\"C++ 算法编程指南\"></a><a href=\"https://majorli.github.io/algo_guide/index.html\">C++ 算法编程指南</a></h1><blockquote>\n<p>仅作个人学习笔记使用，读者如需详细深入学习，请点击上方链接</p>\n</blockquote>\n<h2 id=\"1-链表的概念\"><a href=\"#1-链表的概念\" class=\"headerlink\" title=\"1. 链表的概念\"></a>1. 链表的概念</h2><blockquote>\n<p>注意一下相关名词，还有链表的特点。</p>\n</blockquote>\n<p><strong>链表</strong>采用链式存储结构来实现线性表。</p>\n<ul>\n<li>特点：<ul>\n<li>每一个元素都至多有一个唯一确定的前驱，也至多有一个唯一确定的后继；</li>\n<li>链表中的元素在实际的物理存储上并不要求一个接一个存放，链表可以在任意内存位置随意存放各个元素。</li>\n</ul>\n</li>\n</ul>\n<p>为了维持元素之间逻辑上的前驱后继关系，链表为每一个元素附加上表示其前后关系的指针，</p>\n<ul>\n<li><p><strong>前链：</strong>指向前驱元素的指针</p>\n</li>\n<li><p><strong>后链：</strong>指向后继元素的指针</p>\n</li>\n<li><p>元素的值和它的前后链组合在一起形成一个<strong>元素节点</strong>，简称<strong>节点</strong></p>\n</li>\n<li><p>节点才是<strong>链表的基本存储单元</strong>，所有元素的节点通过前后链串接起来形成链表。</p>\n</li>\n<li><p><strong>单链表：</strong>链表中的每一个元素节点都只有一个后链</p>\n</li>\n<li><p><strong>双链表：</strong>每一个元素节点同时有一个后链和一个前链</p>\n</li>\n</ul>\n<p>示例：有一个整数序列[1,2,3]，其物理地址可以存放在内存的任意位置，通过链来维持前后关系。<del>（双链表中：红色为后链，蓝色为前链）</del></p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_mem.png\" alt=\"../../_images/317_linkedlist_mem.png\"></p>\n<h3 id=\"1-1-链表的定义\"><a href=\"#1-1-链表的定义\" class=\"headerlink\" title=\"1.1 链表的定义\"></a>1.1 链表的定义</h3><ul>\n<li><p>单链表的定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> value;   <span class=\"comment\">// 元素值</span></span><br><span class=\"line\">        Node *next;  <span class=\"comment\">// 后链指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> val = <span class=\"number\">0</span>) &#123; value = val; next = <span class=\"literal\">NULL</span>; &#125; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果希望让链表能像STL库的那些容器一样，可以支持任意数据类型，那么可以将节点定义为模板结构，比如下面这个双向链表节点的结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        T value;     <span class=\"comment\">// 元素值</span></span><br><span class=\"line\">        Node *next;  <span class=\"comment\">// 后链指针</span></span><br><span class=\"line\">        Node *prev;  <span class=\"comment\">// 前链指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>() &#123; next = <span class=\"literal\">NULL</span>; prev = <span class=\"literal\">NULL</span>; &#125;      <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(<span class=\"type\">const</span> T &amp;val) &#123; value = val; next = <span class=\"literal\">NULL</span>; prev = <span class=\"literal\">NULL</span>; &#125;  <span class=\"comment\">// 指定元素值的构造函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-2-头指针、尾指针\"><a href=\"#1-2-头指针、尾指针\" class=\"headerlink\" title=\"1.2 头指针、尾指针\"></a>1.2 头指针、尾指针</h3><blockquote>\n<p>链表只能沿着链的方向迭代遍历节点，无法根据下标直接访问指定位置上的元素，需要按下标访问时要从头节点开始逐个向后寻找，这是一个线性时间 𝑂(𝑛) 的操作。</p>\n</blockquote>\n<p>因此，我们需要告诉链表链表头和链表尾在哪里，自然而然的出现了“<strong>头指针（head）</strong>”和“<strong>尾指针（tail）</strong>”</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_2.png\" alt=\"../../_images/317_linkedlist_2.png\"></p>\n<h3 id=\"1-3-循环链表\"><a href=\"#1-3-循环链表\" class=\"headerlink\" title=\"1.3 循环链表\"></a>1.3 循环链表</h3><p>挺好理解的，就是<strong>首尾相连</strong>。</p>\n<ul>\n<li><strong>循环单链表中尾节点的后继不再是空指针而是指向头指针</strong>；</li>\n<li>循环双链表中尾节点的后继指向头节点，头节点的前驱指向尾节点。</li>\n<li>这样一来，表被改造成了一个环，</li>\n<li>从而也就没有了严格意义上的头尾节点，所以这种循环链表中我们通常会用一个<strong>当前指针</strong>（current）来代替原来的头尾指针。</li>\n</ul>\n<h2 id=\"2-元素的插入与删除\"><a href=\"#2-元素的插入与删除\" class=\"headerlink\" title=\"2. 元素的插入与删除\"></a>2. 元素的插入与删除</h2><p>链表最大的优势是可以实现常数时间 𝑂(1) 的元素增删操作。</p>\n<p>代码操作看这里：<a href=\"https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html\">链表的C++实现</a></p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>向链表中指定位置插入一个元素的操作如下图：</p>\n<p><img src=\"https://majorli.github.io/algo_guide/_images/317_linkedlist_ins.png\" alt=\"../../_images/317_linkedlist_ins.png\"></p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p><img src=\"https://majorli.github.io/algo_guide/_images/317_linkedlist_era.png\" alt=\"../../_images/317_linkedlist_era.png\"></p>\n","excerpt":"","more":"<h1 id=\"代码随想录\"><a href=\"#代码随想录\" class=\"headerlink\" title=\"代码随想录\"></a><a href=\"https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B\">代码随想录</a></h1><h1 id=\"C-算法编程指南\"><a href=\"#C-算法编程指南\" class=\"headerlink\" title=\"C++ 算法编程指南\"></a><a href=\"https://majorli.github.io/algo_guide/index.html\">C++ 算法编程指南</a></h1><blockquote>\n<p>仅作个人学习笔记使用，读者如需详细深入学习，请点击上方链接</p>\n</blockquote>\n<h2 id=\"1-链表的概念\"><a href=\"#1-链表的概念\" class=\"headerlink\" title=\"1. 链表的概念\"></a>1. 链表的概念</h2><blockquote>\n<p>注意一下相关名词，还有链表的特点。</p>\n</blockquote>\n<p><strong>链表</strong>采用链式存储结构来实现线性表。</p>\n<ul>\n<li>特点：<ul>\n<li>每一个元素都至多有一个唯一确定的前驱，也至多有一个唯一确定的后继；</li>\n<li>链表中的元素在实际的物理存储上并不要求一个接一个存放，链表可以在任意内存位置随意存放各个元素。</li>\n</ul>\n</li>\n</ul>\n<p>为了维持元素之间逻辑上的前驱后继关系，链表为每一个元素附加上表示其前后关系的指针，</p>\n<ul>\n<li><p><strong>前链：</strong>指向前驱元素的指针</p>\n</li>\n<li><p><strong>后链：</strong>指向后继元素的指针</p>\n</li>\n<li><p>元素的值和它的前后链组合在一起形成一个<strong>元素节点</strong>，简称<strong>节点</strong></p>\n</li>\n<li><p>节点才是<strong>链表的基本存储单元</strong>，所有元素的节点通过前后链串接起来形成链表。</p>\n</li>\n<li><p><strong>单链表：</strong>链表中的每一个元素节点都只有一个后链</p>\n</li>\n<li><p><strong>双链表：</strong>每一个元素节点同时有一个后链和一个前链</p>\n</li>\n</ul>\n<p>示例：有一个整数序列[1,2,3]，其物理地址可以存放在内存的任意位置，通过链来维持前后关系。<del>（双链表中：红色为后链，蓝色为前链）</del></p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_mem.png\" alt=\"../../_images/317_linkedlist_mem.png\"></p>\n<h3 id=\"1-1-链表的定义\"><a href=\"#1-1-链表的定义\" class=\"headerlink\" title=\"1.1 链表的定义\"></a>1.1 链表的定义</h3><ul>\n<li><p>单链表的定义：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> value;   <span class=\"comment\">// 元素值</span></span><br><span class=\"line\">        Node *next;  <span class=\"comment\">// 后链指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(<span class=\"type\">int</span> val = <span class=\"number\">0</span>) &#123; value = val; next = <span class=\"literal\">NULL</span>; &#125; <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果希望让链表能像STL库的那些容器一样，可以支持任意数据类型，那么可以将节点定义为模板结构，比如下面这个双向链表节点的结构</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Node</span> &#123;</span><br><span class=\"line\">        T value;     <span class=\"comment\">// 元素值</span></span><br><span class=\"line\">        Node *next;  <span class=\"comment\">// 后链指针</span></span><br><span class=\"line\">        Node *prev;  <span class=\"comment\">// 前链指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>() &#123; next = <span class=\"literal\">NULL</span>; prev = <span class=\"literal\">NULL</span>; &#125;      <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">Node</span>(<span class=\"type\">const</span> T &amp;val) &#123; value = val; next = <span class=\"literal\">NULL</span>; prev = <span class=\"literal\">NULL</span>; &#125;  <span class=\"comment\">// 指定元素值的构造函数</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"1-2-头指针、尾指针\"><a href=\"#1-2-头指针、尾指针\" class=\"headerlink\" title=\"1.2 头指针、尾指针\"></a>1.2 头指针、尾指针</h3><blockquote>\n<p>链表只能沿着链的方向迭代遍历节点，无法根据下标直接访问指定位置上的元素，需要按下标访问时要从头节点开始逐个向后寻找，这是一个线性时间 𝑂(𝑛) 的操作。</p>\n</blockquote>\n<p>因此，我们需要告诉链表链表头和链表尾在哪里，自然而然的出现了“<strong>头指针（head）</strong>”和“<strong>尾指针（tail）</strong>”</p>\n<p><img src=\"https://blog-imges-1313931661.cos.ap-nanjing.myqcloud.com/317_linkedlist_2.png\" alt=\"../../_images/317_linkedlist_2.png\"></p>\n<h3 id=\"1-3-循环链表\"><a href=\"#1-3-循环链表\" class=\"headerlink\" title=\"1.3 循环链表\"></a>1.3 循环链表</h3><p>挺好理解的，就是<strong>首尾相连</strong>。</p>\n<ul>\n<li><strong>循环单链表中尾节点的后继不再是空指针而是指向头指针</strong>；</li>\n<li>循环双链表中尾节点的后继指向头节点，头节点的前驱指向尾节点。</li>\n<li>这样一来，表被改造成了一个环，</li>\n<li>从而也就没有了严格意义上的头尾节点，所以这种循环链表中我们通常会用一个<strong>当前指针</strong>（current）来代替原来的头尾指针。</li>\n</ul>\n<h2 id=\"2-元素的插入与删除\"><a href=\"#2-元素的插入与删除\" class=\"headerlink\" title=\"2. 元素的插入与删除\"></a>2. 元素的插入与删除</h2><p>链表最大的优势是可以实现常数时间 𝑂(1) 的元素增删操作。</p>\n<p>代码操作看这里：<a href=\"https://majorli.github.io/algo_guide/ch03/sec01/318_linkedlist_2.html\">链表的C++实现</a></p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>向链表中指定位置插入一个元素的操作如下图：</p>\n<p><img src=\"https://majorli.github.io/algo_guide/_images/317_linkedlist_ins.png\" alt=\"../../_images/317_linkedlist_ins.png\"></p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p><img src=\"https://majorli.github.io/algo_guide/_images/317_linkedlist_era.png\" alt=\"../../_images/317_linkedlist_era.png\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clx8i4fa00001qt3ad635cvq4","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa6000eqt3ahep47xd7"},{"post_id":"clx8i4fa40008qt3acmj87rfq","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa7000hqt3a9us7clrc"},{"post_id":"clx8i4fa30006qt3a0mm81r5z","category_id":"clx8i4fa6000dqt3a3qwcafun","_id":"clx8i4fa8000pqt3aerqnh0aw"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa9000vqt3a5h2x7f2g"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4fa9000zqt3a92179z2f"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa90011qt3a7vwn7vgs"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4fa90014qt3a2kv508y1"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa90015qt3a6kwzczsy"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4fa90018qt3a0o698kj8"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4fa90019qt3agla2f0re"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4fa9001bqt3ab8ree9om"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4faa001dqt3adwtf9dp8"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4faa001fqt3a24wl06lu"},{"post_id":"clx8i4fa20003qt3a7fsk0ofs","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4faa001hqt3abl9q7n1h"},{"post_id":"clx8i4fa20003qt3a7fsk0ofs","category_id":"clx8i4fa9000xqt3a83xz2jov","_id":"clx8i4faa001jqt3aeq4cgjz9"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4faa001nqt3a326dhukf"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4faa001pqt3a4vpgan4r"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","category_id":"clx8i4fa30004qt3a7g7rhcjh","_id":"clx8i4faa001sqt3a86urbkhj"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","category_id":"clx8i4fa7000lqt3ae0p1gk20","_id":"clx8i4faa001uqt3a0e8lh10e"},{"post_id":"clx8i4fa8000oqt3aedl7dv49","category_id":"clx8i4faa001eqt3a8fivefv6","_id":"clx8i4faa001xqt3a3bkjenjc"},{"post_id":"clx8i4fa7000jqt3a9sfj6k0z","category_id":"clx8i4fa9001aqt3ah3f8aoj8","_id":"clx8i4faa001zqt3a9xml9jrw"},{"post_id":"clx8i4fa7000jqt3a9sfj6k0z","category_id":"clx8i4faa001kqt3a99ixaugs","_id":"clx8i4faa0021qt3abce0ehpj"}],"PostTag":[{"post_id":"clx8i4fa00001qt3ad635cvq4","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fa7000iqt3abn5rehaj"},{"post_id":"clx8i4fa00001qt3ad635cvq4","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fa7000kqt3ae42n5mbb"},{"post_id":"clx8i4fa20003qt3a7fsk0ofs","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fa8000tqt3agzeu4saz"},{"post_id":"clx8i4fa20003qt3a7fsk0ofs","tag_id":"clx8i4fa7000mqt3a2h9a3b8g","_id":"clx8i4fa9000wqt3a1ljcfzbc"},{"post_id":"clx8i4fa30006qt3a0mm81r5z","tag_id":"clx8i4fa8000rqt3a8ipt7k0b","_id":"clx8i4fa90010qt3ad9zo43r4"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4faa001iqt3agcn133g0"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4faa001lqt3aarfu0sl2"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4faa001oqt3adrar91bq"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4faa001qqt3abs5e07gh"},{"post_id":"clx8i4fa40007qt3a0kba3g1e","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4faa001tqt3a9wgoawz0"},{"post_id":"clx8i4fa40008qt3acmj87rfq","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4faa001vqt3ahw7jbbhi"},{"post_id":"clx8i4fa40008qt3acmj87rfq","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4faa001yqt3ahtnw7glx"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4faa0022qt3a4wphb8ij"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4faa0023qt3agze1230i"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4fab0025qt3a73ghc6tq"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4fab0026qt3a1pc72ml7"},{"post_id":"clx8i4fa5000bqt3a3kolhmav","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4fab0028qt3a6fhz8d1f"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fab002aqt3a8hgeczzq"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fab002bqt3a2bl459fs"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4fab002dqt3a2l560b4a"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4fab002eqt3aectf1rca"},{"post_id":"clx8i4fa5000cqt3a8d95h4zu","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4fab002gqt3a6lqee4gr"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fab002iqt3afbjuhao2"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fab002jqt3aety6f6nw"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4fab002lqt3a0m9jb78i"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4fab002mqt3acfrb8xhq"},{"post_id":"clx8i4fa6000gqt3a0ocxgi1y","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4fab002oqt3afolbbzcu"},{"post_id":"clx8i4fa7000jqt3a9sfj6k0z","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fab002pqt3ahzc38ls4"},{"post_id":"clx8i4fa7000jqt3a9sfj6k0z","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fab002rqt3a3dnj2ogm"},{"post_id":"clx8i4fa7000jqt3a9sfj6k0z","tag_id":"clx8i4fab002hqt3a2br69oan","_id":"clx8i4fab002sqt3a2n5wg9o3"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fac002uqt3a2n0ldslm"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fac002vqt3a8tydenar"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4fac002xqt3aa6oeg5lv"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4fac002yqt3age9z7hhg"},{"post_id":"clx8i4fa7000nqt3a53s41qjq","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4fac0030qt3aa4fcd1ul"},{"post_id":"clx8i4fa8000oqt3aedl7dv49","tag_id":"clx8i4fa8000rqt3a8ipt7k0b","_id":"clx8i4fac0031qt3ac1z59nt9"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fac0034qt3a7xgr7i8n"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fac0035qt3a05vr3pek"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4fac0037qt3afkcma9fv"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4fac0038qt3a5zvd4cqp"},{"post_id":"clx8i4fa8000sqt3a2m8wh971","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4fac003aqt3adiniga06"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","tag_id":"clx8i4fa30005qt3a8syybmck","_id":"clx8i4fac003bqt3a96eb6jtr"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","tag_id":"clx8i4fa4000aqt3a5ydb77y5","_id":"clx8i4fac003cqt3a7e1646lg"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","tag_id":"clx8i4fa90013qt3acvi9c1it","_id":"clx8i4fac003dqt3a2x30a0jh"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","tag_id":"clx8i4fa90017qt3a34c7a4tf","_id":"clx8i4fac003eqt3accqhdzgf"},{"post_id":"clx8i4fa8000uqt3a7duqdymp","tag_id":"clx8i4fa9001cqt3a9iu7ejz4","_id":"clx8i4fac003fqt3ae31w7308"}],"Tag":[{"name":"cpp","_id":"clx8i4fa30005qt3a8syybmck"},{"name":"计算机","_id":"clx8i4fa4000aqt3a5ydb77y5"},{"name":"QT","_id":"clx8i4fa7000mqt3a2h9a3b8g"},{"name":"Blog","_id":"clx8i4fa8000rqt3a8ipt7k0b"},{"name":"leetcode","_id":"clx8i4fa90013qt3acvi9c1it"},{"name":"秋招","_id":"clx8i4fa90017qt3a34c7a4tf"},{"name":"算法","_id":"clx8i4fa9001cqt3a9iu7ejz4"},{"name":"debug","_id":"clx8i4fab002hqt3a2br69oan"}]}}